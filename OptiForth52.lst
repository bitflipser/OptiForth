
AVRASM ver. 2.1.42  C:\of5.2\avr\OptiForth52.asm Sat Dec 05 20:00:18 2020

C:\of5.2\avr\OptiForth52.asm(50): Including file 'C:\of5.2\avr\of52_config.inc'
C:\of5.2\avr\of52_config.inc(24): Including file 'C:\Program Files\Atmel\AVR Tools\AvrAssembler2\Appnotes\m328pdef.inc'
C:\of5.2\avr\OptiForth52.asm(53): Including file 'C:\of5.2\avr\of_macros.inc'
C:\of5.2\avr\OptiForth52.asm(58): warning: Register r2 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(63): warning: Register r8 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(76): warning: Register r19 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(79): warning: Register r12 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(82): warning: Register r14 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(89): warning: Register r26 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(90): warning: Register r27 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(91): warning: Register r30 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(92): warning: Register r31 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(94): warning: Register r16 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(95): warning: Register r0 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(96): warning: Register r26 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(97): warning: Register r30 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(100): warning: Register r10 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(103): warning: Register r20 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(107): warning: Register r24 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(158): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
C:\of5.2\avr\OptiForth52.asm(159): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
C:\of5.2\avr\OptiForth52.asm(160): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
C:\of5.2\avr\OptiForth52.asm(1412): warning: Register r16 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(1413): warning: Register r16 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(1414): warning: Register r16 already defined by the .DEF directive
C:\of5.2\avr\OptiForth52.asm(1415): warning: Register r26 already defined by the .DEF directive
                 
                 
                 ;                                                                                  *
                 ;    Filename:      OptiForth52.asm                                                *
                 ;    Date:          05.12.2020                                                     *
                 ;    File Version:  5.2                                                            *
                 ;    MCU:           Atmega328/P                                                    *
                 ;    Copyright:     bitflipser                                                     *
                 ;    Author:        bitflipser                                                     *
                 ;                                                                                  * 
                 ;***********************************************************************************
                 ; MIT License                                                                      *
                 ;                                                                                  *
                 ; Copyright (c) 2020 bitflipser                                                    *
                 ;                                                                                  *
                 ; Permission is hereby granted, free of charge, to any person obtaining a copy     *
                 ; of this software and associated documentation files (the "Software"), to deal    *
                 ; in the Software without restriction, including without limitation the rights     *
                 ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell        *
                 ; copies of the Software, and to permit persons to whom the Software is            *
                 ; furnished to do so, subject to the following conditions:                         *
                 ;                                                                                  *
                 ; The above copyright notice and this permission notice shall be included in all   *
                 ; copies or substantial portions of the Software.                                  *
                 ;                                                                                  *
                 ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR       *
                 ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,         *
                 ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE      *
                 ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER           *
                 ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,    *
                 ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    *
                 ; SOFTWARE.                                                                        *
                 ;                                                                                  *
                 ;***********************************************************************************
                 ;                                                                                  *
                 ; OptiForth is a standalone Forth system for AVR ATmega microcontrollers that can  *
                 ; flash their own flash memory.                                                    *
                 ;                                                                                  *
                 ; It is based on Mikael Nordman's FlashForth 5.0 (https://flashforth.com)          *
                 ;                                                                                  *
                 ; Optimized and tested for the ATmega328P/Arduino UNO R3 ONLY !!                   *
                 ;                                                                                  *
                 ; Modified versions of OptiForth must be clearly marked as such, in the name of    *
                 ; this file, and in the identification displayed when OptiForth starts.            *
                 ;***********************************************************************************
                 
                 ; define the OF version date string
                 #define DATE       "05.12.2020"
                 
                 ; include the OptiForth configuration file
                 .include "of52_config.inc"
                 
                 ;                                                                     *
                 ;    Filename:      of52_config.inc                                   *
                 ;    Date:          05.12.2020                                        *
                 ;    MCU:           ATmega328P                                        *
                 ;    Copyright:     bitflipser                                        *
                 ;    Author:        bitflipser                                        *
                 ;                                                                     *
                 ; *********************************************************************
                 ; OptiForth is MIT licensed                                           *
                 ; *********************************************************************
                 
                 ; OptiForth device configuration for Atmega devices
                 ;
                 .LIST
                 
                 ;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                 .equ optimizeNUM		= 1 	; optimized math and numeric conversion
                 .equ optimizingCOMPILER	= 1 	; speed optimizing compiler (may increase code size)
                 ;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                 
                 ; set to 1 when the terminal program requires LF to be send with CR
                 ; (use 'Setup - Terminal... - New Line - Receive: CR' with TeraTerm)
                 .equ CR_with_LF = 0
                 
                 ; set to 1 to allow 'Ctrl-O' to reset OptiForth from the operator UART
                 .equ CTRL_O_WARM_RESET = 1
                 
                 ; debug flash and eeprom writes
                 ; prints time [ms] for every FLASH block write, or '+' for every EEPROM byte write
                 .equ DEBUG_FLASH = 0;1
                 
                 ; set to 1 for power save when CPU is idle
                 .set IDLE_MODE = 0;1
                 
                 ; enable the cpu load measurement (for MS_TIMER <> 1 only, sets IDLE_MODE = 1)
                 ; ################# NO load measurement when MS_TIMER == 1 #####################
                 .set CPU_LOAD = 1
                 			
                 ; CPU load indicator led definitions (sets IDLE_MODE = 1)
                 .equ CPU_LOAD_LED = 1
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 0x100				; 0x100, 0x200, 0x300, 0x400 ... RAMSIZE-0x200
                 ;.equ RX0_OFF_FILL = RX0_BUF_SIZE - 50	; fill level for XOFF - not in use, no handshaking
                 
                 ; default number base
                 .equ BASE_DEFAULT = 10					; 16 = hexadecimal, 10 = decimal
                 
                 ; define the startup delay [ms] for the turnkey word
                 .equ TURNKEY_DELAY = 2000				; milliseconds
                 
                 .equ CPU_LOAD_DDR = DDRB
                 .equ CPU_LOAD_PORT= PORTB				; avr-p28: portc	arduinomega: portb	arduinouno: PORTB
                 .equ CPU_LOAD_BIT = 5					; avr-p28: pin5  	arduinomega: pin7 	arduinouno: PB5
                 .equ CPU_LOAD_LED_POLARITY = 1			; avr-p28:  0 (= low) on port turns on led 
                 										; arduino:  1 (=high) on port turns on led 
                 
                 ; oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturb the XON/XOFF flow control. 
                 ;;; The workaround is NOT to use flow control and INCREASE buffer size. Initial setup
                 ;;; is RX0_BUF_SIZE = 1024 (0x400) - the size of a SCREEN in early forth implementations.
                 ;;; You can set any multiple of 0x100 up to (RAM_SIZE - 0x200).
                 ;;; Send source files ONLY, that do not EXCEED that buffer size! Or use a terminal 
                 ;;; program capable of inserting waiting times between sending lines.
                 ;;; (You may also try the ff-shell.py from the original FlashForth 5.0-package)
                 .equ BAUDRATE0 = 115200             ; serial baudrate UART0
                 .equ U0FC_TYPE = 0                  ; 0 = no handshaking, 1 = XON/XOFF, 2=CTS/RTS
                 ;.equ U0RTS_PORT= PORTD
                 ;.equ U0RTS_DDR = DDRD
                 ;.equ U0RTS_BIT = 3
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE    = 64       ; 32 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 90                   ; 80 chars tib size + 10 chars hold area
                 
                 ; =============================================================================
                 ; =============================================================================
                 ; =============================================================================
                 ; ############## options requiring reburning of bootloader part ###############
                 ; =============================================================================
                 ; =============================================================================
                 ; =============================================================================
                 
                 .equ withBOOTLOADER	= 0;1 			; append bootloader part (needs programmer)
                 
                 ; define the UART used for the operator
                 .equ OPERATOR_UART	= 0 			; 0 or 1 (requires reburning of bootloader)
                 
                 ;;; UART1 configuration	(not on ATmega328/p)
                 .equ BAUDRATE1 = 38400              ; Serial baudrate UART1
                 .equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 .equ U1RTS_PORT= PORTD
                 .equ U1RTS_DDR = DDRD
                 .equ U1RTS_BIT = 4
                 
                 .equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 .equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ; select the timer to use for the system millisecond ticks (0, 1, 2)
                 .equ MS_TIMER = 0					; 0, 1, 2 (requires reburning of bootloader)
                 
                 ; ############### NO load measurement when MS_TIMER = 1 #####################
                 	.if MS_TIMER == 1
                 	.endif
                 ; ############################################################################
                 
                 .if (CPU_LOAD == 1) || (CPU_LOAD_LED == 1)
                 	.set IDLE_MODE = 1
                 .endif
                 
                 #if defined(__ATmega2560__)
                 #elif defined(__ATmega328P__)
                 #define partstring "ATmega328P"
                 #elif defined(__ATmega328__)
                 #elif defined(__ATmega128__)
                 #elif defined(__ATmega2561__)
                 #elif defined(__ATmega644__)
                 #else
                 #endif
                 
                 .if MS_TIMER == 0
                   .ifdef OC0Aaddr
                 	.equ MS_TIMER_ADDR = OC0Aaddr
                   .else
                   .endif
                 .endif
                 
                 .if MS_TIMER == 1
                   .ifdef OC1Aaddr
                   .else
                   .endif
                 .endif
                 
                 .if MS_TIMER == 2
                   .ifdef OC2Aaddr
                   .else
                   .endif
                 .endif
                 
                 .LIST
                 
                 ; Register definitions
                   .def UP		= R2		; not in interrupt
                    .def upL		= R2		; not in interrupt
                    .def upH		= R3		; not in interrupt
                   .def r_one	= R6		; read only one
                   .def r_zero	= R7		; read only zero
                   .def #hold	= R8		; not in interrupt (used by <# # #s #>)
                   .def t8		= R8		; not in interrupt
                   .def wflags	= R9		; not in interrupt
                 
                 .if CPU_LOAD == 1
                 	  .def loadreg	  = R18
                 .else
                 .endif
                 
                   .def X_intSafe	=  R4 	; 16 bit, interrupt only !
                 ;   .def X_intSafeL	=   R4	; interrupt only !
                 ;   .def X_intSafeH	=   R5	; interrupt only !
                   .def INTvector	= R19	; interrupt only !
                   .def SREG_intSafe = R19 	; interrupt only !
                 
                   .def IBASE		= R12	; not in interrupt
                    .def ibaseL		= R12	; not in interrupt
                    .def ibaseH		= R13	; not in interrupt
                   .def MS_COUNT		= R14	; not in interrupt
                    .def ms_countL	= R14	; not in interrupt
                    .def ms_countH	= R15	; not in interrupt
                 
                   .def t0 = R16		.equ regt0   = 0x00
                   .def t1 = R17		.equ regt1   = 0x10
                   .def t2 = R0          	; not in interrupt (see 'OF_ISR' and 'OF_ISR_EXIT')
                   .def t3 = R1          	; not in interrupt (------------------------------)
                   .def t4 = R26				; XL
                   .def t5 = R27				; XH
                   .def t6 = R30				; ZL
                   .def t7 = R31				; ZH
                 
                   .def t1t0 = R16	.equ regt1t0 = 0x00		; 16-bit
                   .def t3t2 = R0							; 16-bit
                   .def t5t4 = R26	.equ regt5t4 = 0xa0		; 16-bit (=X)
                   .def t7t6 = R30	.equ regt7t6 = 0xe0		; 16-bit (=Z)
                 
                   .def A  = R10				; A register
                    .def al = R10
                    .def ah = R11
                   .def P  = R20				; P register and FOR..LOOP INDEX variable
                    .def pl = R20
                    .def ph = R21	.equ regP	= 0x40
                 
                   .def TOP  = R24	.equ regTOP = 0x80
                    .def tosl = R24	  .equ regtosl= 0x80
                    .def tosh = R25	  .equ regtosh= 0x90
                 					.equ regX	= 0xa0
                 					.equ regZ	= 0xe0
                 
                   .def FLAGS1 = R22     	; not in interrupt
                   .def FLAGS2 = R23     	; not in interrupt
                   .equ FLAGS3 = GPIOR0
                 
                 
                 ; symbol naming compatilibity
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 	.equ UDR0_=UDR0
                 	.equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 	.equ SPMEN=SELFPRGEN
                 .endif
                 
                 .ifndef EEWE
                 	.equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 	.equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .elif OPERATOR_UART == 0
                 	.equ OP_TX_=TX0_
                 	.equ OP_RX_=RX0_
                 	.equ OP_RXQ=RX0Q
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/ 8/BAUDRATE0) - 1		; double speed mode
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ; Hz
                 	.equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 	.equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 	.equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                  .ifdef TCCR0B
                 	.equ ms_pre_tmr0   = 3
                  .endif
                  .ifdef TCCR0
                  .endif
                  .ifdef TCCR2B
                 	.equ ms_pre_tmr2   = 4
                  .endif
                  .ifdef TCCR2
                  .endif
                 .else 					; FREQ_OSC >= 16384000 Hz
                  .ifdef TCCR0B
                  .endif
                  .ifdef TCCR0
                  .endif
                  .ifdef TCCR2B
                  .endif
                  .ifdef TCCR2
                  .endif
                 .endif
                 
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*128/100000)
                 
                 ;..............................................................................
                 ;program specific constants (literals used in code)
                 ;..............................................................................
                 ; flash page size
                 .equ PAGESIZEB=PAGESIZE*2		; page size in bytes 
                 
                 ; forth word header flags
                 .equ NFA		= 0x80			; name field mask
                 .equ IMMED		= 0x40			; immediate mask
                 .equ INLINE		= 0x20			; inline mask for 1, 2 and 3 cell code
                 .equ COMPILE	= 0x10			; compile only mask
                 .equ NFAmask	= 0x0f			; name field length mask
                 
                   .if optimizingCOMPILER == 1
                 	.equ INLINE4	= 0x20			; inline mask for 4 cell code
                 	.equ INLINE5	= 0x20			; inline mask for 5+ cell code
                   .else
                   .endif
                 
                 .equ NFAbit		= 7
                 .equ IMMEDbit	= 6
                 .equ INLINEbit	= 5
                 .equ COMPILEbit	= 4
                 
                 ; FLAGS3 (GPIOR0)
                 ;----------------
                 ;						= 7
                 ;						= 6
                 ;						= 5
                 ;						= 4
                 .equ fLEAVE 			= 3		; LEAVE encountered in DO..LOOP
                 .equ fLOCK				= 2		; write protect EEPROM and FLASH
                 .equ idirty				= 1		; flash write buffer modified
                 .equ fFLASH_PAGE_CLEAR	= 0		; actual flash page in erased state -> no need to erase before flushing buffer
                 
                 
                 ; FLAGS2 (R23)
                 ;-------------
                 .equ fSTATE			= 7		; 0 = interpret, 1 = compile
                 ;+++++++++++++ do not change the following two bit positions ++++++++++++
                 .equ fIMMED			= IMMEDbit	; (6) create an IMMEDIATE-marked word
                 .equ fINLINE		= INLINEbit ; (5) create an INLINE-marked word
                 ;+++++++++++++ do not change the upper two bit positions ++++++++++++++++
                 .equ fDOTsign		= 4		; write '-' sign 
                 .equ fWORDSall		= 3		; list all words in WORDS
                 .equ fDUMPxxx		= 3		; DUMP 3-digit numbers (for base < 16)
                   .if IDLE_MODE == 0
                   .else
                 	.equ fTX0pending= 2		; waiting for UDRE0 (enable UDRIE0 in 'IDLE_LOAD')
                 	.equ fIDLE		= 1		; 0 = busy, 1 = idle
                   .endif
                 .equ fLOADled		= 0		; 0 = no load-LED, 1 = load-LED on
                 
                 
                 ; FLAGS1 (R22)		; used in COMPILE-state only
                 ;-------------
                 .equ fLIT		= 7			; literal compiled
                 ;.equ noclear	= 6			; dont clear optimisation flags (replaced by doclear to save space in 'constant')
                 .equ doclear	= 6			; clear optimization flags
                 .equ idup		= 5			; use dupzeroequal instead of zeroequal
                 .equ izeroeq	= 4			; use brne instead of breq if zeroequal
                 .equ f2LIT		= 3			; 2 subsequent literals (used by '!', 'c!', 'mtst', 'mtst0', 'mset', 'mclr')
                 .equ iLITeq		= 2			; 'LIT =' compiled
                 .equ fTAILC		= 1			; prevent tail jump optimization
                 .equ icarryeq	= 0			; use brcs instead of brne
                 
                 ;;; for flow Control
                 .equ XON	= 0x11
                 .equ XOFF	= 0x13
                 
                 .equ CR_	= 0x0d
                 .equ LF_	= 0x0a
                 .equ BS_	= 0x08
                 .equ TAB_	= 0x09
                 
                 ;;; memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 2 kB of RAM    (ATmega328)
                 .equ PEEPROM = RAMEND+1               ; 1 kB of EEPROM (ATmega328)
                 
                 .if (FLASHEND == 0x1ffff)             ; 128 Kwords FLASH
                 .elif (FLASHEND == 0xffff)              ; 64 Kwords FLASH
                 .elif (FLASHEND == 0x7fff)              ; 32 Kwords FLASH
                 .elif (FLASHEND == 0x1fff)              ; 8  Kwords FLASH
                 .elif (FLASHEND == 0x3fff)              ; 16 Kwords FLASH
                 	.equ OFLASH = 0x8000                  ; 32 Kbytes available for OptiForth
                 	.equ PFLASH = OFLASH
                 	.equ RAMPZV  = 0
                 	.set KERNEL_SIZE = 0x1101
                 ;=================================================================================
                 .endif
                 
                 	.if CR_with_LF == 1
                 	.endif
                 	.if CPU_LOAD_LED == 1
                 		.set KERNEL_SIZE = KERNEL_SIZE +  0x11
                 	.endif
                 	.if CPU_LOAD == 1
                 		.set KERNEL_SIZE = KERNEL_SIZE +  0x23
                 	.endif
                 	.if IDLE_MODE == 1
                 		.set KERNEL_SIZE = KERNEL_SIZE +  0x1a
                 	.endif
                 	.if DEBUG_FLASH == 1
                 	.endif
                 	.if optimizeNUM == 1
                 		.set KERNEL_SIZE = KERNEL_SIZE +  0xd4
                 	.endif
                 	.if optimizingCOMPILER == 1
                 		.set KERNEL_SIZE = KERNEL_SIZE + 0x148
                 	.endif
                 
                 .equ BOOT_SIZE   =0x100
                 .equ BOOT_START  =FLASHEND   - BOOT_SIZE + 1  ; atm128: 0xff00, atm328: 0x3f00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  high values for memory areas
                 .equ FLASH_HI  = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI = PEEPROM + EEPROMEND
                 .equ RAM_HI    = RAMEND
                         
                 ;;; USER AREA for the OPERATOR task
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; user variables and area
                 .equ us0=          -28         ; start of parameter stack
                 .equ ur0=          -26         ; start of ret stack
                 .equ uemit=        -24         ; user EMIT vector
                 .equ ukey=         -22         ; user KEY vector
                 .equ ukeyq=        -20         ; user KEY? vector
                 .equ ubase=        -18         ; number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; task area pointer
                 .equ ulink=        -12         ; task link
                 .equ ustatus=      -10
                 .equ uflg=         -9
                 .equ usource=      -8          ; two cells
                 .equ utoin=        -4          ; input stream
                 .equ ursave=       -2          ; saved ret stack pointer
                 .equ uhp=           0          ; hold pointer
                 
                 
                 ;;; variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
                 .org SRAM_START
000100           rbuf0:        .byte RX0_BUF_SIZE		; do not move rbuf0 away from SRAM_START
000200           ibuf:         .byte PAGESIZEB			; must (!) be placed on page boundary (0x..00)
000280           ivec:         .byte INT_VECTORS_SIZE	; must not (!) reach into next page
                 
                 rx0queue:
0002b4           rbuf0_wr:    .byte 2		.equ _wr0=0		.equ _wr1=1
0002b6           rbuf0_rd:    .byte 2		.equ _rd0=2		.equ _rd1=3
0002b8           rbuf0_lv:    .byte 2		.equ _lv0=4		.equ _lv1=5
                 
                 .ifdef UCSR1A
                 .endif
                 
                 RAMvarBase:
0002ba           dpSTART:    .byte 2		.equ _dpSTART	=dpSTART -RAMvarBase
                 ; DP's and LATEST in RAM
0002bc           dpFLASH:    .byte 2		.equ _dpFLASH	=dpFLASH -RAMvarBase
0002be           dpEEPROM:   .byte 2		.equ _dpEEPROM	=dpEEPROM-RAMvarBase
0002c0           dpRAM:      .byte 2		.equ _dpRAM		=dpRAM   -RAMvarBase
0002c2           dpLATEST:   .byte 2		.equ _dpLATEST	=dpLATEST-RAMvarBase
                 
0002c4           iaddrl:     .byte 1
0002c5           iaddrh:     .byte 1
                 
                 .ifdef RAMPZ
                 .endif
                 
                 .if CPU_LOAD == 1       
0002c6           	load_res:	.byte 1			; load result [%]
                 .endif
                 
0002c7           litbuf0:    .byte 1				; used in COMPILE-state only
                 ;litbuf1:    .byte 1
                 .equ litbuf1 = GPIOR2			; used in COMPILE-state only
                 
0002c8           LEAVEadr:	.byte 2				; used in COMPILE-state only
                 .equ _LEAVEadr	=LEAVEadr -RAMvarBase
                 
                 ;cse:    .byte 1 				; current data section 0=FLASH, 2=EEPROM, 4=RAM
                 .equ cse = GPIOR1
                 ;state:   .byte 1 				; compilation state 0=INTERPRET, 1=COMPILE
                 ;++ moved to fSTATE in FLAGS2
                 
0002ca           uvars:   .byte (-us0)
0002e6           up0:     .byte 2
0002e8           urbuf:   .byte ursize
000328           usbuf:   .byte ussize
000368           utibbuf: .byte utibsize
                 dpdata:
                 
                 .eseg
                 .org 0
000000 ff ff     		.dw 0xffff				; force first cell of EEPROM to 0xffff
                 
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .cseg
                 .org KERNEL_START
                 
                 	.if (FLASHEND == 0x1ffff)
                 		.ifdef MCUSR
                 		.else
                 		.endif
                 	.endif
                 ;***************************************************
                 FLASHHI:
002b95 d729      		.dw		FLASH_HI
002b96 0cff      		.dw		EEPROM_HI
002b97 08ff      		.dw		RAM_HI
                 
                 MEMQADDR_N:
002b98 dd7e      		fdw		ROM_N
002b99 dd8a      		fdw		EROM_N
002b9a dd9a      		fdw		FRAM_N
                 
                 ;;; ************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 20
                 WARMLIT:
002b9b 0364      		.dw		utibbuf-4			; S0
002b9c 0327      		.dw		usbuf-1				; R0
002b9d f602      		fdw		OP_TX_
002b9e f62e      		fdw		OP_RX_
002b9f f674      		fdw		OP_RXQ
002ba0 000a      		.dw		BASE_DEFAULT		; BASE
002ba1 0368      		.dw		utibbuf				; TIB
002ba2 db1c      		fdw		OPERATOR_AREA		; TASK
002ba3 02e6      		.dw		up0					; Task link
                 ;;; ************************************************
                 ;;; EMPTY dictionary data
                 ; *******************************************************************
                 .equ coldlitsize=12
                 COLDLIT:
002ba4 0000      STARTV: .dw		0
002ba5 8000      DPC:    .dw		OFLASH
002ba6 090c      DPE:    .dw		ehere
002ba7 03c2      DPD:    .dw		dpdata
002ba8 f456      LW:     fdw		lastword
002ba9 e77e      STAT:   fdw		DOTSTATUS
                 ;*******************************************************************
                 
                 
                 ; PAD ( -- a-addr )				user pad buffer
002baa fa26      		fdw		PCSTORE_L
                 PAD_L:
002bab 7083
002bac 6461      		.db		NFA|3,"pad"
                 PAD:
002bad 01f1      		movw Z,UP				; TIB 
002bae 9770      		sbiw Z,(-utib)			;	( TIU @ )
002baf 939a
002bb0 938a      		pushtos
002bb1 9101      		ld t0,Z+
002bb2 9111      		ld t1,Z+
002bb3 9181      		ld tosl,Z+				; TIBSIZE 
002bb4 9191      		ld tosh,Z+				;	( TASK @ 8 + @ )
002bb5 9608      		adiw TOP,8
002bb6 01fc      		movw Z,TOP
002bb7 58f0      		sub_pflash_z
002bb8 9185      		lpm tosl,Z+
002bb9 9195      		lpm tosh,Z+
                 
002bba 0f80      		add tosl,t0				; +
002bbb 1f91      		adc tosh,t1
002bbc 9508      		ret						; 16 / 27+4
                 
                 
002bbd d7f4      		fdw		BSLASH_L
                 ; [ ( -- )						enter interpretive state
                 LEFTBRACKET_L:
002bbe 5bc1      		.db		NFA|IMMED|1,"["
                 ;LEFTBRACKET:
002bbf 777f      		cbr FLAGS2,(1<<fSTATE)
002bc0 9508      		ret
                 
                 
002bc1 efac      		fdw		DOTS_L
                 DOTQUOTE_L:
002bc2 2ed2
002bc3 ff22      		.db		NFA|IMMED|COMPILE|2,".",0x22,0xff
                 ;DOTQUOTE:
002bc4 d425      		rcall SQUOTE
002bc5 d7ee      		rcall DOCOMMAXT
002bc6 efda      		fdw TYPE
002bc7 9508      		ret
                 
                 
002bc8 f62a      		fdw		RX0_L
                 ; RP@							fetch the return stack pointer
                 RPFETCH_L:
002bc9 72b3
002bca 4070      		.db		NFA|INLINE|COMPILE|3,"rp@"
                 ;RPFETCH:
002bcb 939a
002bcc 938a      		pushtos
002bcd b78d      		in tosl,spl
002bce b79e      		in tosh,sph				; 4 / 6
002bcf 9508      		ret
                 
                 
002bd0 ebf6      		fdw		CHAR_L
                 ; CELL ( -- n )					size of one cell
                 CELL_L:
002bd1 63a4
002bd2 6c65
002bd3 ff6c      		.db		NFA|INLINE4|4,"cell",0xff
                 ;CELL:
002bd4 939a
002bd5 938a      		pushtos
                 ;CELL_0:
002bd6 e082      		ldi tosl,2
002bd7 e090      		ldi tosh,0				; 4 / 6
002bd8 9508      		ret
                 
                 
002bd9 f95c      		fdw		DECIMAL_L
                 ; ALIGNED ( addr -- a-addr )	align given addr
                 ALIGNED_L:
002bda 61a7
002bdb 696c
002bdc 6e67
002bdd 6465      		.db		NFA|INLINE|7,"aligned"
                 ;ALIGNED:
002bde 9601      		adiw TOP,1
002bdf 7f8e      		cbr tosl,1				; 2 / 3
002be0 9508      		ret
                 
                 
002be1 d7d0      		fdw		CELLS_L
                 ; CELL+ ( a-addr1 -- a-addr2 )	add cell size
                 ;	2 + ;
                 CELLPLUS_L:
002be2 63a5
002be3 6c65
002be4 2b6c      		.db		NFA|INLINE|5,"cell+"
                 ;CELLPLUS:
002be5 9602      		adiw TOP,2				; 1 / 2
002be6 9508      		ret
                 
                 
002be7 d7de      		fdw		CHARPLUS_L
                 ; CELLS ( n1 -- n2 )			cells->adrs units
                 CELLS_L:
002be8 63a5
002be9 6c65
002bea 736c      		.db		NFA|INLINE|5,"cells"
                 ;CELLS:
002beb 0f88      		lsl tosl
002bec 1f99      		rol tosh				; 2 / 2
002bed 9508      		ret
                 
                 
002bee d7ea      		fdw		CHARS_L
                 ; CHAR+ ( c-addr1 -- c-addr2 )	add char size
                 CHARPLUS_L:
002bef 63a5
002bf0 6168
002bf1 2b72      		.db		NFA|INLINE|5,"char+"
                 ;CHARPLUS:
002bf2 9601      		adiw TOP,1				; 1 / 2
002bf3 9508      		ret
                 
                 
002bf4 ea22      		fdw		CMOVE_L
                 ; CHARS ( n1 -- n2 )			chars->adrs units
                 CHARS_L:
002bf5 63a5
002bf6 6168
002bf7 7372      		.db		NFA|INLINE|5,"chars"
                 ;CHARS:
002bf8 9508      		ret
                 
                 
002bf9 ed28      		fdw		RIGHTBRACKET_L
                 ; \								skip the rest of the line
                 BSLASH_L:
002bfa 5cc1      		.db		NFA|IMMED|1,0x5c
                 ;BSLASH:
002bfb 01f1      		movw Z,UP
002bfc 9736      		sbiw Z,(-(usource+2))
002bfd 9101      		ld t0,Z+
002bfe 9111      		ld t1,Z+
                 		;adiw Z,<..utoin>		; Z already at utoin
002bff 9301      		st Z+,t0
002c00 9311      		st Z+,t1
002c01 7b6f      		cbr FLAGS1,(1<<doclear)	; don't clear flags in case of \
002c02 9508      		ret
                 
                 
002c03 da54      		fdw		MEMHI_L
                 ; ei ( -- )						enable interrupts
                 EI_L:
002c04 65a2
002c05 ff69      		.db		NFA|INLINE|2,"ei",0xff
002c06 9478      		sei						; 1 / 1
002c07 9508      		ret
                 
                 
002c08 f246      		fdw		DO_L
                 ; di  ( -- )					disable interrupts
                 DI_L:
002c09 64a2
002c0a ff69      		.db		NFA|INLINE|2,"di",0xff
002c0b 94f8      		cli						; 1 / 1
002c0c 9508      		ret
                 
                 
002c0d e9b2      		fdw		SIGNQ_L
                 ; RSAVE ( -- a-addr )			saved return stack pointer
                 RSAVE_L:
002c0e 72a5
002c0f 6173
002c10 6576      		.db		NFA|INLINE4|5,"rsave"
                 ;RSAVE_:
002c11 939a
002c12 938a
002c13 01c1
002c14 9702      		inline_DOUSER ursave	; 4 / 7
002c15 9508      		ret
                 
                 
002c16 f174      		fdw		UNTIL_L
                 ; ULINK ( -- a-addr )			link to next task
                 ULINK_L:
002c17 75a5
002c18 696c
002c19 6b6e      		.db		NFA|INLINE4|5,"ulink"
                 ;ULINK_:
002c1a 939a
002c1b 938a
002c1c 01c1
002c1d 970c      		inline_DOUSER ulink		; 4 / 7
002c1e 9508      		ret
                 
                 
002c1f f140      		fdw		THEN_L
                 ; TASK ( -- a-addr )			TASK pointer
                 TASK_L:
002c20 74a4
002c21 7361
002c22 ff6b      		.db		NFA|INLINE4|4,"task",0xff
                 ;TASK:   
002c23 939a
002c24 938a
002c25 01c1
002c26 970e      		inline_DOUSER utask		; 4 / 7
002c27 9508      		ret
                 
                 
002c28 f8ee      		fdw		ICOMMA_L
                 ; HP ( -- a-addr )				HOLD pointer
                 HP_L:
002c29 68a2
002c2a ff70      		.db		NFA|INLINE|2,"hp",0xff
                 ;HP:
002c2b 939a
002c2c 938a      		pushtos
002c2d 01c1      		movw TOP,UP			; 3 / 5
                 		;sbiw TOP,(-uhp)		; uhp = 0
002c2e 9508      		ret
                 
                 .if IDLE_MODE == 0
                 .elif IDLE_MODE == 1
002c2f db98      		fdw		BUSY_L
                 .else .error "illegal value: IDLE_MODE"
                 .endif
                 ; BASE ( -- a-addr )			holds conversion radix
                 BASE_L:
002c30 62a4
002c31 7361
002c32 ff65      		.db		NFA|INLINE4|4,"base",0xff
                 ;BASE:
002c33 939a
002c34 938a
002c35 01c1
002c36 9742      		inline_DOUSER ubase		; 4 / 7
002c37 9508      		ret
                 
                 
002c38 e28e      		fdw		USER_L
                 ; umin ( u1 u2 -- u )			unsigned minimum
                 ;	2DUP U> IF SWAP THEN DROP ;
                 UMIN_L:
002c39 75a4
002c3a 696d
002c3b ff6e      		.db		NFA|INLINE5|4,"umin",0xff
                 UMIN:
002c3c 9109
002c3d 9119      		pop_t1t0
                 UMIN_0:
002c3e 1780      		cp tosl,t0
002c3f 0791      		cpc tosh,t1
002c40 f008      		brcs PC+2
002c41 01c8      		  movw TOP,t1t0			; 6 / 8
002c42 9508      		ret
                 
                 
002c43 d872      		fdw		UMIN_L
                 ; umax ( u1 u2 -- u )			unsigned maximum
                 ;	2DUP U< IF SWAP THEN DROP ;
                 UMAX_L:
002c44 75a4
002c45 616d
002c46 ff78      		.db		NFA|INLINE5|4,"umax",0xff
                 UMAX:
002c47 9109
002c48 9119      		pop_t1t0
                 UMAX_0:
002c49 1708      		cp t0,tosl
002c4a 0719      		cpc t1,tosh
002c4b f008      		brcs PC+2
002c4c 01c8      		  movw TOP,t1t0			; 6 / 8
002c4d 9508      		ret
                 
                 
002c4e edfe      		fdw 	TICKS_L
                 SWOPMINUS_L:
002c4f 73a5
002c50 6177
002c51 2d70      		.db		NFA|INLINE4|5,"swap-"
                 SWOPMINUS:
002c52 9109
002c53 9119      		pop_t1t0
                 SWOPMINUS_0:
002c54 1b80      		sub tosl,t0
002c55 0b91      		sbc tosh,t1				; 4 / 6
002c56 9508      		ret
                 
                 
002c57 f97c      		fdw		BIN_L
                 AND_L:
002c58 61a3
002c59 646e      		.db		NFA|INLINE4|3,"and"
                 AND_:
002c5a 9109
002c5b 9119      		pop_t1t0
                 AND_0:
002c5c 2380      		and tosl,t0
002c5d 2391      		and tosh,t1				; 4 / 6
002c5e 9508      		ret
                 
                 
002c5f fa88      		fdw		PSTORE_L
                 OR_L:
002c60 6fa2
002c61 ff72      		.db		NFA|INLINE4|2,"or",0xff
                 OR_:
002c62 9109
002c63 9119      		pop_t1t0
                 OR_0:
002c64 2b80      		or tosl,t0
002c65 2b91      		or tosh,t1				; 4 / 6
002c66 9508      		ret
                 
                 
002c67 da18      		fdw		ZFL_L
                 XOR_L:
002c68 78a3
002c69 726f      		.db		NFA|INLINE4|3, "xor"
                 XOR_:
002c6a 9109
002c6b 9119      		pop_t1t0
                 XOR_0:
002c6c 2780      		eor tosl,t0
002c6d 2791      		eor tosh,t1				; 4 / 6
002c6e 9508      		ret
                 
                 
002c6f edca      		fdw		LATEST_L
                 INVERT_L:
002c70 69a6
002c71 766e
002c72 7265
002c73 ff74      		.db		NFA|INLINE|6,"invert",0xff
                 ;INVERT:
002c74 9580      		com tosl
002c75 9590      		com tosh				; 2 / 2
002c76 9508      		ret
                 
                 
002c77 d8fa      		fdw		ONEMINUS_L
                 ONEPLUS_L:
002c78 31a2
002c79 ff2b      		.db		NFA|INLINE|2,"1+",0xff
                 ;ONEPLUS:
002c7a 9601      		adiw TOP,1				; 1 / 2
002c7b 9508      		ret
                 
                 
002c7c eebe      		fdw		TWOSTORE_L
                 ONEMINUS_L:
002c7d 31a2
002c7e ff2d      		.db		NFA|INLINE|2,"1-",0xff
                 ;ONEMINUS:
002c7f 9701      		sbiw TOP,1				; 1 / 2
002c80 9508      		ret
                 
                 
002c81 e42a      		fdw		TWOMINUS_L
                 TWOPLUS_L:
002c82 32a2
002c83 ff2b      		.db		NFA|INLINE|2,"2+",0xff
                 ;TWOPLUS:
002c84 9602      		adiw TOP,2				; 1 / 2
002c85 9508      		ret
                 
                 
002c86 eb56      		fdw		ABORT_L
                 TOBODY_L:
002c87 3ea5
002c88 6f62
002c89 7964      		.db		NFA|INLINE|5,">body"
                 ;TOBODY:
002c8a 9604      		adiw TOP,4				; 1 / 2
002c8b 9508      		ret
                 
                 
002c8c d904      		fdw		TWOPLUS_L
                 TWOSTAR_L:
002c8d 32a2
002c8e ff2a      		.db		NFA|INLINE|2,"2*",0xff
                 ;TWOSTAR:
002c8f 0f88      		lsl tosl
002c90 1f99      		rol tosh				; 2 / 2
002c91 9508      		ret
                 
                 
                 
002c92 fb22      		fdw		UDSTAR_L
                 UTWOSLASH_L:
002c93 75a3
002c94 2f32      		.db		NFA|INLINE|3,"u2/"
                 ;UTWOSLASH:
002c95 9596      		lsr tosh
002c96 9587      		ror tosl				; 2 / 2
002c97 9508      		ret
                 
                 
002c98 ee68      		fdw		TWOFETCH_L
                 TWOSLASH_L:
002c99 32a2
002c9a ff2f      		.db		NFA|INLINE|2,"2/",0xff
                 ;TWOSLASH:
002c9b 9595      		asr tosh
002c9c 9587      		ror tosl				; 2 / 2
002c9d 9508      		ret
                 
                 
002c9e d9ae      		fdw		DUP_L
                 DTWOSLASH_L:
002c9f 64a3
002ca0 2f32      		.db		NFA|INLINE5|3,"d2/"
002ca1 9109
002ca2 9119      		pop_t1t0
                 ;DTWOSLASH_0:
002ca3 9595      		asr tosh
002ca4 9587      		ror tosl
002ca5 9517      		ror t1
002ca6 9507      		ror t0
002ca7 931a
002ca8 930a      		push_t1t0				; 8 / 12
002ca9 9508      		ret
                 
                 
002caa d93e      		fdw		DTWOSLASH_L
                 DTWOSTAR_L:
002cab 64a3
002cac 2a32      		.db		NFA|INLINE5|3,"d2*"
002cad 9109
002cae 9119      		pop_t1t0
                 ;DTWOSTAR_0:
002caf 0f00      		lsl t0
002cb0 1f11      		rol t1
002cb1 1f88      		rol tosl
002cb2 1f99      		rol tosh
002cb3 931a
002cb4 930a      		push_t1t0				; 8 / 12
002cb5 9508      		ret
                 
                 
002cb6 f3e0      		fdw		DZEROEQUAL_L
                 DZEROLESS_L:
002cb7 64a3
002cb8 3c30      		.db		NFA|INLINE4|3,"d0<"
                 ;DZEROLESS:
002cb9 9622      		adiw Y,2				; NIP d.l
002cba 0f99      		lsl tosh
002cbb 0b88      		sbc tosl,tosl
002cbc 0b99      		sbc tosh,tosh			; 4 / 5
002cbd 9508      		ret
                 
                 
002cbe d988      		fdw		FUNLOCK_L
                 ;;; disable writes to FLASH and EEPROM
                 FLOCK_L:
002cbf 66a3
002cc0 2d6c      		.db		NFA|INLINE|3,"fl-"
002cc1 9af2      		sbi FLAGS3,fLOCK		; 1 / 1
002cc2 9508      		ret
                 
                 
002cc3 f210      		fdw		FOR_L
                 ;;; enable writes to FLASH and EEPROM
                 FUNLOCK_L:
002cc4 66a3
002cc5 2b6c      		.db		NFA|INLINE|3,"fl+"
002cc6 98f2      		cbi FLAGS3,fLOCK		; 1 / 1
002cc7 9508      		ret
                 
002cc8 fa94      		fdw		MS_L
                 ; fast RAM access
                 MFETCH_L:
002cc9 6da2
002cca ff40         	    .db		NFA|INLINE|2,"m@",0xff
                 ;MFETCH:
002ccb 01fc      		movw Z,TOP
002ccc 9181      		ld tosl,Z+
002ccd 9191      		ld tosh,Z+			; 3 / 5
002cce 9508      		ret
                 
                 
002ccf fcb2      		fdw		MIN_L
                 MCFETCH_L:
002cd0 6da3
002cd1 4063         	    .db		NFA|INLINE|3,"mc@"
                 ;MCFETCH:
002cd2 01fc      		movw Z,TOP
002cd3 9181      		ld tosl,Z+
002cd4 e090      		ldi tosh,0x00		; 3 / 4
002cd5 9508      		ret
                 
                 
002cd6 dd22      		fdw		FCY_L
                 ; DUP must not be reachable from user code with rcall
                 DUP_L:
002cd7 64a3
002cd8 7075      		.db		NFA|INLINE|3, "dup"
                 DUP:
002cd9 939a
002cda 938a      		duptos					; 2 / 4
002cdb 9508      		ret
                 
                 
002cdc d8f0      		fdw		ONEPLUS_L
                 ZEROEQUAL_L:
002cdd 30a2
002cde ff3d      		.db		NFA|INLINE|2, "0=",0xff
                 ZEROEQUAL:
002cdf 9701      		sbiw    TOP, 1
002ce0 0b88      		sbc     tosl, tosl
002ce1 0b99      		sbc     tosh, tosh		; 3 / 4
002ce2 9508      		ret
                 
                 
002ce3 d9ba      		fdw		ZEROEQUAL_L
                 ZEROLESS_L:
002ce4 30a2
002ce5 ff3c      		.db		NFA|INLINE|2, "0<",0xff
                 ZEROLESS:
002ce6 0f99      		lsl     tosh
002ce7 0b88      		sbc     tosl, tosl
002ce8 0b99      		sbc     tosh, tosh		; 3 / 3
002ce9 9508      		ret
                 
                 
002cea da00      		fdw		XA_FROM_L
                 ; store the execution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
                 X_TO_R_L:
002ceb 7883
002cec 723e      		.db		NFA|3,"x>r"
                 ;X_TO_R:
002ced 01fc      		movw Z,TOP
002cee 9189
002cef 9199      		poptos
002cf0 5890      		sub_pflash_tos
002cf1 9596      		lsr tosh
002cf2 9587      		ror tosl
002cf3 8380      		st  Z,tosl
002cf4 9392      		st -Z,tosh
                 .ifdef EIND
                 .endif
002cf5 9272      		st -Z,r_zero
002cf6 01cf      		movw TOP,Z
002cf7 9508      		ret
                 
                 
002cf8 fd12      		fdw		FEXECUTE_L
                 TO_XA_L:
002cf9 3ea3
002cfa 6178      		.db NFA|INLINE|3,">xa"
                 ;TO_XA:
002cfb 5890      		sub_pflash_tos
                 		;rampv_to_c
                 		;ror tosh
002cfc 9596      		lsr tosh
002cfd 9587      		ror tosl				; 3 / 3
002cfe 9508      		ret
                 
                 
002cff d8d0      		fdw		XOR_L
                 XA_FROM_L:
002d00 78a3
002d01 3e61      		.db NFA|INLINE|3,"xa>"
                 ;XA_FROM:
002d02 0f88      		lsl tosl
002d03 1f99      		rol tosh
002d04 5890      		add_pflash_tos			; 3 / 3
002d05 9508      		ret
                 
                 
002d06 e0ee      		 fdw    R_TO_P_L
                 PFL_L:
002d07 7083
002d08 6c66      		.db		NFA|3,"pfl"
                 ;PFL:
002d09 d69f      		rcall DOCREATE
002d0a 8000      		.dw OFLASH
                 
002d0b e0da      		fdw    STORE_P_TO_R_L
                 ;	.dw		0
                 ZFL_L:
002d0c 7a83
002d0d 6c66      		.db		NFA|3, "zfl"
                 ;ZFL:
002d0e d69a      		rcall DOCREATE
002d0f 0000      		.dw RAMPZV
                 
                 
002d10 e812      		fdw		FALSE_L
                 ; leave clear top of return stack
                 ENDIT_L:
002d11 65b5
002d12 646e
002d13 7469      		.db		NFA|COMPILE|0x20|5,"endit"
                 ;ENDIT:						; ++++ must be inlined ++++
002d14 b7fe      		 in ZH,SPH
002d15 b7ed      		 in ZL,SPL
002d16 8271      		 std Z+1,r_zero
002d17 8272      		 std Z+2,r_zero			; 4 / 6
002d18 9508      		 ret
                 
                 
002d19 d81c              fdw		 RSAVE_L
                 ; RDROP compile a pop
                 RDROP_L:
002d1a 72b5
002d1b 7264
002d1c 706f              .db		NFA|COMPILE|0x20|5,"rdrop"
                 ;RDROP:						;++++ must be inlined ++++
002d1d 910f              pop     t0
002d1e 910f              pop     t0				; 2 / 4
002d1f 9508              ret
                 
                 
002d20 ee76              fdw		SHB_L
                 STOD_L:
002d21 73a3
002d22 643e              .db		NFA|INLINE5|3,"s>d"
                 ;STOD:
002d23 939a
002d24 938a              duptos
002d25 0f99              lsl tosh				; mov sign to C
002d26 0b88              sbc tosl,tosl
002d27 0b99      		sbc tosh,tosh			; 5 / 7
002d28 9508      		ret
                 
                 
002d29 d852              fdw		 HP_L
                 MEMHI_L:
002d2a 6882
002d2b ff69              .db		NFA|2,"hi",0xff
                 ;MEMHI:
002d2c 939a
002d2d 938a      		 pushtos
                 ;MEMHI_0:
002d2e b5ea      		 in ZL,cse
002d2f 27ff      		 clr ZH
002d30 5de6      		 subi ZL, LOW(-(FLASHHI<<1))
002d31 4af8      		 sbci ZH,HIGH(-(FLASHHI<<1))
002d32 9185      		 lpm tosl,Z+
002d33 9195      		 lpm tosh,Z+
002d34 9508      		 ret
                 
                 
002d35 f49c              fdw		 A_FROM_L
                 L_FETCH_P:
002d36 40a2
002d37 0070              .db      NFA|INLINE|2,"@p", 0
                 ;FETCH_P:
002d38 939a
002d39 938a              pushtos
                 ;FETCH_P_0:
002d3a 01ca              movw TOP,pl				; 3 / 5
002d3b 9508              ret
                 
                 
002d3c d756              fdw		 PAD_L
                 ; P2+  ( n -- )					add 2 to P
                 L_PTWOPLUS:
002d3d 70a3
002d3e 2b32              .db		NFA|INLINE|3,"p2+"
                 ;PTWOPLUS:
002d3f 5f4e      		subi pl,-2
002d40 4f5f      		sbci ph,-1				; 2 / 2
002d41 9508              ret
                 
                 
002d42 f5fe              fdw		TX0_L
                 ; TIU  ( -- a-addr )			Terminal Input Buffer user variable 
                 TIU_L:
002d43 74a3
002d44 7569              .db		NFA|INLINE4|3,"tiu"
                 ;TIU:
002d45 939a
002d46 938a
002d47 01c1
002d48 9740      		 inline_DOUSER utib		; 4 / 7
002d49 9508      		 ret
                 
                 
002d4a e102              fdw		TO_PRINTABLE_L
                 ; >IN  ( -- a-addr )			holds offset into TIB
                 ; in RAM
                 TOIN_L:
002d4b 3ea3
002d4c 6e69              .db		NFA|INLINE4|3,">in"
                 TOIN:
002d4d 939a
002d4e 938a
002d4f 01c1
002d50 9704      		 inline_DOUSER utoin	; 4 / 7
002d51 9508      		 ret
                 
                 
002d52 f93a              fdw		SLASHSTRING_L
                 ; 'SOURCE ( -- a-addr )			two cells: len, adrs
                 ; in RAM
                 TICKSOURCE_L:
002d53 27a7
002d54 6f73
002d55 7275
002d56 6563              .db		NFA|INLINE4|7,"'source"
                 ;TICKSOURCE: 				; two cells !!!!!!
002d57 939a
002d58 938a
002d59 01c1
002d5a 9708      		 inline_DOUSER usource	; 4 / 7
002d5b 9508      		 ret
                 
                 
002d5c fa7a              fdw		PFETCH_L
                 PPLUS_L:
002d5d 70a2
002d5e ff2b              .db		NFA|INLINE|2,"p+",0xff
                 ;PPLUS:
002d5f 0d46              add pl,r_one
002d60 1d57              adc ph,r_zero			; 2 / 2
002d61 9508              ret   
                 
                 
002d62 da7a              fdw		L_PTWOPLUS
                 PNPLUS_L:
002d63 70a3
002d64 2b2b              .db		NFA|INLINE4|3,"p++"
                 ;PNPLUS:
002d65 0f48              add pl,tosl
002d66 1f59              adc ph,tosh
002d67 9189
002d68 9199              poptos					; 4 / 6
002d69 9508              ret
                 
                 
002d6a dafa              fdw		UKEYQ_L
                 UEMIT_L:
                 kernellink_long:
002d6b 27a5
002d6c 6d65
002d6d 7469              .db		NFA|INLINE4|5,"'emit"
                 ;UEMIT_:
002d6e 939a
002d6f 938a      		 pushtos
                 UEMIT_0:
002d70 01c1      		 movw TOP,UP
002d71 9748      		 sbiw TOP,(-uemit)		; 4 / 7
002d72 9508      		 ret
                 
                         
002d73 de38              fdw		TWODUP_L
                 UKEY_L:
002d74 27a4
002d75 656b
002d76 ff79              .db		NFA|INLINE4|4,"'key",0xff
                 ;UKEY_:
002d77 939a
002d78 938a      		 pushtos
                 UKEY_0:
002d79 01c1      		 movw TOP,UP
002d7a 9746      		 sbiw TOP,(-ukey)		; 4 / 7
002d7b 9508      		 ret
                 
                 
002d7c de28              fdw		TWODROP_L
                 UKEYQ_L:
002d7d 27a5
002d7e 656b
002d7f 3f79              .db		NFA|INLINE4|5,"'key?"
                 ;UKEYQ_:
002d80 939a
002d81 938a      		 pushtos
                 UKEYQ_0:
002d82 01c1      		 movw TOP,UP
002d83 9744      		 sbiw TOP,(-ukeyq)		; 4 / 7
002d84 9508      		 ret
                 
                 
002d85 ecbe              fdw		POSTPONE_L
                 OPERATOR_L:
002d86 6f88
002d87 6570
002d88 6172
002d89 6f74
002d8a ff72              .db		NFA|8,"operator",0xff
                 OPERATOR:
002d8b 940e 33a9 		call DOCREATE			; ### 'call..' for 'tasks' to work ###
002d8d db1c      		fdw   OPERATOR_AREA
                 OPERATOR_AREA:					; description of operator task:
002d8e 02e6      		.dw  up0				; location of the user area
002d8f 0000
002d90 0040      		.dw  0		,ursize		; size of:  user variable area	, return stack	
002d91 0040
002d92 005a      		.dw  ussize	,utibsize	;			data stack			, tib
                 
                 
002d93 db76              fdw		MTST_L
                 ; mset  ( mask addr -- )
                 ;   dup >r c@ or r> c! ;
                 MSET_L:
002d94 6da4
002d95 6573
002d96 ff74              .db		NFA|INLINE5|4,"mset",0xff
                 MSET:
002d97 9109
002d98 9119      		pop_t1t0
                 MSET_0:
002d99 01fc      		movw Z,TOP
002d9a 8180      		ld tosl,Z
002d9b 2b80      		or tosl,t0
002d9c 8380      		st Z,tosl
002d9d 9189
002d9e 9199      		poptos					; 8 / 14
002d9f 9508      		ret
                         
                 
002da0 db28              fdw		MSET_L
                 ; mclr  ( mask addr -- )
                 ;   dup >r c@ swap invert and r> c! ;
                 MCLR_L:
002da1 6da4
002da2 6c63
002da3 ff72              .db		NFA|INLINE5|4,"mclr",0xff
                 MCLR:
002da4 9109
002da5 9119      		pop_t1t0
                 MCLR_0:
002da6 01fc      		movw Z,TOP
002da7 8180      		ld tosl,Z
002da8 9500      		com t0
002da9 2380      		and tosl,t0
002daa 8380      		st Z,tosl
002dab 9189
002dac 9199      		poptos					;  9 / 15
002dad 9508      		ret
                 
                 
002dae e2b0      		fdw		PARSE_L
                 ; mtst0 ( mask addr -- )		(NO flag on stack - to be used with '0until' and '0if')
                 ;   c@ and drop ;
                 MTSTZ_L:
002daf 6da5
002db0 7374
002db1 3074      		.db		NFA|INLINE5|5,"mtst0"
                 MTSTZ:
002db2 9109
002db3 9119      		pop_t1t0				; mask in t0
                 MTSTZ_0:
002db4 01fc      		movw Z,TOP
002db5 9189
002db6 9199      		poptos
002db7 8110      		ld t1,Z
002db8 2310      		and t1,t0				; 7 / 12
002db9 9508      		ret						; leave valid Z-flag
                 
                 
002dba f304      		fdw		NEXT_L
                 ; mtst ( mask addr -- flag )
                 ;   c@ and ;
                 MTST_L:
002dbb 6da4
002dbc 7374
002dbd ff74      		.db		NFA|INLINE5|4,"mtst",0xff
                 MTST:
002dbe 9109
002dbf 9119      		pop_t1t0
                 MTST_0:
002dc0 01fc      		movw Z,TOP
002dc1 8180      		ld tosl,Z
002dc2 2380      		and tosl,t0
002dc3 e090      		ldi tosh,0x00			; 6 / 9
002dc4 9508      		ret						; leav valid Z-flag
                 
                 
                 .if IDLE_MODE == 1
002dc5 f870      			fdw		IRQ_V_L
                 	IDLE_L:
002dc6 69a4
002dc7 6c64
002dc8 ff65      			.db		NFA|INLINE|4,"idle",0xff
                 	;IDLE:
002dc9 6072      			sbr FLAGS2,(1<<fIDLE)	; 1 / 1
002dca 9508      			ret
                 
002dcb d7a2      			fdw		CELL_L
                 	BUSY_L:
002dcc 62a4
002dcd 7375
002dce ff79      			.db		NFA|INLINE|4,"busy",0xff
                 	;BUSY:
002dcf 7f7d      			cbr FLAGS2,(1<<fIDLE)	; 1 / 1
002dd0 9508      			ret
                 .endif
                 
                 
002dd1 ebec              fdw		TICK_L
                 ; #   ( ud1 -- ud2 )			convert 1 digit of output and put into PAD
                 ;   base @ ud/mod rot >digit hold ;
                 NUM_L:
002dd2 2381              .db		NFA|1,"#"
                 NUM:
                 .if optimizeNUM == 0
                 .elif optimizeNUM == 1
                 								; unsignd division 32 -- 32	, t0: rem8
002dd3 01f1      			movw Z,UP
002dd4 9772      			sbiw Z,(-ubase)
002dd5 81a0      			ld t4,Z					; base in t4
002dd6 81e8      			ldd t6,Y+0
002dd7 81f9      			ldd t7,Y+1				; ud.l: t7t6
                 									; ud.h: TOP
002dd8 2f0e      			mov t0,t6				; save LSB for digit
002dd9 30a2       			cpi t4,2
002dda f0f9      			  breq UDbinSLASHMOD
002ddb 31a0      			cpi t4,16
002ddc f089      			  breq UDhexSLASHMOD
                 			;cpi t4,8
                 			;  breq UDoctSLASHMOD	; (activate when needed)
                 			;cpi t4,4
                 			;  breq UDquadSLASHMOD	; (activate when needed)
                 
002ddd 27bb      			clr t5					; divisor.h (divisor.l = base)
002dde 2700      			clr t0
002ddf 2be8      			or t6,tosl
002de0 2bf9      			or t7,tosh
002de1 2bef      			or t6,t7
002de2 f0f9      			  breq UDbaseSM_00		; skip division for ud = 0x0000.0000. (for leading zeros in UDOTR)
                 				
                 	UDbaseSM_32:					; ( ud.l  ud.h )					u  : t5t4
002de3 d7f2      			rcall udslashmod0		; ( ud'.l	   )	ud'h in t7:t6	rem: t3t2
                 
002de4 2d00      			mov t0,t2				; rem/digit
002de5 010c      			movw t3t2,TOP			; save ud'.l for zero check in NUMS
002de6 939a
002de7 938a      			pushtos
002de8 01cf      			movw TOP,t7t6			; ( ud'.l ud'.h  )
                 			;rjmp NUM_TODIGIT
                 	NUM_TODIGIT:
002de9 300a      			cpi t0,0x0a
002dea f00c      			brlt PC+2
002deb 5d09      			  subi t0,-0x27
002dec 5d00      			subi t0,-0x30
002ded c2c2      			rjmp NUM_HOLD
                 
                 	UDhexSLASHMOD:					; 42+4
002dee 9596      			lsr tosh
002def 9587      			ror tosl
002df0 95f7      			ror t7
002df1 95e7      			ror t6
                 	UDoctSLASHMOD:					; 40+4
002df2 9596      			lsr tosh
002df3 9587      			ror tosl
002df4 95f7      			ror t7
002df5 95e7      			ror t6
                 	UDquadSLASHMOD: 				; 38+4
002df6 9596      			lsr tosh
002df7 9587      			ror tosl
002df8 95f7      			ror t7
002df9 95e7      			ror t6
                 	UDbinSLASHMOD:					; 28+4	
002dfa 9596      			lsr tosh
002dfb 9587      			ror tosl
002dfc 95f7      			ror t7
002dfd 95e7      			ror t6
                 	
002dfe 95aa      			dec t4					; base - 1
002dff 230a      			and t0,t4				; separate digit
002e00 83f9      			std Y+1,t7
002e01 83e8      			std Y+0,t6
                 	UDbaseSM_00:
002e02 010f      			movw t3t2,t7t6			; save ud'.l for zero check in NUMS
002e03 cfe5      			rjmp NUM_TODIGIT
                 .else .error "illegal value: optimizeNUM"
                 .endif
                 
                 	
002e04 fc80              fdw		PLUSSTORE_L
                 ; #S  ( ud1 -- 0. )				convert remaining digits
                 ;   begin # 2dup or 0= until ;
                 NUMS_L:
002e05 2382
002e06 ff73              .db		NFA|2,"#s",0xff
                 NUMS:
                 .if optimizeNUM == 0
                 .elif optimizeNUM == 1
002e07 01f1      			movw Z,UP
002e08 9772      			sbiw Z,(-ubase)
002e09 81a0      			ld t4,Z
                 
002e0a 30aa      			cpi t4,10
002e0b f039      			breq NUMS10
                 	NUMS_0:
002e0c dfc6      			  rcall NUM				; ud'.l saved in t3t2
002e0d 2a08      			  or t2,tosl			; ud' = 0 ?
002e0e 2a19      			  or t3,tosh
002e0f 2801      			  or t2,t3
002e10 f7d9      			brne NUMS_0
002e11 9508      			ret
                 
                 	NUMS10_loop:
002e12 dfc0      			  rcall NUM
                 	NUMS10:
002e13 9700      			  sbiw TOP,0
002e14 f7e9      			brne NUMS10_loop		; ud.h <> 0 -> get a digit
                 									; ud.h =  0 -> ...
                 	NUMS_ten:					; 16-bit base10 conversion for u in NEXT
002e15 8188      			ldd tosl,Y+0			; (keep stack space)
002e16 8199      			ldd tosh,Y+1
                 	WordToDec5:						; (t1:t0:tosh:tosl:t3) = WordToDec5(TOP)
                 
                 		.def x6     = R16			; t0
                 		.def x5536L = R16
                 		.def x5536H = R16
                 		.def x10    = R26			; t4
                 
002e17 e310      			ldi t1,'0'						; 10.000
002e18 e006      			ldi x6,6						; multiply by 6,5536 to shift out the first digit
002e19 9f80      			mul tosl,x6											; * 6,5536 as:
002e1a 01f0      						movw t7t6,R1:R0
002e1b 9f90      			mul tosh,x6											; * 6
002e1c 0df0
002e1d 1d11      									add t7,R0		adc t1,R1
                 		
002e1e eb09      			ldi x5536L,0xb9										; .. + *0,553604126 (0x8db9)
002e1f e8b0      			ldi t5,0x80											; enough for correct rounding
002e20 9f90      			mul tosh,x5536L
002e21 0db0
002e22 1de1
002e23 1df7
002e24 1d17      			add t5,R0	adc t6,R1	adc t7,r_zero	adc t1,r_zero
                 	
002e25 e80d      			ldi x5536H,0x8d
002e26 9f90      			mul tosh,x5536H
002e27 9408
002e28 1de0
002e29 1df1
002e2a 1d17      			sec			adc t6,R0	adc t7,R1		adc t1,r_zero
002e2b 9f80      			mul tosl,x5536H
002e2c 0db0
002e2d 1de1
002e2e 1df7
002e2f 1d17      			add t5,R0	adc t6,R1	adc t7,r_zero	adc t1,r_zero	; 30
                 	
002e30 e300      			ldi t0,'0'						;  1.000
002e31 e0aa      			ldi x10,10						; multiply by 10 to shift out the second digit
002e32 9fea      			mul t6,x10
002e33 01c0      						movw TOP,R1:R0
002e34 9ffa      			mul t7,x10
002e35 0d90
002e36 1d01      									add tosh,R0		adc t0,R1
002e37 9fba      			mul t5,x10
002e38 0d81
002e39 1d97
002e3a 1d07      						add tosl,R1	adc tosh,r_zero	adc t0,r_zero	; 44
                 
                 											; ......... third digit
002e3b 9f8a      			mul tosl,x10					;    100
002e3c 01f0      						movw t7t6,R1:R0
002e3d 9f9a      			mul tosh,x10
002e3e e390
002e3f 0df0
002e40 1d91      			ldi tosh,'0'			add t7,R0	adc tosh,R1			; 52
                 
                 											; ........ fourth digit
002e41 e380      			ldi tosl,'0'					;     10
002e42 9fea      			mul t6,x10
002e43 2db1      									mov t5,R1
002e44 9ffa      			mul t7,x10
002e45 0db0
002e46 1d81      									add t5,R0	adc tosl,R1			; 60
                 											; ......... fifth digit
002e47 e3f0      			ldi t7,'0'						;      1
002e48 9fba      			mul t5,x10
002e49 0e1f      												add R1,t7	; t3	; 64 
                 
                 								; HOLD
002e4a 01f1      			movw Z,UP				; t7:t6
                 			;sbiw Z,(-uhp)			; uhp = 0
002e4b 91a1      			ld XL,Z+				; t4
002e4c 91b1      			ld XH,Z+				; t5
002e4d 921e      			st -X,t3				; ....x HOLD
002e4e 9483      			inc #hold
                 
002e4f 3310      			cpi t1,'0'										;
002e50 f481      			  brne Nt_all									;	 	91		leading digit non-zero -> write all 5 digits
                 			  					; skip leading zeros
002e51 1710      			cp  t1,t0				; at this point: t1 = '0'
002e52 0719      			cpc t1,tosh
002e53 0718      			cpc t1,tosl	
002e54 f091      			  breq Nt_xxx									;		    95			
002e55 938e      			st -X,tosl				; ...x. HOLD
002e56 9483      			inc #hold
                 
002e57 1710      			cp  t1,t0
002e58 0719      			cpc t1,tosh	
002e59 f069      			  breq Nt_xxx									;			   101
002e5a 939e      			st -X,tosh				; ..x.. HOLD
002e5b 9483      			inc #hold
                 
002e5c 1710      			cp  t1,t0	
002e5d f049      			  breq Nt_xxx									;				   106
002e5e 930e      			st -X,t0				; .x... HOLD
002e5f 9483      			inc #hold
                 
002e60 c006      			rjmp Nt_xxx										;					   110
                 
                 	Nt_all:
002e61 938e      			st -X,tosl				; ...x. HOLD
002e62 939e      			st -X,tosh				; ..x.. HOLD
002e63 930e      			st -X,t0				; .x... HOLD
002e64 931e      			st -X,t1				; x.... HOLD
002e65 e004      			ldi t0,4
002e66 0e80      			add #hold,t0									;       99
                 	Nt_xxx:
002e67 93b2      			st -Z,XH
002e68 93a2      			st -Z,XL
                 			;;clr tosl 										; put 0x0000.0000. on stack
                 			;;clr tosh
                 			;;pushtos
                 			;sbiw Y,2										; let it be any double (will be 2drop-ed in '#>' anyway)
                 															; .. no need (stack space kept)
                 															;   	 5	 1	 2	 3	 4 #digits 
002e69 9508      			ret												;      104  99 105 110 114
                 															;   	+4	+4	+4	+4	+4
                 .else .error "illegal value: optimizeNUM"
                 .endif
                 
                 
002e6a eed8              fdw		SQUAREROOT_L
                 ; SKIP  ( c-addr u c -- c-addr' u' )	skip matching chars
                 ; c-addr must point to RAM
                 ; u (count) must be smaller than 256
                 SKIP_L:
002e6b 7384
002e6c 696b
002e6d ff70              .db		NFA|4,"skip",0xff
                 SKIP:
002e6e 2f08      		 mov t0,tosL			; c in t0
002e6f 9189
002e70 9199      		 poptos					; u in tosl
                 SKIP_0:
002e71 91e9
002e72 91f9      		 pop_Z					; c-addr in Z
                 SKIP_loop:
002e73 9701      		   sbiw TOP,1
002e74 f030                   brcs SKIP_leave
002e75 9111      		   ld t1,Z+				; fetched char
002e76 3019      		   cpi t1,TAB_
002e77 f3d9      		     breq SKIP_loop
002e78 1710      		   cp t1,t0
002e79 f3c9      		 breq SKIP_loop
                 SKIP_mismatch:
                 SCAN_match:
002e7a 9731      		 sbiw Z,1				; set c-addr back to found match
                 SKIP_leave:
                 SCAN_leave:
002e7b 9601      		 adiw TOP,1
002e7c 93fa
002e7d 93ea      		 push_Z
002e7e 9508      		 ret
                 
                 
002e7f e1fc      		fdw		SIGN_L
                 ; SCAN  ( c-addr u c -- c-addr' u' )	find matching chars
                 ; c-addr must point to RAM
                 SCAN_L:
002e80 7384
002e81 6163
002e82 ff6e      		.db		NFA|4,"scan",0xff
                 SCAN:
002e83 2f08      		 mov t0,tosl			; c in t0
002e84 9189
002e85 9199      		 poptos					; u in tos
                 SCAN_0:
002e86 91e9
002e87 91f9      		 pop_Z					; c-addr in Z
                 SCAN_loop:
002e88 9701      		   sbiw TOP,1
002e89 f388      		     brcs SCAN_leave
002e8a 9111      		   ld t1,Z+
002e8b 3019      		   cpi t1,TAB_
002e8c f369      		     breq SCAN_match
002e8d 1710      		   cp t1,t0
002e8e f7c9      		 brne SCAN_loop
002e8f cfea      		 rjmp SCAN_match
                 
                 
002e90 d97e      		fdw		FLOCK_L
                 FCY_L:
002e91 4683
002e92 7963      		.db		NFA|3,"Fcy"
002e93 d515      		rcall DOCREATE
002e94 3e80      		.dw FREQ_OSC/1000
                 
                 
002e95 e278      		fdw		TWOCONSTANT_L
                 VARIABLE_L:
002e96 7688
002e97 7261
002e98 6169
002e99 6c62
002e9a ff65      		.db		NFA|8,"variable",0xff
                 VARIABLE_:
002e9b e012      		 ldi t1,2
                 VARIABLE_1:
002e9c d043      		 rcall HERE				; (uses t0)
002e9d 2700      		 clr t0
002e9e 0f18      		 add t1,tosl			; t0:t1 (++ high<>low swapped ++) 
002e9f 1f09      		 adc t0,tosh
002ea0 9302      		 st -Z,t0				; (Z-pointer valid from HERE)
002ea1 9312      		 st -Z,t1
002ea2 c28b      		 rjmp CONSTANT_
                 
                 
002ea3 ee90      		fdw		IMMEDIATE_L
                 TWOVARIABLE_L:
002ea4 3289
002ea5 6176
002ea6 6972
002ea7 6261
002ea8 656c      		.db		NFA|9,"2variable"
                 TWOVARIABLE_:
002ea9 e014      		 ldi t1,4
002eaa cff1      		 rjmp VARIABLE_1
                 
                 
002eab dd64      		fdw		EIGHTRSHIFT_L
                 EIGHTLSHIFT_L:
002eac 38a3
002ead 3c3c      		.db		NFA|INLINE|3,"8<<"
                 ;EIGHTLSHIFT:
002eae 2f98      		mov tosh,tosl
002eaf e080      		ldi tosl,0				; 2 / 2
002eb0 9508      		ret
                 	
002eb1 da96      		fdw		TOIN_L
                 EIGHTRSHIFT_L:
002eb2 38a3
002eb3 3e3e      		.db		NFA|INLINE|3,"8>>"
                 ;EIGHTRSHIFT:
002eb4 2f89      		mov tosl,tosh
002eb5 e090      		ldi tosh,0				; 2 / 2
002eb6 9508      		ret
                 
002eb7 f48e      		fdw		TO_A_L
                 ; ><							swap bytes
                 SWAPB_L:
002eb8 3ea2
002eb9 ff3c      		.db		NFA|INLINE|2,"><",0xff
                 ;SWAPB:
002eba 2f08      		mov t0,tosl
002ebb 2f89      		mov tosl,tosh
002ebc 2f90      		mov tosh,t0				; 3 / 3
002ebd 9508      		ret
                 
                 
002ebe ec06      		fdw		IHERE_L
                 ; set the current memory section
                 ; ..FLASH
                 FLASH_L:
                 ROM_N:  
002ebf 66a5
002ec0 616c
002ec1 6873      		.db		NFA|INLINE|5,"flash"
                 ;ROM_:
002ec2 bc7a      		out cse,r_zero			; 1 / 1
002ec3 9508      		ret
                 
002ec4 f700      		fdw		IFLUSH_L
                 ; ..EEPROM
                 EEPROM_L:
                 EROM_N: 
002ec5 65a6
002ec6 7065
002ec7 6f72
002ec8 ff6d      		.db		NFA|INLINE|6,"eeprom",0xff
                 ;EROM:
002ec9 e002      		ldi t0,2
002eca bd0a      		out cse,t0				; 2 / 2
002ecb 9508      		ret
                 
002ecc f68a      		fdw		ROT_L
                 ; ..RAM
                 RAM_L:
                 FRAM_N: 
002ecd 72a3
002ece 6d61      		.db		NFA|INLINE|3,"ram"
                 FRAM:
002ecf e004      		ldi t0,4
002ed0 bd0a      		out cse,t0				; 2 / 2
002ed1 9508      		ret
                 
                 
002ed2 d808      		fdw		EI_L
                 ; DP  ( -- a-addr )				current dictionary pointer (in RAM)
                 DP_L:
002ed3 64a2
002ed4 ff70      		.db		NFA|INLINE5|2,"dp",0xff
                 DP:
002ed5 939a
002ed6 938a      		 pushtos
                 DP_0:
002ed7 b58a      		 in tosl,cse
002ed8 2799      		 clr tosh
002ed9 5484      		 subi tosl, LOW(-dpFLASH)
002eda 4f9d      		 sbci tosh,HIGH(-dpFLASH)	; 6 / 8
002edb 9508      		 ret
                 
                 
002edc e154      		fdw		HOLD_L
                 ; HERE  ( -- addr )				get current data space ptr
                 ;   DP @ ;
                 HERE_L:
002edd 6884
002ede 7265
002edf ff65      		.db		NFA|4,"here",0xff
                 HERE:
002ee0 939a
002ee1 938a      		 pushtos
                 HERE_0:
002ee2 b5ea      		 in ZL,cse
002ee3 27ff      		 clr ZH
002ee4 54e4      		 subi ZL, LOW(-dpFLASH)
002ee5 4ffd      		 sbci ZH,HIGH(-dpFLASH)
002ee6 9181      		 ld tosl,Z+
002ee7 9191      		 ld tosh,Z+				; 8 / 10
002ee8 9508      		 ret
                 
                 
002ee9 f6f6      		fdw		CWD_L
                 COMMAXT_L:
002eea 6383
002eeb 2c66      		.db		NFA|3, "cf,"
                 COMMAXT:
002eec 939a
002eed 938a      		duptos
002eee 9100 02bc 		lds t0,dpFLASH
002ef0 9110 02bd 		lds t1,dpFLASH+1
                 
                   .if FLASHEND < 0x4000
002ef2 3f90      			cpi tosh,0xf0
002ef3 f010      			brcs COMMAXT_xxx
                 			  ;cbr tosh,HIGH(PFLASH)	; 'rcall ...' with wrap around at flashhi
002ef4 709f      			  andi tosh,0x0f
002ef5 6790      			  ori tosh,HIGH(PFLASH-0x1000)
                 	COMMAXT_xxx:
                   .endif
                 
002ef6 1b80      		sub tosl,t0
002ef7 0b91      		sbc tosh,t1
                 		;sbrc tosh,7			; (size vs. speed)
                 		;  rcall negate
002ef8 f41a      		brpl COMMAXT_yyy
002ef9 9580      		  com tosl
002efa 9590      		  com tosh
002efb 9601      		  adiw TOP,1
                 COMMAXT_yyy:
002efc 3f8c      		cpi tosl,0xfc
002efd e08f      		ldi tosl,0x0f
002efe 0798      		cpc tosh,tosl
002eff 9189
002f00 9199      		poptos
002f01 f048      		  brcs STORECF1
                 STORECFF1: 
002f02 5890      		sub_pflash_tos			; compile 'call ..'
002f03 9596      		lsr tosh
002f04 9587      		ror tosl
                 STORECFF2:
002f05 939a
002f06 938a      		pushtos
                   .ifdef EIND
                   .else
                 			;.dw     0x940E
002f07 e08e      			ldi tosl,0x0e  		; 'call ..'
002f08 e994      			ldi tosh,0x94
                   .endif
002f09 d7b6      		rcall ICOMMA_
002f0a c7b5      		rjmp ICOMMA_
                 
                 STORECF1:
                 		;rcall IHERE			; compile 'rcall ..'
                 		;rcall MINUS			;  2 / 29
                 ;		lds t0,dpFLASH
                 ;		lds t1,dpFLASH+1		; (still there)
002f0b 1b80      		sub tosl,t0
002f0c 0b91      		sbc tosh,t1
002f0d 9702      		sbiw TOP,2
002f0e 9595      		asr tosh
002f0f 9587      		ror tosl
002f10 709f      		andi tosh,0x0f
002f11 6d90      		ori tosh,0xd0
                 ICOMMA___:
002f12 c7ad      		rjmp ICOMMA_
                 
                 
002f13 de4e      		fdw		TWOSWAP_L
                 ; 2DROP ( x1 x2 -- )			drop 2 cells
                 ;	DROP DROP ;
                 TWODROP_L:
002f14 32a5
002f15 7264
002f16 706f      		.db		NFA|INLINE|5,"2drop"
                 TWODROP:
002f17 9622      		adiw Y,2				; NIP
002f18 9189
002f19 9199      		poptos					; 3 /  6
002f1a 9508      		ret
                 
                 
002f1b d860      		fdw		BASE_L
                 ; 2DUP  ( x1 x2 -- x1 x2 x1 x2 )	dup top 2 cells
                 ;   OVER OVER ;
                 TWODUP_L:
002f1c 32a4
002f1d 7564
002f1e ff70      		.db		NFA|INLINE5|4,"2dup",0xff
                 TWODUP:
002f1f 8108      		ldd t0,Y+0
002f20 8119      		ldd t1,Y+1
002f21 939a
002f22 938a      		duptos
002f23 931a
002f24 930a      		push_t1t0				; 6 / 12
002f25 9508      		ret
                 
                 
002f26 d90e      		fdw		TOBODY_L
                 ; 2SWAP  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
                 TWOSWAP_L:
002f27 3285
002f28 7773
002f29 7061      		.db		NFA|5,"2swap"
                 TWOSWAP:
002f2a 01fc      		movw t7t6,TOP
002f2b 91a9
002f2c 91b9      		pop_t5t4
002f2d 9189
002f2e 9199      		poptos
002f2f 9109
002f30 9119      		pop_t1t0
002f31 93ba
002f32 93aa      		push_t5t4
002f33 93fa
002f34 93ea      		push_t7t6
002f35 931a
002f36 930a      		push_t1t0				; 13 / 25
002f37 9508      		ret
                 
                 
002f38 edb6      		fdw		STATE_L
                 ; SPACE ( -- )					output a space
                 ;	BL EMIT ;
                 SPACE_L:
002f39 7385
002f3a 6170
002f3b 6563      		.db		NFA|5,"space"
                 SPACE_:  
002f3c e200      		ldi t0,' '
002f3d c736      		rjmp EMIT_t0
                 
                 
002f3e ee0e      		fdw		TICKSCOMPUTE_L
                 ; SPACES ( n -- )				output n spaces
                 ;	BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
                 SPACES_L:
002f3f 7386
002f40 6170
002f41 6563
002f42 ff73      		.db		NFA|6,"spaces",0xff
                 SPACES:
                 SPCS1:
002f43 9700      		sbiw TOP,0
002f44 f019      		breq SPCS2
                 SPCS3:
002f45 dff6      		  rcall SPACE_
002f46 9701      		  sbiw TOP,1
002f47 f7e9      		brne SPCS3
                 SPCS2:  
002f48 c004      		rjmp DROP
                 
                 
002f49 eff0      		fdw		DUMP_L
                 DROP_L:
002f4a 64a4
002f4b 6f72
002f4c ff70      		.db		NFA|INLINE|4,"drop",0xff
                 DROP:
002f4d 9189
002f4e 9199      		poptos					; 2 / 4
002f4f 9508      		ret
                 
                 
002f50 d840      		fdw		TASK_L
                 SWOP_L:
002f51 73a4
002f52 6177
002f53 ff70      		.db		NFA|INLINE5|4,"swap",0xff
                 SWOP:
002f54 018c      		movw t1t0,TOP
002f55 9189
002f56 9199      		poptos
002f57 931a
002f58 930a      		push_t1t0				; 5 / 9
002f59 9508      		ret
                 
                 
002f5a eae0      		fdw		QUIT_L
                 ; ( xu ... x0 u -- xu ... x0 xu )
                 PICK_L:
002f5b 70a4
002f5c 6369
002f5d ff6b      		.db		NFA|INLINE5|4,"pick",0xff
                 PICK:
002f5e 0f88      		lsl tosl
002f5f 01fe      		movw Z,Y
002f60 0fe8      		add ZL,tosl
002f61 1df7      		adc ZH,r_zero
002f62 9181      		ld tosl,Z+
002f63 9191      		ld tosh,Z+				; 8 / 10
002f64 9508      		ret
                 
                 
002f65 deb6      		fdw 	PICK_L
                 OVER_L:
002f66 6fa4
002f67 6576
002f68 ff72      		.db		NFA|INLINE4|4,"over",0xff
                 OVER:
002f69 939a
002f6a 938a      		pushtos
002f6b 818a      		ldd tosl,Y+2
002f6c 819b      		ldd tosh,Y+3			; 4 / 8
002f6d 9508      		ret
                 
                 
002f6e f6b2      		fdw		FETCHPP_L
                 TOR_L:
002f6f 3eb2
002f70 ff72      		.db		NFA|COMPILE|0x20|2,">r",0xff
                 ;TOR:					;++++ must be inlined ++++
002f71 938f      		 push tosl
002f72 939f      		 push tosh
002f73 9189
002f74 9199      		 poptos					; 4 /  8
002f75 9508      		 ret
                 
002f76 defe      		fdw		RFETCH_L
                 RFROM_L:
002f77 72b2
002f78 ff3e      		.db		NFA|COMPILE|0x20|2,"r>",0xff
                 ;RFROM:					;++++ must be inlined ++++
002f79 939a
002f7a 938a      		 pushtos
002f7b 919f      		 pop tosh
002f7c 918f      		 pop tosl				; 4 /  8
002f7d 9508      		 ret
                 
                 
002f7e dfd0      		fdw		SQUOTE_L
                 RFETCH_L:
002f7f 72b2
002f80 ff40      		.db		NFA|COMPILE|0x20|2,"r@",0xff
                 ;RFETCH:				;++++ must be inlined ++++
002f81 939a
002f82 938a      		 pushtos
002f83 b7ed      		 in ZL,SPL
002f84 b7fe      		 in ZH,SPH
002f85 8182      		 ldd tosl,Z+2
002f86 8191      		 ldd tosh,Z+1			; 6 / 10
002f87 9508      		 ret				
                 
002f88 d8b0      		fdw		AND_L
                 ; ABS ( n -- |n| )				absolute value of n
                 ABS_L:
002f89 61a3
002f8a 7362      		.db		NFA|INLINE|3,"abs"
                 ABS_:
002f8b 2399      		 tst tosh
002f8c f41a      		 brpl ABS_1
002f8d 9580      		   com tosl
002f8e 9590      		   com tosh
002f8f 9601      		   adiw TOP,1
                 ABS_1:							; 5 / 3..6
002f90 9508      		 ret
                 
                 
002f91 ea54      		fdw		COMMA_L
                 PLUS_L:
002f92 2ba1      		.db		NFA|INLINE4|1, "+"
                 PLUS:
002f93 9109
002f94 9119      		pop_t1t0
                 PLUS_0:
002f95 0f80      		add tosl,t0
002f96 1f91      		adc tosh,t1				; 4 / 6
002f97 9508      		ret
                 
                 
002f98 ee4a      		fdw		ALLOT_L
                 ; ALIGN ( -- )					align DP
                 ALIGN_L:
002f99 6185
002f9a 696c
002f9b 6e67      		.db		NFA|5,"align"
                 ;ALIGN:
002f9c df43      		 rcall HERE
002f9d 9601      		 adiw TOP,1
002f9e 7f8e      		 cbr tosl,1
002f9f c790      		 rjmp ALLOT_1			; Z-pointer valid from HERE
                 
                 
002fa0 ec9c      		fdw		CREATE_L
                 ; ACCEPT  ( c-addr u -- u' )	get line or max u char from terminal and put into TIB
                 ACCEPT_L:
002fa1 6186
002fa2 6363
002fa3 7065
002fa4 ff74      		.db		NFA|6,"accept",0xff
                 ACCEPT:
002fa5 018c      		movw t1t0,TOP
002fa6 8188      		ldd tosl,Y+0
002fa7 8199      		ldd tosh,Y+1
002fa8 0f08      		add t0,tosl				; ( c-addr c-addr ) end-addr in t1:t0
002fa9 1f19      		adc t1,tosh
                 ACC0:
002faa 930f      		push t0
002fab 931f      		push t1
                 ACC1:
002fac d6cb      		  rcall KEY_A			; ( c-addr c-addr c )
                 
002fad 01d1      		  movw X,UP
002fae 9719      		  sbiw X,(-uflg)
                 
002faf 308a      		  cpi tosl, LF_
002fb0 f0d9      			breq ACC_LF
002fb1 3088      		  cpi tosl, BS_
002fb2 f051      			breq ACC_BS_DEL
002fb3 378f      		  cpi tosl, 127
002fb4 f041      			breq ACC_BS_DEL
002fb5 308d      		  cpi tosl, CR_
002fb6 f4e1      			brne ACC3
                 ACC_CR:
002fb7 938c      		  st X,tosl
002fb8 9189
002fb9 9199      		  poptos
                 ;			rjmp ACC6
                 ACC6:
002fba 910f      		  pop t0
002fbb 910f      		  pop t0
002fbc cc95      		  rjmp SWOPMINUS
                 
                 ACC_BS_DEL:
002fbd 927c      		  st X,r_zero
002fbe 9189
002fbf 9199      		  poptos
002fc0 8108      		  ldd t0,Y+0
002fc1 8119      		  ldd t1,Y+1
002fc2 1b08      		  sub t0,tosl
002fc3 0b19      		  sbc t1,tosh
002fc4 f339      		breq ACC1
002fc5 9701      		  sbiw TOP,1
002fc6 d7c8      		  rcall XSQUOTE
002fc7 0803
002fc8 0820      		  .db   3,8,0x20,8
002fc9 940e 37ed 		call TYPE
002fcb cfe0      		rjmp ACC1
                 
                 ACC_LF:
002fcc 9189
002fcd 9199      		  poptos
002fce 910c      		  ld t0,X
002fcf 2300      		  tst t0
002fd0 f349      			breq ACC6
002fd1 927c      		  st X,r_zero
002fd2 cfd9      		rjmp ACC1
                 
                 ACC3:
002fd3 2f08      		  mov t0,tosl
002fd4 d69f      		  rcall EMIT_t0
002fd5 91a9
002fd6 91b9      		  pop_X
002fd7 938d      		  st X+,tosl
002fd8 01cd      		  movw TOP,X
                 
002fd9 911f      		  pop t1
002fda 910f      		  pop t0
002fdb 1708      		  cp  t0,tosl
002fdc 0719      		  cpc t1,tosh
002fdd f661      		brne ACC0
002fde cc73      		rjmp SWOPMINUS
                 
002fdf eecc      		fdw		SQUARE_L
                 ; SP@ ( -- addr )				get parameter stack pointer
                 SPFETCH_L:
002fe0 73a3
002fe1 4070      		.db		NFA|INLINE|3,"sp@"
                 SPFETCH:
002fe2 01fe      		movw Z,Y
002fe3 939a
002fe4 938a      		pushtos
002fe5 01cf      		movw TOP,Z				; 4 / 6
002fe6 9508      		ret
                 
                 
002fe7 edde      		fdw		S0_L
                 SQUOTE_L:
002fe8 73d2
002fe9 ff22      		.db      NFA|IMMED|COMPILE|2,"s",0x22,0xff
                 SQUOTE:
002fea d3c9      		rcall DOCOMMAXT
002feb ef1e      		fdw  XSQUOTE
002fec bc7a      		out cse,r_zero			; 'flash'
002fed d004      		rcall CQUOTE
002fee cee0      		rjmp  FRAM
                 
                 
002fef eda8      		fdw		MINUS_FETCH_L
                 CQUOTE_L:
002ff0 2c82
002ff1 ff22      		.db		NFA|2,",",0x22,0xff
                 CQUOTE: 
002ff2 939a
002ff3 938a      		pushtos
002ff4 e282      		ldi tosl,'"'
                 		;ldi tosh,0
002ff5 d165      		rcall PARSE
002ff6 dee9      		rcall HERE
002ff7 df71      		rcall OVER
002ff8 9602      		adiw TOP,2
002ff9 7f8e      		cbr tosl,1
002ffa d72d      		rcall ALLOT
002ffb c56c      		rjmp  PLACE
                 
                 
002ffc e33e      		fdw     FIND_L
                 ; EXIT							compile a return
                 ;		variable link
                 EXIT_L:
002ffd 65d4
002ffe 6978
002fff ff74      		.db		NFA|COMPILE|IMMED|4,"exit",0xff
                 EXIT:
003000 c6a4      		rjmp SEMICOLON_0
                 
                 
003001 daa6      		fdw		TICKSOURCE_L
                 ; within ( x min max -- f )		min <= x < max ?
                 WITHIN_L:
003002 7786
003003 7469
003004 6968
003005 ff6e      		.db		NFA|6,"within",0xff
                 ;WITHIN:
003006 9109
003007 9119      		pop_t1t0				; min
003008 91a9
003009 91b9      		pop_t5t4				; x
                 								; max in TOP
00300a 170a      		cp  t0,t4
00300b 071b      		cpc t1,t5
00300c f009      		breq PC+2
00300d f410      		  brcc WITHIN_flag		; C=0 -> x < min -> put FALSE
00300e 17a8      		cp  t4,tosl
00300f 07b9      		cpc t5,tosh				; C=0 -> max <= x -> put FALSE
                 WITHIN_flag:					; C=1 -> min <= x < max -> put TRUE
003010 0b88      		sbc tosl,tosl			; .. make it a stack-flag
003011 0b99      		sbc tosh,tosh
003012 9508      		ret						; 12 / 14..15+4
                 
                 
003013 dd70      		fdw		SWAPB_L
                 NOTEQUAL_L:
003014 3ca2
003015 ff3e      		.db		NFA|INLINE4|2,"<>",0xff
                 NOTEQUAL:
003016 9109
003017 9119      		 pop_t1t0
                 NOTEQUAL_0:
003018 1b80      		 sub tosl,t0
003019 0b91      		 sbc tosh,t1			; 4 / 6
00301a 9508      		 ret
                 
                 
00301b e064      		fdw		GREATER_L
                 EQUAL_L:
00301c 3da1      		.db		NFA|INLINE5|1, "="
                 EQUAL:
00301d 9109
00301e 9119      		 pop_t1t0
                 EQUAL_0:
00301f 1b80      		 sub tosl,t0
003020 0b91      		 sbc tosh,t1
003021 9701      		 sbiw TOP,1
003022 0b88      		 sbc tosl,tosl
003023 0b99      		 sbc tosh,tosh			; 7 / 10
003024 9508      		 ret
                 
                 
003025 e038      		fdw		EQUAL_L
                 LESS_L:
003026 3c81      		.db		NFA|1,"<"
                 LESS:
003027 9109
003028 9119      		pop_t1t0
                 ;LESS_0:						; #### check LESSC_ when changing ####
003029 1b08      		sub t0,tosl
00302a 0b19      		sbc t1,tosh
00302b f40b      		brvc PC+2
00302c 9510      		  com t1
00302d 0f11      		lsl t1
00302e 0b88      		sbc tosl,tosl
00302f 0b99      		sbc tosh,tosh			; 9 / 11
003030 9508      		ret
                 
                 
003031 fa16      		fdw		FETCH_L
                 GREATER_L:
003032 3e81      		.db		NFA|1,">"
                 GREATER:						; #### check GREATERC_ when changing ####
003033 9109
003034 9119      		pop_t1t0
                 ;GREATER_0:
003035 1b80      		sub tosl,t0
003036 0b91      		sbc tosh,t1
                 ;GREATER_1:
003037 f40b      		brvc PC+2
003038 9590      		  com tosh
003039 0f99      		lsl tosh
00303a 0b88      		sbc tosl,tosl
00303b 0b99      		sbc tosh,tosh			; 9 / 11
00303c 9508      		ret
                 
                 
00303d e090      		fdw		UGREATER_L
                 ULESS_L:
00303e 75a2
00303f ff3c      		.db		NFA|INLINE5|2,"u<",0xff
                 ULESS:							; #### check ULESSC_ when changing ####
003040 9109
003041 9119      		pop_t1t0
                 ;ULESS_0:
003042 1708      		cp  t0,tosl
003043 0719      		cpc t1,tosh
003044 0b88      		sbc tosl,tosl
003045 0b99      		sbc tosh,tosh			; 6 / 8
003046 9508      		ret
                 
                 
003047 e144      		fdw		UPTR_L
                 UGREATER_L:
003048 75a2
003049 ff3e      		.db		NFA|INLINE5|2, "u>",0xff
                 UGREATER:						; #### check UGREATERC_ when changing ####
00304a 9109
00304b 9119      		 pop_t1t0
                 ;UGREATER_0:
00304c 1780      		 cp  tosl,t0
00304d 0791      		 cpc tosh,t1
00304e 0b88      		 sbc tosl,tosl
00304f 0b99      		 sbc tosh,tosh			; 6 / 8
003050 9508      		 ret
                 
                 
003051 e196      		fdw		NUMGREATER_L
                 STORE_P_L:
003052 21a2
003053 ff70      		.db		NFA|INLINE|2,"!p",0xff
                 STORE_P:
003054 01ac      		movw P,TOP
003055 9189
003056 9199      		poptos
003057 9508      		ret
                 
                 .if optimizingCOMPILER == 1
                 	TO_A_C_:						; fdw TO_A in TOP
                 	TO_A_C_0:
003058 d668      			rcall ldi16_t1t0_C_
003059 e588
00305a e091      			ldi16 tos,0x0158		; 'movw A,t1t0'
00305b c664      			rjmp ICOMMA_
                 
                 	STORE_P_TO_R_C_:				; fdw STORE_P_TO_R in TOP
00305c e008      			ldi t0,8
00305d d7e4      			rcall IDPMINUS
00305e e48f
00305f e993      			ldi16 tos,0x934f		; 'push pl'
003060 d65f      			rcall ICOMMA_
003061 939a
003062 938a      			pushtos
003063 e58f
003064 e993      			ldi16 tos,0x935f		; 'push ph'
003065 d65a      			rcall ICOMMA_
                 ;			ldi t0,2				; point to 'ldi tosh,<lit.1>'
003066 e002      		ldi t0,2
003067 e410      		ldi t1,regP
003068 c65c      		rjmp ldi16_thtl_C_0
                 
                 	STORE_P_C_:						; (fdw STORE_P) | (fdw STORE_P_TO_R) in TOP
003069 e410      			ldi t1,regP				; -> P
00306a d657      		rcall ldi16_thtl_C_
00306b cee1      		rjmp DROP
                 
                 .endif
                 		
00306c dae8      		fdw		UKEY_L
                 STORE_P_TO_R_L:
00306d 21b4
00306e 3e70
00306f ff72      		.db		NFA|COMPILE|0x20|4,"!p>r",0xff
                 STORE_P_TO_R:				;++++ must be inlined ++++
003070 934f      		push pl
003071 935f      		push ph
003072 01ac      		movw P,TOP
003073 9189
003074 9199      		poptos					; 5 / 9
003075 9508      		ret
                 
                 
003076 dd9a      		fdw		RAM_L
                 R_TO_P_L:
003077 72b3
003078 703e      		.db		NFA|COMPILE|0x20|3,"r>p"
                 ;R_TO_P:					;++++ must be inlined ++++
003079 915f      		pop ph
00307a 914f      		pop pl
00307b 9508      		ret						; 2 / 4
                 
                 
                 ;		.db		NFA|INLINE|3,"?0="
                 ZEROSENSE:
00307c 2b98      		or tosh,tosl
00307d 9189
00307e 9199      		poptos
00307f 9508      		ret
                 
                 
003080 d9f2      		fdw		TO_XA_L
                 ; >pr  ( c -- c )				filter a character to printable 7-bit ASCII
                 TO_PRINTABLE_L:
003081 3ea3
003082 7270      		.db		NFA|INLINE5|3,">pr"
                 TO_PRINTABLE:
003083 2799      		clr tosh
003084 3280      		cpi tosl,0x20
003085 f008      		  brcs nonPRINT
003086 fd87      		sbrc tosl,7
003087 e28e      nonPRINT: ldi tosl,'.'			; 5 / 5
003088 9508      		ret
                 
                 
003089 e22e      		fdw		DOT_L
                 MINUS_L:
00308a 2da1      		.db		NFA|INLINE5|1, "-"
                 MINUS:
00308b 9109
00308c 9119      		pop_t1t0
                 ;MINUS_0:
00308d 1b08      		sub t0,tosl
00308e 0b19      		sbc t1,tosh
00308f 01c8      		movw TOP,t1t0			; 5 / 7
003090 9508      		ret
                 
                 
003091 dac6      		fdw 	PNPLUS_L
                 NIP_L:
003092 6ea3
003093 7069      		.db		NFA|INLINE|3,"nip"
                 NIP:
003094 9622      		adiw Y,2				; 1 / 1
003095 9508      		ret
                     
                 
003096 efd4      		fdw		TYPE_L
                 ; TUCK
                 ;   swap over ;
                 TUCK_L:
003097 74a4
003098 6375
003099 ff6b      		.db		NFA|INLINE5|4,"tuck",0xff
                 TUCK:
00309a 9109
00309b 9119      		pop_t1t0
00309c 939a
00309d 938a      		duptos
00309e 931a
00309f 930a      		push_t1t0				; 6 / 12
0030a0 9508      		ret
                 
                 
0030a1 ee34      		fdw		MICROS_L
                 UPTR_L:
0030a2 75a2
0030a3 ff70      		.db		NFA|INLINE4|2,"up",0xff
                 UPTR:
0030a4 939a
0030a5 938a      		pushtos 				; up in R3:R2 -> addr = 0x0002
                 UPTR_0:
0030a6 e082      		ldi tosl,2
0030a7 e090      		ldi tosh,0				; 4 / 6
0030a8 9508      		ret
                 
                 .if IDLE_MODE == 0
                 .elif IDLE_MODE == 1
0030a9 db8c      		fdw		IDLE_L
                 .else .error "ilegal value: IDLE_MODE"
                 .endif
                 HOLD_L:
0030aa 6884
0030ab 6c6f
0030ac ff64      		.db		NFA|4,"hold",0xff
                 HOLD:
0030ad 2f08      		mov t0,tosl
0030ae 9189
0030af 9199      		poptos
                 NUM_HOLD:
0030b0 01f1      		movw Z,UP
                 		;sbiw Z,(-uhp)			; uhp = 0 !!
0030b1 91a1      		ld XL,Z+
0030b2 91b1      		ld XH,Z+
0030b3 930e      		st -X,t0
0030b4 9483      		inc #hold
0030b5 93b2      		st -Z,XH
0030b6 93a2      		st -Z,XL
0030b7 9508      		ret
                 
                 
0030b8 e028      		fdw		NOTEQUAL_L
                 ; <# ( -- )						begin numeric conversion
                 ;	PAD HP ! ;					(initialize hold pointer)
                 LESSNUM_L:
0030b9 3c82
0030ba ff23      		.db		NFA|2,"<#",0xff
                 LESSNUM:
0030bb daf1      		rcall PAD
0030bc 01f1      		movw Z,UP
0030bd 8380      		std Z+0,tosl
0030be 8391      		std Z+1,tosh
0030bf 2488      		clr #hold
0030c0 ce8c      		rjmp DROP				; 6 / 46+4
                 
                 
0030c1 ed16      		fdw		DOES_L
                 ; digit ( n -- c )				convert to 0..9 a..z
                 TODIGIT_L:
0030c2 64a5
0030c3 6769
0030c4 7469      		.db		NFA|INLINE4|5,"digit"
                 TODIGIT:
0030c5 308a      		cpi tosl,0x0a
0030c6 f008      		brcs PC+2
0030c7 5d89      		  subi tosl,-0x27
0030c8 5d80      		subi tosl,-0x30			; 4 / 4
0030c9 9508      		ret
                 
                 
0030ca dc0a      		fdw		NUMS_L
                 ; #>  ( ud1 -- c-addr u )		end conversion, get string
                 ;   2drop hp @ pad over - ;
                 NUMGREATER_L:
0030cb 2382
0030cc 003e      		.db		NFA|2,"#>", 0
                 NUMGREATER:
0030cd 9622      		adiw Y,2				; "2drop"
                 		;poptos
                 		;pushtos				; HP @
0030ce 01f1      		movw Z,UP
                 		;sbiw Z,(-uhp)			; (uhp = 0)
0030cf 9181      		ld tosl,Z+
0030d0 9191      		ld tosh,Z+
0030d1 939a
0030d2 938a      		pushtos
0030d3 2d88      		mov tosl,#hold			;  8 / 12+4
0030d4 9508      		ret			
                 
                 
                 .if optimizeNUM == 1
                 	UDOTR_ten:
0030d5 93af      			push XL					; print count
0030d6 93bf      			push XH					; leading char when <> 0 (optional)
0030d7 dd3d      			rcall NUMS_ten			; Z points to uhp, X points to leading digit in PAD
0030d8 919f      			pop tosh				; leading char
0030d9 e310      			ldi t1,'0'
0030da 1197      			cpse tosh,r_zero
0030db 2f19      			  mov t1,tosh
0030dc 918f      			pop tosl				; print count
0030dd 1988      			sub tosl,#hold			; sub # of converted digits
0030de f181      			  breq allDOT_finish
0030df f420      			  brcc UDOTR_ten_more
                 
                 	UDOTR_ten_less:
0030e0 1ba8      			sub XL,tosl				; mov X back skipping unused leading digits
0030e1 4fbf      			sbci XH,-1
0030e2 0e88      			add #hold,tosl
0030e3 c004      			rjmp UDOTR_ten_xxx
                 
                 	UDOTR_ten_more:
0030e4 931e      			  st -X,t1				; append leading char to PAD
0030e5 9483      			  inc #hold
0030e6 958a      			dec tosl
0030e7 f7e1      			brne UDOTR_ten_more
                 
                 	UDOTR_ten_xxx:
0030e8 93a1      			st Z+,XL
0030e9 93b1      			st Z+,XH
                 	UDOTR_ten_done:
0030ea c024      			rjmp allDOT_finish
                 .endif
                 
0030eb d926      		fdw		UTWOSLASH_L
                 ; U.R  ( u +n -- )				display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
                 UDOTR_L:
0030ec 7583
0030ed 722e      		.db		NFA|3,"u.r"
                 UDOTR:
0030ee 01dc      		movw X,TOP				; n <= 255 -> byte loop count in XL
                 		;poptos
                 		;pushtos				; ZERO 
0030ef 2788      		clr tosl
0030f0 2799      		clr tosh
0030f1 dfc9      		rcall LESSNUM			; (leaves Z = UP)
                 	  .if optimizeNUM == 1
                 			;movw Z,UP
0030f2 9772      			sbiw Z,(-ubase)
0030f3 8100      			ld t0,Z
0030f4 300a      			cpi t0,10
0030f5 f2f9      			  breq UDOTR_ten
                 	  .endif
0030f6 c003      		rjmp UDOTR_2
                 UDOTR_loop:
0030f7 93af      		  push XL
0030f8 dcda      		  rcall NUM
0030f9 91af      		  pop XL				; byte loop count
                 UDOTR_2: 
0030fa 50a1      		  subi XL,1
0030fb f7d8      		brcc UDOTR_loop
                 
0030fc c012      		rjmp allDOT_finish
                 
                 
0030fd dcd6      		fdw		SKIP_L
                 ; SIGN ( n -- )					add minus sign if n<0
                 ;	0< IF 2D HOLD THEN ;
                 SIGN_L:
0030fe 7384
0030ff 6769
003100 ff6e      		.db		NFA|4,"sign",0xff
                 SIGN:
003101 ff97      		sbrs tosh,7
003102 ce4a      		  rjmp DROP
003103 e28d      		ldi tosl,'-'
003104 cfa8      		rjmp HOLD
                 
                 
003105 fb8c      		fdw		USLASH_L
                 ; U.  ( u -- )					display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
                 UDOT_L:
003106 7582
003107 ff2e      		.db		NFA|2,"u.",0xff
                 UDOT:
003108 d303      		rcall ZERO
                 		;pushtos				; (speed vs. size)
                 		;clr tosl
                 		;clr tosh				; +3 / -7
                 UDOT_0:
003109 dfb1      		rcall LESSNUM			;   1 /  53
                 		;call PAD				; (speed vs. size)
                 		;movw Z,UP
                 		;st Z+,tosl
                 		;st Z+,tosh
                 		;clr #hold
                 		;poptos					;  +6 /  -9
                 		;<inline PAD>			; +16 / -25
                 
00310a dcfc      		rcall NUMS
                 
00310b e20d      		ldi t0,'-'
00310c fd74      		sbrc FLAGS2,fDOTsign
00310d dfa2      		  rcall NUM_HOLD		; append '-' sign
00310e 7e7f      		cbr FLAGS2,(1<<fDOTsign)
                 
                 allDOT_finish:
00310f dfbd      		rcall NUMGREATER
003110 d6dc      		rcall TYPE
                 SPACE_A:
003111 ce2a      		rjmp SPACE_
                 
                 
003112 fb44      		fdw		UMSTAR_L
                 UDDOT_L:
003113 7583
003114 2e64      		.db		NFA|3,"ud."
                 ;UDDOT:
003115 cff3      		rjmp UDOT_0
                 
                 
003116 fc58      		fdw		SLASH_L
                 ; . ( n -- )					display n signed
                 ;	<# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
                 DOT_L:
003117 2e81      		.db		NFA|1,"."
                 DOT:
003118 2399      		tst tosh
003119 f772      		brpl UDOT
00311a 6170      		  sbr FLAGS2,(1<<fDOTsign)
00311b 9580      		  com tosl
00311c 9590      		  com tosh
00311d 9601      		  adiw TOP,1
00311e cfe9      		  rjmp UDOT
                 
                 
00311f f404      		fdw		DLESS_L
                 DDOT_L:
003120 6482
003121 002e      		.db		NFA|2,"d.",0
                 ;DDOT:
003122 2399      		tst tosh
003123 f72a      		brpl UDOT_0
003124 6170      		  sbr FLAGS2,(1<<fDOTsign)
003125 940e 399f 		  call DNEGATE
003127 cfe1      		  rjmp UDOT_0
                 	  
                 
003128 db0c      		fdw		OPERATOR_L
                 CONSTANT_L:
003129 6388
00312a 6e6f
00312b 7473
00312c 6e61
00312d ff74      		.db		NFA|8,"constant",0xff
                 CONSTANT_:
                 .if optimizingCOMPILER == 0
                 .elif optimizingCOMPILER == 1
00312e 6470      		 	sbr FLAGS2,(1<<fIMMED)	; compile an 'immediate' word
                 			;rcall COLON
00312f d4e4      			rcall CREATE0
003130 d4e2      		 	rcall LITERAL_A			; compile 'pushtos   ldi tosl,..   ldi tosh,..'
003131 939a
003132 938a      			pushtos
003133 e68e
003134 ee92      			ldi16 tos,((CONST_yyy<<1)+PFLASH)
003135 d7c8      			rcall INLINE0			; compile CONST_yyy-sequence
                 			;cbr FLAGS2,(1<<fSTATE)	; SEMICOLON
003136 c585      		 	rjmp ADD_RETURN_1
                 
                 	CONST_yyy:
003137 fd77      			sbrc FLAGS2,fSTATE
                 			;-------------------------------------------------------------------------
003138 940c 3c4c 			  jmp LITERAL			; 'compile' -> compile lit (### must be 'jmp' ###)
                 			;-------------------------------------------------------------------------
00313a 9508      			ret						; 'interpret' - > ready
                 .else .error "illegal value: optimizingCOMPILER"
                 .endif
                 
00313b dd48      		fdw		TWOVARIABLE_L
                 TWOCONSTANT_L:
00313c 3289
00313d 6f63
00313e 736e
00313f 6174
003140 746e      		.db		NFA|9,"2constant"
                 TWOCONSTANT_:
003141 de12      		rcall SWOP
003142 d4d1      		rcall CREATE0
003143 d4cf      		rcall LITERAL_A
003144 d4ce      		rcall LITERAL_A
003145 c576      		rjmp ADD_RETURN_1
                 
                 
003146 f728      		fdw		WARM_L
                 ; USER  ( n -- )				create user variable
                 USER_L:
003147 7584
003148 6573
003149 ff72      		.db		NFA|4,"user",0xff
                 ;USER:
                 	  .if optimizingCOMPILER == 1
00314a 6270      		sbr FLAGS2,(1<<fINLINE)	; compile 'INLINE'-marked user variable
                 	  .endif
00314b d4c8      		 rcall CREATE0
00314c d4c6      		 rcall LITERAL_A
00314d 7767      		 cbr FLAGS1,(1<<fLIT)|(1<<f2LIT)
00314e 939a
00314f 938a      		 pushtos
003150 ea88
003151 ee92      		 ldi16 tos,((XDOUSER<<1)+PFLASH)
003152 d7ab      		 rcall INLINE0
003153 c568      		 rjmp ADD_RETURN_1
                 
                 XDOUSER:
003154 0d82      		 add tosl,upL
003155 1d93      		 adc tosh,upH
003156 9508      		 ret
                 
                 
003157 faac      		fdw		PAUSE_L
                 ; PARSE  ( char -- c-addr u )
                 PARSE_L:
003158 7085
003159 7261
00315a 6573      		.db		NFA|5,"parse"
                 PARSE:
00315b 01f1      		movw Z,UP
00315c 9738      		sbiw Z,(-usource)
00315d 91a1      		ld XL,Z+
00315e 91b1      		ld XH,Z+				; a in X
00315f 939a
003160 938a      		pushtos
003161 9181      		ld tosl,Z+
003162 9191      		ld tosh,Z+				; ( c u )
003163 9101      		ld t0,Z+
003164 9111      		ld t1,Z+				; n in t1:t0
003165 0fa0      		add XL,t0
003166 1fb1      		adc XH,t1				; a = a + n in X
003167 93ba
003168 93aa      		push_X					; ( c a u )
003169 1b80      		sub tosl,t0				; u = u - n (new tib len)
00316a 0b91      		sbc tosh,t1				; ( c a u )
00316b 938f      		push tosl				; 'dup >r'
00316c 939f      		push tosh				; ( c a u			R: u )
00316d 810a      		ldd t0,Y+2				; c in t0
00316e dd02      		rcall SKIP_0			; ( c astart u' )	Z: astart	t0: c
00316f 93ef      		push ZL					; ( c astart u'		R: u astart )
003170 93ff      		push ZH
003171 9624      		adiw Y,4				; ( u' )			Z: astart	t0: c
003172 dd15      		rcall SCAN_loop			; ( aend u" )		Z: aend
003173 9700      		sbiw TOP,0
003174 f009      		breq PC+2
003175 9701      		  sbiw TOP,1
003176 901f      		pop t3
003177 900f      		pop t2					; astart in t3:t2
003178 19e0      		sub ZL,t2
003179 09f1      		sbc ZH,t3				; aend-astart (wlen)
00317a 8219      		std Y+1,t3
00317b 8208      		std Y+0,t2				; ( astart u" )
00317c 911f      		pop t1
00317d 910f      		pop t0					; u
00317e 1b08      		sub t0,tosl
00317f 0b19      		sbc t1,tosh				; u = u - u" in t1:t0
003180 01cf      		movw TOP,Z				; ( astart wlen )
003181 01f1      		movw Z,UP
003182 9734      		sbiw Z,(-utoin)
003183 91a1      		ld XL,Z+				; u >in +!
003184 91b1      		ld XH,Z+
003185 0fa0      		add XL,t0
003186 1fb1      		adc XH,t1
003187 93b2      		st -Z,XH
003188 93a2      		st -Z,XL
003189 9508      		ret						; ( astart wlen )
                      
                 
                 ;		fdw		UEMIT_L
00318a 0000      	.dw		0
                 ; WORD ( char -- c-addr )		word delimited by char and/or TAB
                 WORD_L:
00318b 7784
00318c 726f
00318d ff64      		.db		NFA|4,"word",0xff
                 WORD:
00318e dfcc      		rcall PARSE				; c-addr wlen
00318f 91e9
003190 91f9      		pop_Z
003191 9382      		st -Z,tosl
003192 2388      		tst tosl				; leave Z-flag for caller
003193 01cf      		movw TOP,Z
003194 9508      		ret
                 
                 
003195 f1e8      		fdw		INLINE_L
                 ; IMMED? ( nfa -- f )			fetch immediate flag
                 IMMEDQ_L:
003196 6986
003197 6d6d
003198 6465
003199 ff3f      		.db		NFA|6,"immed?",0xff
                 IMMEDQ: 
00319a d3d3      		rcall CFETCH_A
00319b 2e98      		mov wflags,tosl  		; COMPILE and INLINE flags for the compiler
00319c 7480      		andi tosl,IMMED
                 FINDx: 
00319d 9508      		ret
                 
                 
00319e ddba      		fdw		HERE_L
                 ; FIND	( c-addr -- c-addr 0 )	if not found
                 ;		(			xt     1 )	if immediate
                 ;		(			xt    -1 )	if normal
                 ; 3 chains for kernel words to speed up search
                 FIND_L:
00319f 6684
0031a0 6e69
0031a1 ff64      		.db		NFA|4,"find",0xff
                 FIND:   
0031a2 939a
0031a3 938a      		duptos
                 FIND_0:
0031a4 01fc      		movw Z,TOP
0031a5 9101      		ld t0,Z+
0031a6 e486
0031a7 ef9a      		ldi16 tos,((kernellink_short<<1)+PFLASH)
0031a8 3003      		cpi t0,3
0031a9 f030      		  brcs FIND_1
0031aa e48c
0031ab ee94      		ldi16 tos,((kernellink_mid<<1)+PFLASH)
0031ac 3005      		cpi t0,5
0031ad f010      		  brcs FIND_1
0031ae ed86
0031af ed9a      		ldi16 tos,((kernellink_long<<1)+PFLASH)
                 FIND_1:
0031b0 d077      		rcall findi
0031b1 f759      		  brne FINDx
0031b2 9180 02c2
0031b4 9190 02c3 		lds16 tos,dpLATEST
0031b6 c071      		rjmp findi
                 
                 
0031b7 e386      		fdw		TIB_L
                 ; TI# ( -- n )					size of TIB
                 ;	ti# task @ 8 + @ ;
                 TIBSIZE_L:
0031b8 7483
0031b9 2369      		.db		NFA|3,"ti#"
                 TIBSIZE:
0031ba 939a
0031bb 938a      		pushtos
                 TIBSIZE_0:
0031bc 01f1      		movw Z,UP
0031bd 973e      		sbiw Z,(-utask)
0031be 9181      		ld tosl,Z+
0031bf 9191      		ld tosh,Z+
0031c0 9608      		adiw TOP,8
0031c1 c3ab      		rjmp FETCH_A
                 
                 
0031c2 da86      		fdw		TIU_L
                 ; TIB ( -- a-addr )				Terminal Input Buffer
                 TIB_L:
0031c3 74a3
0031c4 6269      		.db		NFA|INLINE5|3,"tib"
                 TIB:
0031c5 939a
0031c6 938a      		pushtos
                 TIB_0:
0031c7 01f1      		movw Z,UP
0031c8 9770      		sbiw Z,(-utib)
0031c9 9181      		ld tosl,Z+
0031ca 9191      		ld tosh,Z+				; 6 / 11
0031cb 9508      		ret
                 
                 
0031cc eb68      		fdw		QABORTQ_L
                 ; >NUMBER ( 0 0 addr u -- ud.l ud.h addr' u' )
                 ;										  0  ) done
                 ;										<>0  ) not a number
                 ;								 convert string to number (u < 0x100)
                 TONUMBER_L:
0031cd 3e87
0031ce 756e
0031cf 626d
0031d0 7265      		.db		NFA|7,">number"
                 ;TONUMBER:
0031d1 01f1      		movw Z,UP
0031d2 9772      		sbiw Z,(-ubase)
0031d3 80b0      		ld ah,Z					; base in ah
                 TONUMBER_0:
0031d4 2ca6      		mov al,r_one			; init 'not a number'-flag
                 
                 TONUM_loop:
0031d5 2388      		  tst tosl	      		; ( ud.l ud.h addr u )
0031d6 f0b1      			breq TONUM_exit
0031d7 938f      		  push tosl				; (byte value)		
0031d8 9189
0031d9 9199      		  poptos				; ( ud.l ud.h addr		R: u )
0031da 938f      		  push tosl
0031db 939f      		  push tosh				; ( ud.l ud.h addr		R: u addr )
0031dc d391      		  rcall CFETCH_A
0031dd 328e      		  cpi tosl,'.'
0031de f131      			breq TONUM_next
                 ;TONUM_digitQ:				; inline DIGITQ
0031df 338a      		  cpi tosl,0x3a			; ( ud.l ud.h c )
0031e0 f018      			brcs TONUM_dQ1
0031e1 3681      		  cpi tosl,0x61
0031e2 f028      		    brcs TONUM_noDIGIT
0031e3 5287      		  subi tosl,0x27
                 TONUM_dQ1:
0031e4 5380      		  subi tosl,0x30		; 1
0031e5 f010      			brcs TONUM_noDigit
0031e6 158b      		  cp tosl,ah
0031e7 f040      			brcs TONUM_digit
                 TONUM_noDigit:
0031e8 919f      		  pop tosh
0031e9 918f      		  pop tosl				; (ud.l ud.h addr		R: u )
0031ea 939a
0031eb 938a      		  pushtos				; r> (byte value)
0031ec 918f      		  pop tosl				; ( ud.l ud.h addr u )
                 TONUM_exit:
0031ed 2799      		  clr tosh
0031ee 0d8a      		  add tosl,al			; generate 'not a number'-flag, leave valid Z-flag
0031ef 9508      		ret
                 
                 TONUM_digit:
                 ;baseStarPlus:				; multiply by base and add digit
0031f0 2e88      	 	  mov t8,tosl			; save digit
0031f1 91e9
0031f2 91f9      		  pop_t7t6				; ud.h
0031f3 91a9
0031f4 91b9      		  pop_t5t4				; ud.l
0031f5 9deb      		  mul t6,ah
0031f6 01c0      		  movw TOP,R1:R0
0031f7 9dab      		  mul t4,ah
0031f8 0180      		  movw t1t0,R1:R0
0031f9 9dfb      		  mul t7,ah
0031fa 0d90      		  add tosh,R0
0031fb 9dbb      		  mul t5,ah
0031fc 0d08      		  add t0,t8				; add digit
0031fd 1d10      		  adc t1,R0
0031fe 1d81      		  adc tosl,R1
0031ff 1d97      		  adc tosh,r_zero		; ud.l' in t1t0
                 		 					; ++++ end baseStarPlus ++++
003200 931a
003201 930a      		  push_t1t0				; ( ud'.l ud'.h 		R: u addr )
                 								; 18 / 28
003202 2ca7      		  mov al,r_zero			; clear 'not a number'-flag
003203 939a
003204 938a      		  pushtos
                 
                 TONUM_next:
003205 919f      		  pop tosh
003206 918f      		  pop tosl				; ( ud'.l ud'.h addr		R: u )
003207 9601      		  adiw TOP,1			; <addr+1>
003208 939a
003209 938a      		  pushtos
00320a 918f      		  pop tosl				; byte value
00320b 5081      		  subi tosl,1			; ( ud'.l ud'.h addr+1 u-1 )
00320c cfc8      		rjmp TONUM_loop
                 
                 
00320d eef8      		fdw		STAR_L
                 ; ( ( -- )						skip input until ')'
                 PAREN_L:
00320e 28c1      		.db		NFA|IMMED|1,"("
                 ;PAREN:
00320f d3df      		rcall DOLIT
003210 0029      		.dw   ')'
003211 df49      		rcall PARSE
003212 7b6f      		cbr FLAGS1,(1<<doclear)	; don't clear flags in case of '('
003213 cd03      		rjmp TWODROP
                 
                 
003214 d932      		fdw		TWOSLASH_L
                 TWOMINUS_L:
003215 32a2
003216 ff2d      		.db		NFA|INLINE|2,"2-",0xff
                 ;TWOMINUS:
                 waste9:
003217 9702      		sbiw TOP,2				; 1 / 2
003218 9508      		ret
                 
                 
003219 fa62      		fdw		CSTORE_L
                 ; BL ( -- char )				ASCII space
                 BL_L:
00321a 62a2
00321b ff6c      		.db		NFA|INLINE4|2,"bl",0xff
                 BL:
00321c 939a
00321d 938a      		pushtos
                 ;BL_0:
00321e e280      		ldi tosl,' '
00321f e090      		ldi tosh,0x00			; 4 / 6
003220 9508      		ret
                 
                 BL_WORD:
003221 939a
003222 938a      		pushtos
003223 e280      		ldi tosl,' '
003224 cf69      		rjmp WORD
                 
                 
003225 eeb2      		fdw		DOTID_L
                 ; findi	( c-addr nfa -- c-addr 0 )	if not found
                 ;		(				xt     1 )	if immediate
                 ;		(				xt    -1 )	if normal
                 ; first in RAM, second in FLASH, Z-flag
                 BRACFIND_L:
                 kernellink_mid:
003226 2883
003227 2966      		.db		NFA|3,"(f)"
                 findi:
                 findi_loop:
003228 81a8      		  ldd XL,Y+0			; c-addr -> X
003229 81b9      		  ldd XH,Y+1
00322a 010c      		  movw t3t2,TOP			; save NFA
00322b d20d      		  rcall NEQUAL_0		; leaves valid Z-flag
00322c f041      			breq findi_match
00322d 01f0      		  movw Z,t3t2
00322e 9732      		  sbiw Z,2				; NFA -> LFA
00322f 9468      		  set					; 'fetch word' flag
003230 940e 3cc2 		  call IFETCH
003232 9700      		sbiw TOP,0				; LFA 0=?
003233 f7a1      		brne findi_loop			; no -> valid new NFA -> loop
                 		;sez
003234 9508      		ret						; yes-> end of dict -> return
                 
                 findi_match:					; TOP = 0 
003235 9631      		adiw Z,1				; 'aligned'
003236 7fee      		cbr ZL,1
003237 58f0      		add_pflash_z
003238 83e8      		std Y+0,ZL				; CFA > next
003239 83f9      		std Y+1,ZH
00323a 2e90      		mov wflags,t0  			; COMPILE and INLINE flags for the compiler (loaded to t0 in NEQUAL)
00323b 9701      		sbiw TOP,1				; 'normal'		Z clear	N set
00323c fc96      		sbrc wflags,IMMEDbit
00323d 9602      		  adiw TOP,2			; ->'immediate'	Z clear N clear
                 ;;		clz
00323e 9508      		ret
                 
                 
                 PLUSC_:
00323f 9180 02c7 		lds tosl,litbuf0		; optimize 'LIT +'
003241 b59b      		in  tosh,litbuf1
                 ;PLUSC_0:
003242 9580      		com tosl
003243 9590      		com tosh
003244 0d86      		add tosl,r_one
003245 1d97      		adc tosh,r_zero
003246 bd9b      		out litbuf1,tosh
003247 d004      		rcall ANDIC1
                 
                 	.if CPU_LOAD == 1
003248 e410      			ldi t1,0x40			; 'sbci ..'
                 	.else
                 	.endif
                 
003249 c00d      		rjmp ORIC_1
                 
                 ANDIC0:
00324a 9180 02c7 		lds tosl,litbuf0
                 ANDIC1:
00324c e008      		ldi t0,8
00324d d5f4      		rcall IDPMINUS
                 ANDIC2:
00324e 2f98      		mov tosh,tosl
00324f 9592      		swap tosh
003250 708f      		andi tosl,0x0f
003251 709f      		andi tosh,0x0f
003252 9508      		ret
                 
                 ANDIC_:
                 	.if CPU_LOAD == 1
003253 e710      			ldi t1,0x70			; 'andi ..'
                 	.else
                 	.endif
                 
003254 c001      		rjmp ORIC_0
                 
                 ORIC_:							; optimize 'LIT or'
                 	.if CPU_LOAD == 1
003255 e610      			ldi t1,0x60			; 'ori ..'
                 	.else
                 	.endif
                 ORIC_0:
003256 dff3      		rcall ANDIC0
                 ORIC_1:
003257 6880      		ori tosl,regtosl
                 
                 	.if CPU_LOAD ==1
003258 2e81      			mov t8,t1
003259 2998      			or tosh,t8
                 	.else
                 	.endif
                 
00325a ff95      		sbrs tosh,5
00325b 6190      	  	  ori tosh,0x10			; 'subi ..' >< 'sbci ..'
00325c d463      		rcall ICOMMA_
                 
00325d 939a
00325e 938a      		pushtos
00325f b58b      		in tosl,litbuf1
003260 dfed      		rcall ANDIC2
003261 6980      		ori tosl,regtosh
                 
                 	.if CPU_LOAD == 1
003262 2998      			or tosh,t8
                 	.else
                 	.endif
                 
003263 c45c      		rjmp ICOMMA_
                 
                 MINUSC_:
                 	.if CPU_LOAD == 1
003264 e410      			ldi t1,0x40			; 'sbci ..'
                 	.else
                 	.endif
                 
003265 cff0      		rjmp ORIC_0
                 
                 
                 .if optimizingCOMPILER == 1
                 	STARIC_:						; fdw STAR in TOP
003266 d45a      			rcall ldi16_t1t0_C_
003267 9604      			adiw TOP,4
003268 b51b      			in t1,litbuf1
003269 1117      			cpse t1,r_zero
00326a c693      			  rjmp INLINE0			; -> fdw STAR_0
00326b e002      			ldi t0,2
00326c d5d5      			rcall IDPMINUS
00326d 9640      			adiw TOP,16				; -> fdw cSTAR_0
00326e c68f      			rjmp INLINE0
                 
                 	ULESSC_:						; fdw ULESS in TOP
00326f 9688      			adiw TOP,40				; -> fdw UGREATER_0	(+24) (TOP >< t1:t0 swapped)
                 
                 	UGREATERC_:						; fdw UGREATER in TOP
003270 9604      			adiw TOP,4				; -> fdw ULESS_0 	(-16) (TOP >< t1:t0 swapped)
                 
                 	GREATERC_:						; fdw GREATER in TOP
003271 9744      			sbiw TOP,20				; -> fdw LESS_0		(-20) (TOP >< t1:t0 swapped)
                 			
003272 d015      			rcall checkDUP
                 
003273 e010      			ldi t1,regt1t0
003274 e008      			ldi t0,8
003275 fd65      			sbrc FLAGS1,idup
003276 e00c      			  ldi t0,12
003277 d44b      			rcall ldi16_thtl_C_DUP_
                 			
003278 6061      			sbr FLAGS1,(1<<icarryeq)
003279 c684      			rjmp INLINE0
                 
                 	LESSC_:							; fdw LESS in TOP
00327a 9680      			adiw TOP,32				; -> fdw GREATER_1	(+32) (TOP >< t1:t0 swapped)
00327b 939a
00327c 938a      			pushtos
00327d dfe6      			rcall MINUSC_
00327e 6061      			sbr FLAGS1,(1<<icarryeq)
00327f c67e      			rjmp INLINE0
                 
                 
                 
                 	EQUALC_:						; fdw EQUAL in TOP
003280 d007      			rcall checkDUP
003281 dfe2      			rcall MINUSC_
003282 6164      			sbr FLAGS1,(1<<izeroeq)|(1<<iLITeq)
003283 939a
003284 938a
003285 eb8e
003286 ed99      			inline_DOLIT ((ZEROEQUAL<<1)+PFLASH)
003287 c676      			rjmp INLINE0
                 
                 	checkDUP:
003288 7d6f      			cbr FLAGS1,(1<<idup)
003289 d37c      			rcall IHERE
00328a 970c      			sbiw TOP,12				; look for 'dup' preceeding LIT
00328b d2e1      			rcall FETCH_A			; (valid addr+2 returned in Z)
00328c 398a      			cpi tosl, LOW(0x939a)	; 'pushtosH'?
00328d f419      			  brne checkDUP_non
00328e 3993      			cpi tosh,HIGH(0x939a)
00328f f409      			  brne checkDUP_non
                 			;rcall FETCH_Zplus		; (skip check to save space)
                 			;cpi tosl, LOW(0x938a)	; 'pushtosL'?
                 			;  brne _noDUP
                 			;cpi tosh,HIGH(0x938a)
                 			;  brne _noDUP
003290 6260      			sbr FLAGS1,(1<<idup)
                 	checkDUP_non:
003291 ccbb      			rjmp DROP
                 .endif
                 
                 SWOP_A:
003292 ccc1      		rjmp SWOP
                 
                 .if optimizingCOMPILER == 1
                 	optMEM_helper:
003293 9180 02c7 			lds tosl,litbuf0
003295 b59b      			in  tosh,litbuf1
003296 e008      			ldi t0,8
003297 c5aa      			rjmp IDPMINUS
                 
                 	STOREC_2LIT:
003298 d428      			rcall ldi16_t1t0_C_
003299 e1a0      			ldi t4,regt1			; register 0x11 -> t1
00329a d21f      			rcall comp_sts_
00329b c21d      			rjmp comp_sts_t0
                 
                 	STOREC_:
00329c dff6      			rcall optMEM_helper
00329d 939a
00329e 938a      			duptos
00329f 9601      			adiw TOP,1				; high byte <addr+1>
0032a0 fd63      			sbrc FLAGS1,f2LIT
0032a1 cff6      			  rjmp STOREC_2LIT
                 	STOREC_1LIT:
0032a2 e9a0      			ldi t4,regtosh			; register 0x19 -> tosh
0032a3 d216      			rcall comp_sts_
0032a4 c003      			rjmp STOREC_helper
                 
                 	CSTOREC_:
0032a5 dfed      			rcall optMEM_helper
0032a6 fd63      			sbrc FLAGS1,f2LIT
0032a7 c007      			  rjmp CSTOREC_2LIT
                 	CSTOREC_1LIT:
                 	STOREC_helper:
0032a8 e8a0      		 	ldi t4,regtosl			; register 0x18 -> tosl
                 	STOREC_help1:
0032a9 d210      			rcall comp_sts_
                 	STOREC_help2:
0032aa 939a
0032ab 938a      			pushtos
0032ac e98a
0032ad ed9e      			ldi16 tos,((DROP<<1)+PFLASH)
0032ae c64f      			rjmp INLINE0
                 
                 	CSTOREC_2LIT:
0032af d411      			rcall ldi16_t1t0_C_
0032b0 e002      			ldi t0,2
0032b1 d590      			rcall IDPMINUS			; wipe 'ldi t1,<lit.1>'
0032b2 c206      			rjmp comp_sts_t0	
                 .endif
                 
0032b3 0000      		.dw		0
                 ; INTERPRET ( c-addr u -- )		interpret given buffer (in RAM)
                 INTERPRET_L:
0032b4 6989
0032b5 746e
0032b6 7265
0032b7 7270
0032b8 7465      		.db		NFA|9,"interpret"
                 INTERPRET:
0032b9 9109
0032ba 9119      		pop_t1t0
0032bb 01d1      		movw X,UP
0032bc 9718      		sbiw X,(-usource)
0032bd 930d      		st X+,t0
0032be 931d      		st X+,t1
0032bf 938d      		st X+,tosl
0032c0 939d      		st X+,tosh
0032c1 9189
0032c2 9199      		poptos
0032c3 927d      		st X+,r_zero			; utoin
0032c4 927d      		st X+,r_zero
                 IPARSEWORD:
0032c5 df5b      		rcall BL_WORD
0032c6 f409      		brne PC+2				; valid Z-flag left by 'WORD'
0032c7 cc85      		  rjmp DROP				; INOWORD
0032c8 ded9      		rcall FIND 				; sets also wflags, leaves valid Z-flag
                 						; 0 = not found, -1 = normal, 1 = immediate
0032c9 9189
0032ca 9199      		poptos
0032cb f409      		brne PC+2
0032cc c07b      		  rjmp INUMBER			; 'not found' -> is it a number?
0032cd f412      		brpl IPARSEWORD_3		; 'immediate'
0032ce fd77      		sbrc FLAGS2,fSTATE
0032cf c012      		  rjmp ICOMPILE_1		; 'normal & compiling' -> go compile
                 IPARSEWORD_3:
                 								; ..'immediate' or 'interpreting'
0032d0 fc94      		sbrc wflags,COMPILEbit
0032d1 fd77      		sbrc FLAGS2,fSTATE
0032d2 c009      		  rjmp IEXECUTE			; (not a compile only word) OR ('compile only' && 'compiling') -> execute
0032d3 d4bb      		rcall XSQUOTE
0032d4 430c
0032d5 4d4f
0032d6 4950
0032d7 454c
0032d8 4f20
0032d9 4c4e
0032da ff59      		.db 12,"COMPILE ONLY",0xff
0032db c2ed      		rjmp QABORT_1
                 IEXECUTE:
0032dc 6460      		sbr FLAGS1,(1<<doclear)
0032dd 940e 3e81 		call EXECUTE
0032df fd66      		sbrc FLAGS1,doclear		; cleared by '\', '(', 'literal' and 'constant'
0032e0 7462      		  cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)|(1<<iLITeq)|(1<<idup)|(1<<fLIT)|(1<<f2LIT)
0032e1 cfe3      		rjmp IPARSEWORD
                 
                 ICOMPILE_1:
0032e2 7e6e      		cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)
                 								; check for 0=, modifies IF, WHILE and UNTIL to use brne
0032e3 ed19      		ldi t1, HIGH((ZEROEQUAL<<1) + PFLASH)
0032e4 3b8e      		cpi tosl,LOW((ZEROEQUAL<<1) + PFLASH)
0032e5 0791      		cpc tosh,t1
0032e6 f411      		  brne ICOMPILE_2
0032e7 6160      		sbr FLAGS1,(1<<izeroeq)	; mark '0= encountered in compilation'
0032e8 c055      		rjmp ICOMPILE
                 
                 ICOMPILE_2:
0032e9 ff67      		sbrs FLAGS1,fLIT
0032ea c04d      		  rjmp ICOMPILE_00
                 
                 .if optimizingCOMPILER == 0
                 .elif optimizingCOMPILER == 1
                 
0032eb e0ec
0032ec e6f6      			ldi16 Z,(optTAB*2)
0032ed e1ac      			ldi t4,optTAB_count
                 	optLoop:
0032ee 9105      			  lpm t0,Z+
0032ef 9115      			  lpm t1,Z+
0032f0 1780      			  cp  tosl,t0
0032f1 0791      			  cpc tosh,t1
0032f2 f019      			    breq foundOpt
0032f3 95aa      			dec t4
0032f4 f7c9      			brne optLoop
0032f5 c042      			  rjmp ICOMPILE_00		; -> go on with no opt found
                 	
                 	foundOpt:
0032f6 30a7      			cpi t4,WORDIC_check
0032f7 f418      			brcc fO_yyy
                 			  					; WORDIC_ optimization		
0032f8 d3c8      			  rcall ldi16_t1t0_C_	; replace LIT by 'ldi t0,<lit.0> ldi t1,<lit.1>'
0032f9 9604      			  adiw TOP,4			; skip 'pop_t1t0' at beginning of word
0032fa c043      			  rjmp ICOMPILE
                 
                 		fO_yyy:
0032fb 30ab      			cpi t4,PEEPROMcheck
0032fc f418      			brcc fO_xxx
0032fd b51b      			  in t1,litbuf1			; @ c@ ! c!
0032fe 3019      			  cpi t1,HIGH(PEEPROM)	; ..for ram access only (lit.h < PEEPROM)
0032ff f5c0      			  brcc ICOMPILE_00
                 
                 		fO_xxx:
003300 96f6      			adiw Z,(optTAB_count*2-2)
003301 9105      			lpm t0,Z+				; read address of .... opt routine
003302 9115      			lpm t1,Z+
003303 01f8      			movw Z,t1t0
003304 9509      			icall					; call opt routine
003305 c040      			rjmp ICLRFLIT			; clear fLIT and f2LIT, go on parsing
                 
                 	.equ optTAB_count = 28
                 	.equ WORDIC_check =  7
                 	.equ PEEPROMcheck = WORDIC_check + 4
                 
                 	optTAB:
003306 d8b4      		fdw AND_
003307 d8c4      		fdw OR_
003308 df26      		fdw PLUS
003309 e116      		fdw MINUS
00330a eefa      			fdw STAR
00330b e02c      			fdw NOTEQUAL
00330c e03a      			fdw EQUAL
00330d e080      			fdw ULESS
00330e e094      			fdw UGREATER
00330f e04e      			fdw LESS
003310 e066      			fdw GREATER
003311 f492      			fdw TO_A
003312 e0a8      			fdw STORE_P
003313 e0e0      			fdw STORE_P_TO_R
003314 db2e      			fdw MSET
003315 db48      			fdw MCLR
003316 db7c      			fdw MTST
003317 db64      			fdw MTSTZ
                 		;.equ PEEPROMcheck = WORDIC_check + 4
003318 fa48      			fdw STORE				; words requiring an address check 'below PEEPROM?'
003319 fa66      			fdw CSTORE
00331a fa18      			fdw FETCH
00331b fa36      			fdw CFETCH
                 		;.equ WORDIC_check = 5
00331c d8d4      			fdw XOR_				; words not requiring a special routine
00331d d878      			fdw UMIN				; .. by simply loading LIT to t1:t0
00331e d88e      			fdw UMAX
00331f fcb6      			fdw MIN
003320 fc9a      			fdw MAX
003321 fb04      			fdw SCALE
                 
003322 3253      		.dw ANDIC_
003323 3255      		.dw ORIC_
003324 323f      		.dw PLUSC_
003325 3264      		.dw MINUSC_
003326 3266      			.dw STARIC_
003327 3264      			.dw MINUSC_
003328 3280      			.dw EQUALC_
003329 326f      			.dw ULESSC_
00332a 3270      			.dw UGREATERC_
00332b 327a      			.dw LESSC_
00332c 3271      			.dw GREATERC_
00332d 3058      			.dw TO_A_C_
00332e 3069      			.dw STORE_P_C_
00332f 305c      			.dw STORE_P_TO_R_C_
003330 34ad      			.dw MSETC_
003331 3494      			.dw MCLRC_
003332 3476      			.dw MTSTC_
003333 345f      			.dw MTSTZC_
                 		; PEEPROMcheck ...
003334 329c      			.dw STOREC_
003335 32a5      			.dw CSTOREC_
003336 3c65      			.dw FETCHC_
003337 3c69      			.dw CFETCHC_
                 		; WORDIC_check - no entries needed
                 .else .error "illegal value: optimizingCOMPILER"
                 .endif
                 
                 ICOMPILE_00:
003338 7d6f      		cbr FLAGS1, (1<<idup)	; clear 'DUP encountered in compilation'
003339 ed19      		ldi t1, HIGH((DUP<<1) + PFLASH)
00333a 3b82      		cpi tosl,LOW((DUP<<1) + PFLASH)
00333b 0791      		cpc tosh,t1				; check for DUP, modies IF and UNTIL to use DUPZEROSENSE
00333c f409      		brne ICOMPILE
00333d 6260      		  sbr FLAGS1,(1<<idup)	; mark DUP encountered during compilation
                 ICOMPILE:
00333e fe95      		sbrs wflags,INLINEbit	; inline check
00333f c002      		  rjmp ICOMMAXT
003340 d5bd      		rcall INLINE0
003341 c004      		rjmp ICLRFLIT
                 
                 ICOMMAXT:
003342 dba9      		rcall COMMAXT
003343 7f6d      		cbr FLAGS1,(1<<fTAILC)	; allow tail jump  optimization
003344 fc94      		sbrc wflags,COMPILEbit	; compile only ?
003345 6062      		  sbr FLAGS1,(1<<fTAILC); ->  prevent tail jump  optimization
                 ICLRFLIT:
003346 7767      		cbr FLAGS1,(1<<fLIT)|(1<<f2LIT)
003347 cf7d      		rjmp IPARSEWORD
                 
                 INUMBER: 
003348 7c62      		cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)|(1<<iLITeq)|(1<<idup)|(1<<f2LIT)
                 ;		poptos
003349 d01c      		rcall NUMBERQ
00334a 9700      		sbiw TOP,0
00334b f071      		  breq IUNKNOWN
00334c ff77      		sbrs FLAGS2,fSTATE
00334d c009      		  rjmp INUMBER1			; 'interpret' -> 
00334e 2f08      		mov t0,tosl
00334f 9189
003350 9199      		poptos
003351 ff01      		sbrs t0,1
003352 c002      		  rjmp ISINGLE
                 IDOUBLE:
003353 dc00      		rcall SWOP
003354 d2be      		rcall LITERAL_A
                 ISINGLE:
003355 d2bd      		rcall LITERAL_A
003356 cf6e      		rjmp IPARSEWORD
                 
                 INUMBER1:
003357 9189
003358 9199      		poptos
003359 cfec      		rjmp ICLRFLIT
                 
                 IUNKNOWN:
00335a 7767      		cbr FLAGS1,(1<<fLIT)|(1<<f2LIT)
00335b 9189
00335c 9199      		poptos
00335d d09c      		rcall DP_TO_RAM
00335e d7f5      		rcall CFETCHPP
00335f d48d      		rcall TYPE
003360 c25b      		rjmp QABORTQ_0			; never returns & resets the stacks
                 
                 
003361 ee22      		fdw		TICKStoNEXT_L
                 ; NUMBER?	( c-addr --     n  1 ) single
                 ;			(		 -- dl dh  2 ) double
                 ;			(		 -- c-addr 0 ) if convert error
                 NUMBERQ_L:
003362 6e87
003363 6d75
003364 6562
003365 3f72      		.db		NFA|7,"number?"
                 NUMBERQ:
003366 939a
003367 938a      		duptos					; a a  (for the 'not a number'-case)
003368 927a      		st -Y,r_zero
003369 927a      		st -Y,r_zero
00336a 927a      		st -Y,r_zero
00336b 927a      		st -Y,r_zero			; a 0 0 a
00336c 01dc      		movw X,TOP
00336d 918d      		ld tosl,X+
00336e 2799      		clr tosh				; a 0 0 n	X: a+1
00336f 910c      		ld t0,X				; inline 'sign?'
003370 520b      		subi t0,'+'
003371 f021      		  breq isSign
003372 3002      		cpi t0,2				; '-'
003373 f011      		  breq isSign
003374 2700      		clr t0
003375 c002      		rjmp prefix
                 isSign:
003376 9701      		  sbiw TOP,1			; a 0 0 n-1
003377 9611      		  adiw X,1				;			X: a+1
                 prefix:
003378 930f      		push t0					; save sign
                 
003379 01f1      		movw Z,UP				; get current base
00337a 9772      		sbiw Z,(-ubase)
00337b 80b0      		ld ah,Z
                 
00337c 910c      		ld t0,X					; check for base-prefix
00337d 5203      		subi t0,'#'
00337e f021      		  breq baseQ_dec		; '#' (=0)
00337f 3002      		cpi t0,2
003380 f019      		  breq baseQ_bin		; '%' (=2)
003381 f428      		  brcc BASEQ1			; no prefix
                 baseQ_hex:						; '$' (=1)
003382 5f0b      		subi t0,-5
                 baseQ_dec:
003383 5f06      		subi t0,-10
                 
                 baseQ_bin:
003384 2eb0      		mov ah,t0				; set temporary base (from prefix)
003385 9701      		sbiw TOP,1				; a 0 0 n-1
003386 9611      		adiw X,1				;			X: a+1
                 BASEQ1:
003387 93ba
003388 93aa      		push_X					; a 0 0 a' n'
003389 de4a      		rcall TONUMBER_0		; leaves valid Z-flag
00338a 9189
00338b 9199      		poptos					; a ud.l ud.h a' 
00338c f4a9      		  brne QNUM_ERR
                 
00338d 9701      		sbiw TOP,1				; read last char from buf
00338e d1df      		rcall CFETCH_A			; a ud.l ud.h c
                 
00338f 528e      		subi tosl,'.'			; check for 'double'-sign
003390 9189
003391 9199      		poptos					; a ud.l ud.h
003392 910f      		pop t0					;				t0: sign
003393 f431      		  brne QNUM_single
                 ;QNUM_double:
003394 1107      		cpse t0,r_zero
003395 d609      		  rcall DNEGATE
003396 d7b0      		rcall ROT				; d.l d.h a
003397 e082      		ldi tosl,2
003398 e090      		ldi tosh,0
003399 9508      		ret
                 
                 QNUM_single:
00339a 9189
00339b 9199      		poptos					; a ud.l	t0: sign
00339c 1107      		cpse t0,r_zero
00339d d706      		  rcall NEGATE
00339e 8388      		std Y+0,tosl			; d.l d.l
00339f 8399      		std Y+1,tosh
0033a0 01c3      		movw TOP,r_one			; d.l 1 - single precision number
0033a1 9508      		ret
                 
                 QNUM_ERR:					; not a number
0033a2 910f      		pop t0					; drop sign-flag from R
0033a3 9624      		adiw Y,4
0033a4 2788      		clr tosl				; a 0 (convert error)
0033a5 2799      		clr tosh
0033a6 9508      		ret
                 
                 
                 ; DOCREATE						 code action of CREATE
                 ; fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
0033a7 2883
0033a8 2963      		.db		NFA|3, "(c)"	; just for 'see' to work
                 DOCREATE:
                 		m_pop_zh
0033a9 91ff      		pop ZH
0033aa 91ef      		pop ZL
                 		;rjmp FETCHLIT
                 FETCHLIT:
0033ab 939a
0033ac 938a      		pushtos
0033ad 0fee      		lsl ZL
0033ae 1fff      		rol ZH
0033af 9185      		lpm_ tosl,Z+
0033b0 9195      		lpm_ tosh,Z+
0033b1 9508      		ret
                 
                 
0033b2 2883
0033b3 292c      		.db		NFA|3, "(,)"	; just for 'see' to work
                 DOCOMMAXT:
                 		m_pop_t0
0033b4 91ff      		pop ZH
0033b5 91ef      		pop ZL
0033b6 dff4      		rcall FETCHLIT
0033b7 95f7      		ror ZH					; C-flag set by FETCHLIT
0033b8 95e7      		ror ZL
0033b9 93ef      		push ZL
0033ba 93ff      		push ZH
                 		m_push_t0
0033bb cb30      		rjmp COMMAXT
                 
                 
0033bc f126      		fdw		ZEROIF_L
                 ; .st ( -- )					output a string with current data section and current base info
                 ;	base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;	<# [char] > hold cse @ #s #> type base ! ;
                 DOTSTATUS_L:
0033bd 2e83
0033be 7473      		.db		NFA|3,".st"
                 DOTSTATUS:
                 ;### no runtime otimization
0033bf e30c      		ldi t0,'<'
0033c0 d2b3      		rcall EMIT_t0
                 		;rcall DOTBASE
                 ;DOTBASE:					; ++++ begin inline DOTBASE ++++
0033c1 01f1      		movw Z,UP
0033c2 9772      		sbiw Z,(-ubase)
0033c3 8110      		ld t1, Z
0033c4 e204      		ldi t0,'$'				; hex
0033c5 3110      		cpi t1,0x10
0033c6 f039      		  breq DOTBASE_done
                 ;		ldi t0,'%'				; bin
                 ;		cpi t1,2				; replaced by '2'
                 ;		  breq DOTBASE_done
0033c7 e203      		ldi t0,'#'				; decimal
0033c8 301a      		cpi t1,10
0033c9 f021      		  breq DOTBASE_done
0033ca e30f      		ldi t0, '?'
0033cb f410      		  brcc DOTBASE_done
0033cc 5d10      		subi t1,-'0'			; less than #10 -> display as decimal digit
0033cd 2f01      		mov t0,t1
                 DOTBASE_done:					; ++++ end inline ++++
0033ce d2a5      		rcall EMIT_t0
0033cf e20c      		ldi t0,','
0033d0 d2a3      		rcall EMIT_t0
                 		;rcall MEMQ
                 
                 ; M? ( -- caddr count )			current data space string
                 MEMQ:						; +++ begin inline MEMQ +++
0033d1 939a
0033d2 938a      		pushtos
0033d3 b5ea      		in ZL,cse
0033d4 27ff      		clr ZH
0033d5 5de0      		subi ZL, LOW(-(MEMQADDR_N<<1))
0033d6 4af8      		sbci ZH,HIGH(-(MEMQADDR_N<<1))
0033d7 9185      		lpm tosl,Z+
0033d8 9195      		lpm tosh,Z+
0033d9 d77a      		rcall CFETCHPP
0033da 708f      		andi tosl,NFAmask
                 							; +++ end inline +++
0033db d411      		rcall   TYPE
0033dc e30e      		ldi t0,'>'
0033dd d296      		rcall EMIT_t0
0033de c3f9      		rjmp DOTS
                 
                 
                 ; >dp ( -- )					copy (only changed) turnkey, dp's and latest from RAM to EEPROM
0033df 3e83
0033e0 7064      		.db		NFA|3,">dp"		; just for 'see' to work
                 DP_TO_EEPROM:
0033e1 e0e9
0033e2 e0f0      		ldi16 Z,(dp_start+9-PEEPROM)
0033e3 eca4
0033e4 e0b2      		ldi16 X,(dpSTART+10)
                 DP_TO_EEPROM_loop:
0033e5 99f9
0033e6 cffe      DTE_wait: sbic EECR,EEWE	rjmp DTE_wait	; EEPROM ready?
                 
0033e7 bdf2      		  out EEARH,ZH
0033e8 bde1      		  out EEARL,ZL
0033e9 ba6f      		  out EECR,r_one		; (1<<EERE)
0033ea b500      		  in t0,EEDR
0033eb 911e      		  ld t1,-X
0033ec 1701      		  cp t0,t1
0033ed f039      		  breq DP_TO_EEPROM_0
0033ee bd10      			out EEDR,t1			; value changed -> write to EEPROM
0033ef b70f      			in_ t0,SREG
0033f0 94f8      			cli
0033f1 e014      			ldi t1,(EEMPE<<1)
0033f2 bb1f      			out EECR,t1
0033f3 9af9      			sbi EECR,EEWE
0033f4 bf0f      			out_ SREG,t0
                 ;	sei
                 		  .if DEBUG_FLASH == 1	; write a '+' for every changed byte
                 		  .endif
                 DP_TO_EEPROM_0:
0033f5 50e1      		subi ZL,1				; dp_start on page boundary!!
0033f6 f770      		brcc DP_TO_EEPROM_loop
0033f7 9508      		ret
                 
                 
                 ; dp> ( -- )					copy ini, dps and latest from EEPROM to RAM
0033f8 6483
0033f9 3e70      		.db		NFA|3,"dp>"		; just for 'see' to work
                 DP_TO_RAM:
0033fa e0e9
0033fb e0f0      		ldi16 Z,(dp_start+9-PEEPROM)
0033fc eca4
0033fd e0b2      		ldi16 X,(dpSTART+10)
                 
0033fe 99f9
0033ff cffe      DTR_wait: sbic EECR,EEWE     rjmp DTR_wait	; EEPROM ready?
                 
003400 bdf2      		out EEARH,ZH
                 DP_TO_RAM_loop:
003401 bde1      		  out EEARL,ZL
003402 ba6f      		  out EECR,r_one		; (1<<EERE)
003403 b510      		  in t1,EEDR
003404 931e      		  st -X,t1
003405 50e1      		subi ZL,1				; dp_start on page boundary!!
003406 f7d0      		brcc DP_TO_RAM_loop
003407 9508      		ret
                 
                 
003408 dd7e      		fdw		FLASH_L
                 FALSE_L:
003409 66a5
00340a 6c61
00340b 6573      		.db		NFA|INLINE4|5,"false"
                 FALSE_:							; put 0000 (FALSE) on data stack
                 ZERO:
00340c 939a
00340d 938a      		pushtos
                 ;FALSE_pushed:
00340e 2788      		clr tosl
00340f 2799      		clr tosh				; 4 / 6
003410 9508      		ret
                 
                 
003411 e12e      		fdw		TUCK_L
                 TRUE_L:
003412 74a4
003413 7572
003414 ff65      		.db		NFA|INLINE4|4,"true",0xff
                 ;TRUE_:							; put ffff (TRUE) on data stack
003415 939a
003416 938a      		pushtos
                 ;TRUE_pushed:
                 NEQUAL_noMatch:
003417 ef8f      		ser tosl
003418 ef9f      		ser tosh				; 5 / 7
                 SHIFT_ret:
003419 9508      		ret
                 
                 
00341a f540      		fdw		NEGATE_L
                 ; LSHIFT ( x1 u -- x2 )			shift left u bit positions
                 LSHIFT_L:
00341b 6c86
00341c 6873
00341d 6669
00341e ff74      		.db		NFA|6,"lshift",0xff
                 LSHIFT:
00341f 01fc      		movw Z,TOP
003420 9189
003421 9199      		poptos
                 LSHIFT1:
003422 9731      		  sbiw Z,1
003423 f3aa      			brmi SHIFT_ret
003424 0f88      		  lsl tosl
003425 1f99      		  rol tosh
003426 cffb      		rjmp LSHIFT1
                 	
                 
003427 f91a      		fdw		SOURCE_L
                 ; RSHIFT ( x1 u -- x2 )			shift right u bit positions
                 RSHIFT_L:
003428 7286
003429 6873
00342a 6669
00342b ff74      		.db		NFA|6,"rshift",0xff
                 RSHIFT:
00342c 01fc      		movw Z,TOP
00342d 9189
00342e 9199      		poptos
                 RSHIFT1:
00342f 9731      		  sbiw Z,1
003430 f342      			brmi SHIFT_ret
003431 9596      		  lsr tosh
003432 9587      		  ror tosl
003433 cffb      		rjmp RSHIFT1
                 
                 
003434 d8c0      		fdw		OR_L
                 ; N= ( c-addr nfa -- n )		compare strings
                 ;					 0    ) s1==s2
                 ;                    ffff ) s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; it can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in RAM and the second in program memory (FLASH).
                 NEQUAL_L:
003435 6e82
003436 ff3d      		.db		NFA|2,"n=",0xff
                 ;NEQUAL:
003437 91a9
003438 91b9      		pop_X
                 NEQUAL_0:
003439 01fc      		movw Z,TOP
00343a 58f0      		sub_pflash_z
00343b 919d      		ld tosh,X+
00343c 9185      		lpm tosl,Z+
00343d 2f08      		mov t0,tosl				; save length+flags for caller
00343e 708f      		andi tosl,0x0f			; length
00343f 1789      		cp tosl,tosh
003440 f6b1      		  brne NEQUAL_noMatch	; Z flag valid
                 
                 NEQUAL_loop:					; length in tosh as loop count
003441 9185      		  lpm tosl,Z+
003442 911d      		  ld t1,X+
003443 1718      		  cp t1,tosl
003444 f691      			brne NEQUAL_noMatch
003445 959a      		dec tosh
003446 f7d1      		brne NEQUAL_loop
                 NEQUAL_match:					; Z flag valid
003447 2788      		clr tosl				; n=0: s1==s2
                 		;clr tosh				; (already there)
003448 9508      		ret
                 
                 ;NEQUAL_noMatch:
                 ;		rjmp TRUE_pushed		; n=ffff: s1!=s2
                 
                 
003449 dd8a      		fdw		EEPROM_L
                 ; DIGIT? ( c -- n f )			check char for beeing a valid digit (base < 0xd0)
                 DIGITQ_L:
00344a 6486
00344b 6769
00344c 7469
00344d ff3f      		.db		NFA|6,"digit?",0xff
                 ;DIGITQ:						; '0' = 0x30    'a' = 0x61
00344e 338a      		cpi tosl,0x3a
00344f f018      		  brcs DIGITQ1
003450 3681      		cpi tosl,0x61
003451 f018      		  brcs noDIGIT
003452 5287      		subi tosl,0x27
                 DIGITQ1:
003453 5380      		subi tosl,0x30			; '0'
003454 f408      		brcc DIGITQ2			; not needed for base < 0xd0
003455 cfb6      noDIGIT:  rjmp FALSE_
                 DIGITQ2:
003456 939a
003457 938a      		duptos
003458 01f1      		movw Z,UP
003459 9772      		sbiw Z,(-ubase)
00345a 8190      		ld tosh,Z				; base in tosh
00345b 1b89      		sub tosl,tosh			; n < base -> C -> TRUE
00345c 0b88      		sbc tosl,tosl
00345d 0b99      		sbc tosh,tosh
00345e 9508      		ret
                 
                 
                 .if optimizingCOMPILER == 1
                 	; bit testing 8 bits (for RAM addresses only)
                 	; ( mask addr -- )   (NO flag on stack - to be used with '0until' and '0if')
                 	MTSTZC_:						; fdw MTSTZ in TOP
00345f e008      			ldi t0,8
003460 d3e1      			rcall IDPMINUS
003461 ff63      			sbrs FLAGS1,f2LIT
003462 c00a      			  rjmp MTSTZC_1LIT
                 	MTSTZC_2LIT:
003463 e008      			ldi t0,8
003464 d3dd      			rcall IDPMINUS			; leaves dpFLASH in X
003465 01cd      			movw TOP,X
003466 9604      			adiw TOP,4
003467 d105      			rcall FETCH_A			; 'ldi tosl,mask'
003468 709f      			cbr tosh,0xf0
003469 6790      			ori tosh,HIGH(0x7000)	; 'andi tosl,mask'
00346a 708f      			cbr tosl,0xf0			; 'andi t0  ,mask'
00346b d01f      			rcall comp_lds_t0
00346c c253      			rjmp ICOMMA_
                 
                 	MTSTZC_1LIT:
00346d d01d      			rcall comp_lds_t0
00346e e880
00346f e293      			ldi16 tos,0x2380		; 'and tosl,t0'
003470 d24f      			rcall ICOMMA_
003471 939a
003472 938a      			pushtos
003473 e98a
003474 ed9e      			ldi16 tos,((DROP<<1) + PFLASH)
003475 c488      			rjmp INLINE0
                 	
                 	; bit testing 8 bits (for RAM addresses only)
                 	; ( mask addr -- f )		
                 
                 	MTSTC_:							; fdw MTST in TOP
003476 e008      			ldi t0,8
003477 d3ca      			rcall IDPMINUS
003478 ff63      			sbrs FLAGS1,f2LIT
003479 c00a      			  rjmp MTSTC_1LIT
                 	MTSTC_2LIT:
00347a d18b      			rcall IHERE
00347b 9704      			sbiw TOP,4
00347c d0f0      			rcall FETCH_A			;   'ldi tosl,<lit1.0>'
00347d 709f      			cbr tosh,0xf0
00347e 6790      			ori tosh,HIGH(0x7000)	;->'andi tosl,<lit1.0>'
00347f e004      			ldi t0,4
003480 d3c1      			rcall IDPMINUS			; "wipe" 'ldi tosl,<lit1.0>    ldi tosh,<lit1.1>'
003481 e8a0      			ldi t4,regtosl			; register 0x18 -> tosl
003482 d009      			rcall comp_lds_t4		; 'in/lds  tosl,<addr>'
                 			;rcall ICOMMA			; 'andi tosl,<lit1.0>'
                 			;rjmp ldi_tosh_0_C_		; 'ldi  tosh,0x00'
003483 c005      			rjmp MTSTC_xxx
                 	
                 	MTSTC_1LIT:
003484 d006      			rcall comp_lds_t0		; 'in/lds t0,<addr>
003485 939a
003486 938a      			pushtos
003487 e880
003488 e293      			ldi16 tos,0x2380		; 'and tosl,t0'
                 	MTSTC_xxx:
003489 d7ef      			rcall ICOMMA
00348a c7df      			rjmp ldi_tosh_0_C_		; 'ldi tosh,0x00'
                 	
                 	comp_lds_t0:
00348b e0a0      			ldi t4,regt0			; register 0x10 -> t0
                 	comp_lds_t4:
00348c 7f61      			cbr FLAGS1,(fLIT<<1)|(f2LIT<<1)
00348d 939a
00348e 938a      			pushtos
00348f 9180 02c7 			lds tosl,litbuf0
003491 b59b      			in  tosh,litbuf1
                 	comp_lds_:
003492 94e8      			clt						; 'read'-flag ('in/lds .... ')
003493 c027      			rjmp comp_xts_
                 			 
                 	MCLRC_:							; fdw MCLR in TOP
003494 ddfe      			rcall optMEM_helper
003495 ff63      			sbrs FLAGS1,f2LIT
003496 c00a      			  rjmp MCLRC_1LIT
                 	MCLRC_2LIT:						; ( addr -- )
003497 d16e      			rcall IHERE
003498 9704      			sbiw TOP,4
003499 d0d3      			rcall FETCH_A			;    ldi tosl,<lit1.0>'
00349a 709f      			cbr tosh,0xf0
00349b 6790      			ori tosh,HIGH(0x7000)	;  'andi tosl,<lit1.0>'
00349c 708f      			cbr tosl,0xf0			;->'andi t0  ,<lit1.0>'
00349d e00f      			ldi t0,0x0f
00349e 2780      			eor tosl,t0
00349f 2790      			eor tosh,t0				; "com <lit1.0>"
0034a0 c014      			rjmp comp_2LIT
                 	
                 	MCLRC_1LIT:
0034a1 939a
0034a2 938a      			pushtos
0034a3 e088
0034a4 e293      			ldi16 tos,0x2308		; 'and t0,tosl'
0034a5 939a
0034a6 938a      			pushtos
0034a7 e880
0034a8 e995      			ldi16 tos,0x9580		; 'com tosl'
0034a9 dfe1      			rcall comp_lds_t0		; 'in/lds t0,<addr>
0034aa d7ce      			rcall ICOMMA
0034ab d00c      			rcall comp_sts			; ICOMMA, 'out/sts <addr>,t0'
0034ac cdfd      			rjmp STOREC_help2		; 'drop'
                 	
                 	MSETC_:							; fdw MSET in TOP
0034ad dde5      			rcall optMEM_helper
                 	MSETC_0: 
0034ae ff63      			sbrs FLAGS1,f2LIT
0034af c021      			  rjmp MSETC_1LIT
                 	MSETC_2LIT:						; ( addr -- )
0034b0 d155      			rcall IHERE
0034b1 9704      			sbiw TOP,4
0034b2 d0ba      			rcall FETCH_A			;   'ldi tosl,<lit1.0>'
0034b3 779f      			cbr tosh,0x80			; ->'ori tosl,<lit1.0>'
0034b4 708f      			cbr tosl,0xf0			; ->'ori t0  ,<lit1.0>'
                 	comp_2LIT:
0034b5 e008      			ldi t0,8
0034b6 d38b      			rcall IDPMINUS			; "wipe" 'lit1'
0034b7 dfd3      			rcall comp_lds_t0		; 'in/lds t0,<addr>
                 	comp_sts:						; compile command ('andi ..' or 'ori ..')
0034b8 d7c0      			rcall ICOMMA
                 	comp_sts_t0:
0034b9 e0a0      			ldi t4,regt0			; register 0x10 -> t0
                 	comp_sts_:
0034ba 9468      			set						; 'write'-flag ('out/sts ... ')
                 	comp_xts_:
0034bb 3680      			cpi tosl,0x60			; check addr range
0034bc 0597      			cpc tosh,r_zero
0034bd f460      			  brcc comp_xts_pure
0034be 3280      			cpi tosl,0x20
0034bf f050      			  brcs comp_xts_pure
                 								; compile 'in/out <t4>,<addr-0x20>'
0034c0 5280      			subi tosl,0x20			; make it an io-addr
0034c1 2f98      			mov tosh,tosl
0034c2 708f      			andi tosl,0x0f
0034c3 7f90      			andi tosh,0xf0
0034c4 9592      			swap tosh
0034c5 0f99      			lsl tosh
0034c6 6b91      			ori tosh,0xb1
0034c7 f993      			bld tosh,3				; insert 'read/write'-flag
0034c8 2b8a      			or tosl,t4
0034c9 c7af      			rjmp ICOMMA
                 
                 	comp_xts_pure:				; compile 'lds/sts <t4>,<addr>'
0034ca 939a
0034cb 938a      			pushtos	
0034cc 2f8a      			mov tosl,t4
0034cd e991      			ldi tosh,HIGH(0x9100)	; R16..R31
0034ce f991      			bld tosh,1				; insert 'read/write'-flag
0034cf d7a9      			rcall ICOMMA
0034d0 c7a8      			rjmp ICOMMA
                 
                 	MSETC_1LIT:
0034d1 939a
0034d2 938a      			pushtos
0034d3 e088
0034d4 e29b      			ldi16 tos,0x2b08		; 'or t0,tosl'
0034d5 dfb5      			rcall comp_lds_t0		; 'lds t0,<addr>
0034d6 dfe1      			rcall comp_sts			; ICOMMA, 'sts <addr>,t0'
0034d7 cdd2      			rjmp STOREC_help2		; 'drop'
                 .endif
                 
                 
0034d8 de72      		fdw		SPACE_L
                 ; SIGN? ( addr n -- addr' n' f )	get optional sign (n<0x100)
                 ;							+ leaves $0000 flag
                 ;							- leaves $0002 flag
                 SIGNQ_L:
0034d9 7385
0034da 6769
0034db 3f6e      		.db		NFA|5,"sign?"
                 ;SIGNQ:
0034dc 81e8      		 ldd ZL,Y+0				; addr
0034dd 81f9      		 ldd ZH,Y+1
0034de 2f08      		 mov t0,tosl			; n
0034df 939a
0034e0 938a      		 pushtos				; OVER c@
                 
                 		 ;call CFETCH_Zplus
0034e1 9181      		 ld tosl,Z+				; in RAM
                 
0034e2 528b      		 subi tosl,'+'
0034e3 f021      		   breq SIGNQIS
0034e4 3082      		 cpi tosl,2				; '-'
0034e5 f011      		   breq SIGNQIS
0034e6 2788      		 clr tosl
                 		 ;ldi tosh,0x00			; (unchanged)
0034e7 9508      		 ret
                 SIGNQIS:
0034e8 83ea      		 std Y+2,ZL				; addr'
0034e9 83fb      		 std Y+3,ZH
0034ea 950a      		 dec t0
0034eb 8308      		 std Y+0,t0				; n'
                 		 ;std Y+1,r_zero		; (unchanged)
                 		 ;ldi tosh,0x00			; (unchanged)
0034ec 9508      		 ret
                 
                 
0034ed e004      		fdw		WITHIN_L
                 UMSLASHMOD_L:
0034ee 7586
0034ef 2f6d
0034f0 6f6d
0034f1 ff64      		.db		NFA|6,"um/mod",0xff
                 UMSLASHMOD:
0034f2 01dc      		movw t5t4,TOP			; divisor
0034f3 9189
0034f4 9199      		poptos					; ( ud.l ud.h			u in t5:t4 )
0034f5 d0e0      		rcall udslashmod0		; (t7:t6:tosh:tosl)		rem in t3:t2
0034f6 921a
0034f7 920a      		push_t3t2				; ( rem ud'.l )
0034f8 9508      		ret
                 
                 
0034f9 e1d8      		fdw		UDOTR_L
                 STARSLASH_L:
0034fa 7583
0034fb 2f2a      		.db		NFA|3,"u*/"
                 STARSLASH: 						; unsigned values only
0034fc 938f      		push tosl				; divisor
0034fd 939f      		push tosh
0034fe 9189
0034ff 9199      		poptos
003500 d584      		rcall umstar0			; product.l in tos, product.h in t7:t6
003501 91bf      		pop t5
003502 91af      		pop t4
003503 939a
003504 938a      		pushtos
003505 01cf      		movw TOP,t7t6
003506 c0cf      		rjmp udslashmod0		; ( ud'.l		ud'.h in t7:t6		rem in t3:t2 )
                 
                 
003507 ebc6      		fdw		UDSLASHMOD_L
                 USSMOD_L:
003508 7586
003509 2f2a
00350a 6f6d
00350b ff64      		.db		NFA|6,"u*/mod",0xff
                 USSMOD:
00350c dfef      		rcall STARSLASH			; remainder returned in t3:t2
00350d 921a
00350e 920a      		push_t3t2
00350f 9508      		ret
                 
                 
003510 f5b4      		fdw		DEFER_L
                 ; CMOVE ( src dst u -- )		copy u bytes from src to dst
                 ;	swap !p>r for c@+ pc! p+ next drop ;
                 CMOVE_L:
003511 6385
003512 6f6d
003513 6576      		.db		NFA|5,"cmove"
                 CMOVE:
003514 934f      		push pl
003515 935f      		push ph
003516 9149      		ld pl,Y+
003517 9159      		ld ph,Y+				; dst to P
003518 01dc      		movw X,TOP				; u to X
003519 9189
00351a 9199      		poptos					; src
00351b c008      		rjmp CMOVE2
                 CMOVE1:
00351c 93af      		  push XL
00351d 93bf      		  push XH
00351e d635      		  rcall CFETCHPP
00351f d7f5      		  rcall PCSTORE
003520 0d46      		  add pl,r_one
003521 1d57      		  adc ph,r_zero
003522 91bf      		  pop XH
003523 91af      		  pop XL
                 CMOVE2:
003524 9711      		  sbiw X,1
003525 f7b0      		brcc CMOVE1
                 
003526 915f      		pop ph
003527 914f      		pop pl
003528 ca24      		rjmp DROP
                 
                 
003529 e114      		fdw		MINUS_L
                 ; , ( x -- )					append cell to current data space
                 ;	HERE ! CELL ALLOT ;
                 COMMA_L:
00352a 2c81      		.db		NFA|1,","
                 COMMA:
00352b d9b4      		rcall HERE
00352c 9602      		adiw TOP,2
00352d 9392      		st -Z,tosh				; Z-pointer valid from HERE
00352e 9382      		st -Z,tosl
00352f 9702      		sbiw TOP,2
003530 c7f3      		rjmp STORE
                 
                 
003531 fa32      		fdw		CFETCH_L 
                 ; c, ( c -- )					append char to current data space
                 ;	HERE C! 1 ALLOT ;
                 CCOMMA_L:
003532 6382
003533 ff2c      		.db		NFA|2,"c,",0xff
                 CCOMMA:
003534 d9ab      		rcall HERE
003535 9601      		adiw TOP,1
003536 9392      		st -Z,tosh				; Z-pointer valid from HERE
003537 9382      		st -Z,tosl
003538 9701      		sbiw TOP,1
003539 c7f9      		rjmp CSTORE
                 
                 
00353a e124      		fdw    NIP_L
                 ; N>C ( nfa -- cfa )			name addr -> code field
                 NTOC_L:
00353b 6e83
00353c 633e      		.db		NFA|3,"n>c"
                 NFATOCFA:
00353d d7dd      		 rcall CFETCH
00353e 708f      		 andi tosl,0x0f
00353f 0fe8      		 add ZL,tosl			; Z valid from CFETCH
003540 1df7      		 adc ZH,r_zero
003541 9631      		 adiw Z,1
003542 7fee      		 cbr ZL,1
003543 01cf      		 movw TOP,Z
003544 9508      		 ret
                 
                 
003545 f6a4      		fdw    CFETCHPP_L
                 ; C>N ( cfa -- nfa )			code field addr -> name field addr
                 ; moded to match 'see': checks for valid length and chars < 0x80
                 CTON_L:
003546 6383
003547 6e3e      		.db		NFA|3,"c>n"
                 CFATONFA:
003548 ef0e      		ldi t0,-2
                 CTN_loop:
003549 d18c      		  rcall MINUS_FETCH
00354a 5f0e      		  subi t0,-2
00354b ff87      		  sbrs tosl,7
00354c f021      			breq CFATONFA_3		; skip  first high byte for len > 1
00354d 379f      		  cpi tosh,0x7f
00354e f458      			brcc CTN_noname
00354f 3290      		  cpi tosh,0x20
003550 f048      		    brcs CTN_noname
                 CFATONFA_3:
003551 378f      		  cpi tosl,0x7f
003552 f039      		    breq CTN_noname
003553 f450      			brcc CTN_hit
                 CFATONFA_2:
003554 3280      		  cpi tosl,0x20
003555 f020      		    brcs CTN_noname
003556 9189
003557 9199      		  poptos
003558 300e      		  cpi t0,14
003559 f779      		brne CTN_loop
                 CTN_noname:
00355a 9622      		adiw Y,2				; NIP address
00355b e087      		ldi tosl,7				; 'r_zero' as length, if no NFA was found
00355c 2799      		clr tosh
00355d 9508      		ret
                 CTN_hit:
00355e 708f      		andi tosl,0x0f			; length
00355f f3d1      		  breq CTN_noname
003560 7f8e      		cbr tosl,1
003561 1780      		cp tosl,t0				; same lenght?
003562 f7b9      		  brne CTN_noname
003563 c9e9      		rjmp DROP
                 
                 
003564 da34      		fdw		RDROP_L
                 ; place ( src n dst -- )		place as counted str
                 PLACE_L:
003565 7085
003566 616c
003567 6563      		.db		NFA|5,"place"
                 PLACE:
003568 d9b6      		rcall TWODUP
                 PLACE_twodupped:
003569 d7c9      		rcall CSTORE
00356a 9601      		adiw TOP,1
00356b d9e8      		rcall SWOP
00356c cfa7      		rjmp CMOVE
                 		 
                 
                 FETCH_A:
00356d c79e      		rjmp FETCH
                 
                 CFETCH_A:
00356e c7ac      		rjmp CFETCH
                 
                 
00356f f66e      		fdw		RX0Q_L
                 ; QUIT ( -- 	R: i*x -- )		interpret from kbd
                 QUIT_L:
003570 7184
003571 6975
003572 ff74      		.db		NFA|4,"quit",0xff
                 QUIT:
003573 01f1      		movw Z,UP
003574 977a      		sbiw Z,(-ur0)
003575 91a1      		ld t4,Z+
003576 91b1      		ld t5,Z+
003577 b70f      		in_ t0,SREG
003578 94f8      		cli
003579 bfad      		out SPL,t4
00357a bfbe      		out SPH,t5
00357b bf0f      		out_ SREG,t0
                 ;	sei
00357c 777f      		cbr FLAGS2,(1<<fSTATE)	; 'INTERPRET'
00357d e004      		ldi t0,4
00357e bd0a      		out cse,t0				; 'RAM'
                 QUIT0:  
00357f de7a      		  rcall   DP_TO_RAM
                 QUIT1: 
                 check_sp:						; check stack pointer position
003580 01f1      			movw Z,UP
003581 977c      			sbiw Z,(-us0)
003582 91a1      			ld t4,Z+			; SP R0 S0 WITHIN
003583 91b1      			ld t5,Z+
003584 17ac      			cp  t4,YL
003585 07bd      			cpc t5,YH
003586 f028      			  brcs SP_error		; s0 < sp -> error
003587 91a1      			ld t4,Z+			; ur0
003588 91b1      			ld t5,Z+
003589 17ac      			cp  t4,YL
00358a 07bd      			cpc t5,YH
00358b f020      			brcs SP_ok
                 SP_error:
00358c d202      			  rcall XSQUOTE
00358d 5303
00358e 3f50      			  .db   3,"SP?"
00358f c039      			  rjmp QABORT_1		; never returns
                 SP_ok:
003590 d0e2      			rcall CR
003591 dc33      			rcall TIB
003592 939a
003593 938a      			duptos
003594 dc25      			rcall TIBSIZE
003595 970a      			sbiw  TOP,10		; reserve 10 bytes for hold buffer
003596 da0e      			rcall ACCEPT
003597 d9a4      			rcall SPACE_
003598 dd20      			rcall INTERPRET
003599 fd77      			sbrc FLAGS2,fSTATE
00359a cfe5      		  rjmp QUIT1
                 
00359b d5e8      		  rcall IFLUSH
00359c de44      		  rcall DP_TO_EEPROM
00359d d1f1      		  rcall XSQUOTE
00359e 2003
00359f 6b6f      		  .db   3," ok"
0035a0 d24c      		  rcall TYPE
0035a1 d006      		  rcall PROMPT_
0035a2 cfdc      		rjmp  QUIT0
                 
                 
0035a3 f1da      		fdw		REPEAT_L
                 PROMPT_L:
0035a4 7086
0035a5 6f72
0035a6 706d
0035a7 ff74      		.db		NFA|6,"prompt",0xff
                 PROMPT_:
0035a8 d53b      		rcall DEFER_DOES
0035a9 090a      		.dw  prompt
                 
                 
0035aa f1ac      		fdw		AGAIN_L
                 ; ABORT ( i*x -- 	R: j*x -- )	clear stack & QUIT
                 ABORT_L:
0035ab 6185
0035ac 6f62
0035ad 7472      		.db		NFA|5,"abort"
                 ABORT:
0035ae 01f1      		movw Z,UP
0035af 977c      		sbiw Z,(-us0)
0035b0 91c1      		ld YL,Z+
0035b1 91d1      		ld YH,Z+
0035b2 cfc0      		rjmp QUIT				; QUIT never rets
                 
                 
0035b3 f52c      		fdw		QNEGATE_L
                 ; ?ABORT ( f -- )				abort & print '?'
                 QABORTQ_L:
0035b4 3f87
0035b5 6261
0035b6 726f
0035b7 3f74      		.db		NFA|7,"?abort?"
                 QABORTQ:
0035b8 9700      		sbiw TOP,0
0035b9 9189
0035ba 9199      		poptos
0035bb f4c9      		  brne QAQ_ret
                 QABORTQ_0:
0035bc d97f      		rcall SPACE_
0035bd e30f      		ldi t0,'?'
0035be d0b5      		rcall EMIT_t0
0035bf cfee      		rjmp ABORT
                 
                 
0035c0 ec1c      		fdw		BRACCHAR_L
                 ; ?ABORT ( f c-addr u -- )		abort & print msg if flag is false
                 QABORT_L:
0035c1 3f86
0035c2 6261
0035c3 726f
0035c4 ff74      		.db		NFA|6,"?abort",0xff
                 QABORT:
0035c5 810a      		ldd t0,Y+2
0035c6 811b      		ldd t1,Y+3
0035c7 2b01      		or t0,t1
0035c8 f419      		  brne QABO1
                 QABORT_1:
0035c9 d972      		rcall SPACE_
0035ca d222      		rcall TYPE
0035cb cfe2      		rjmp ABORT  			; ABORT never returns
                 QABO1:
0035cc c21a      		rjmp DOTS_2				; (drop drop drop)
                 
                 
0035cd df42      		fdw		ACCEPT_L
                 ; ABORT" ( i*x 0  -- i*x   R: j*x -- j*x ) x1=0
                 ;		 ( i*x x1 --       R: j*x --     ) x1<>0
                 ABORTQUOTE_L:
0035ce 61d6
0035cf 6f62
0035d0 7472
0035d1 ff22      		.db		NFA|IMMED|COMPILE|6,"abort",0x22,0xff
                 ABORTQUOTE:
0035d2 da17      		rcall SQUOTE
0035d3 dde0      		rcall DOCOMMAXT
0035d4 eb8a      		fdw  QABORT
                 QAQ_ret:
0035d5 9508      		ret
                 
                 
                 udslashmod0:				; ( 32 / 16 -> 32		rem16: t3t2 )
                 								; ( ud.l ud.h					u: t5t4 )
0035d6 9700      		sbiw TOP,0
0035d7 f031      		  breq udsm0_16
                 udsm0_32:
0035d8 d7f2      		rcall uslashmod0		; ( ud.l q.h	r.h  : t3t2		u: t5t4 )
0035d9 01fc      		movw t7t6,TOP
0035da 9189
0035db 9199      		poptos					; ( ud.l		r.h  : t3t2		u: t5t4		q.h:  t7t6 )
0035dc 9468      		set
                 ;		cp  t2,r_zero			; r.h == 0 ?
                 ;		cpc t3,r_zero			; (speed >< size)
                 ;		brne PC+2
                 ;		  clt
0035dd c7f0      		rjmp udsm0_second		; ( ud'l		rem16: t3t2		u: t5t4		ud'h: t7t6 )   
                 
                 udsm0_16:
0035de 01fc      		movw t7t6,TOP			; = 0 (unchanged in uslashmod0)
0035df 9189
0035e0 9199      		poptos
0035e1 c7e9      		rjmp uslashmod0			; ( ud'l		rem16: t3t2		u: t5t4		ud'h: t7t6(=0) )
                 
                 
0035e2 e9dc      		fdw		UMSLASHMOD_L
                 ; UD/MOD ( ud u -- r ud' )
                 UDSLASHMOD_L:
0035e3 7586
0035e4 2f64
0035e5 6f6d
0035e6 ff64      		.db		NFA|6,"ud/mod",0xff
                 ;UDSLASHMOD:
0035e7 df0a      		rcall UMSLASHMOD		; ( rem ud'.l	ud'h: t7t6 )
0035e8 939a
0035e9 938a      		pushtos					
0035ea 01cf      		movw TOP,t7t6			; ( rem ud'.l ud'.h )
0035eb 9508      		ret
                 
                 
0035ec fc96      		fdw		MAX_L
                 ; LIT ( -- x )					fetch inline 16 bit literal to the stack
                 DOLIT_L:
0035ed 6c83
0035ee 7469      		.db		NFA|3, "lit"
                 DOLIT:
                 		m_pop_zh
0035ef 91ff      		pop ZH
0035f0 91ef      		pop ZL
0035f1 ddb9      		rcall FETCHLIT			; 1 / 12+7
0035f2 95f7      		ror ZH
0035f3 95e7      		ror ZL
0035f4 9409      		mijmp    ; (z)
                 
                 
0035f5 e41c      		fdw		PAREN_L
                 ; ' ( "name" -- xt )			find word in dictionary
                 TICK_L:
0035f6 2781      		.db		NFA|1,0x27		; 27h = '
                 TICK:
0035f7 dc29      		rcall BL_WORD
                 		;rcall WORD
0035f8 dba9      		rcall FIND
0035f9 cfbe      		rjmp QABORTQ
                 
                 
0035fa f364      		fdw		DABS_L
                 ; CHAR ( -- char )				parse ASCII character
                 CHAR_L:
0035fb 6384
0035fc 6168
0035fd ff72      		.db		NFA|4,"char",0xff
                 CHAR:
0035fe dc1d      		rcall BL
0035ff db5b      		rcall PARSE
003600 d94c      		rcall DROP
003601 c719      		rjmp CFETCH
                 
                 
003602 f272      		fdw		LEAVE_L
                 ; IHERE ( -- a-addr )			put code dictionary ptr onto data stack
                 ;   IDP @ ;
                 IHERE_L:
003603 69a5
003604 6568
003605 6572      		.db		NFA|INLINE5|5,"ihere"
                 IHERE:
003606 939a
003607 938a      		 pushtos
                 ;IHERE_0:
003608 9180 02bc
00360a 9190 02bd 		 lds16 tos,dpFLASH		; 6 / 8
00360c 9508      		 ret
                 
                 
00360d eb9c      		fdw		ABORTQUOTE_L
                 ; [CHAR] ( -- )					compile character as literal
                 BRACCHAR_L:
00360e 5bd6
00360f 6863
003610 7261
003611 ff5d      		.db		NFA|IMMED|COMPILE|6,"[char]",0xff
                 BRACCHAR:
003612 dfeb      		rcall CHAR
                 LITERAL_A:
003613 c638      		rjmp LITERAL
                 
                 
                 ; helper for CREATE (CONSTANT_, VARIABLE, MARKER ...)
                 ; creates an empty dictionary entry w/o appending DOCREATE and current dp
                 CREATE0:
003614 dc0c      		rcall BL_WORD
                 		;rcall WORD
003615 db8c      		rcall FIND				; ( c-addr 0 ) if not found -> go on
003616 f069      		  breq CREATE_1			; Z-flag valid from 'FIND'
                 		;adiw Y,2				; (drop address) QABORT will do
003617 2788      		clr tosl
003618 2799      		clr tosh
003619 797f      		cbr FLAGS2,(1<<fINLINE) | (1<<fIMMED)	; clear flags
00361a d174      		rcall XSQUOTE
00361b 410f
00361c 524c
00361d 4145
00361e 5944
00361f 4420
003620 4645
003621 4e49
003622 4445      		.db 15,"ALREADY DEFINED"
003623 dfa1      		rcall QABORT			; ABORT if word has already been defined
                 
                 CREATE_1:						;			  ( c-addr 0 )
003624 81e8      		ldd ZL,Y+0				; CFETCH: we are in TIB -> RAM
003625 81f9      		ldd ZH,Y+1
003626 8180      		ld tosl,Z				;			  ( c-addr len )
003627 2388      		tst tosl
003628 f011      		  breq CREATE_2			; len = 0 -> abort
003629 3180      		cpi tosl,16
00362a f008      		brcs CREATE_3			; len < 16 -> go on
                 CREATE_2:						; len = 0 or len >= 16
00362b df8c      		  rcall QABORTQ			; invalid length -> abort
                 CREATE_3:						; (c-addr true )
00362c 9180 02c2
00362e 9190 02c3 		lds16 tos,dpLATEST		; 			  ( c-addr [latest] )
003630 d648      		rcall ICOMMA			; Link field  ( c-addr )
003631 d522      		rcall CFETCHPP			; str len	  ( addr' len)
003632 da67      		rcall TUCK				; len str len ( len addr' len )
                 								; IHERE LATEST !
003633 91e0 02bc
003635 91f0 02bd 		lds16 Z,dpFLASH			; IHERE
003637 93f0 02c3
003639 93e0 02c2 		sts16 dpLATEST,Z
00363b 9631      		adiw Z,1				; IHERE+1
00363c 93fa
00363d 93ea      		push_Z					;			  ( len addr' ihere+1 len )
                 
00363e 939a
00363f 938a      		duptos					;			  ( len addr' ihere+1 len len )
003640 6880      		ori tosl,NFA
003641 2f07      		mov t0,FLAGS2
003642 7600      		andi t0,(IMMED|INLINE)	; mask out fIMMED and fINLINE
003643 2b80      		or tosl,t0				; ..and set header bits
                 							;			  ( len addr' ihere+1 len NFA[0] )
003644 797f      		cbr FLAGS2,(1<<fINLINE)|(1<<fIMMED)		; clear flags
003645 9731      		sbiw Z,1				; IHERE
003646 94e8      		clt
003647 d6e0      		rcall STORE_Z			; 			  ( len addr' ihere+1 len )
003648 decb      		rcall CMOVE				; 			  ( len )
                 								; align length and increase IDP
003649 9602      		adiw TOP,2
00364a 7f8e      		cbr tosl,1				;			  ( len' )
                 ;		rjmp IALLOT				; the header has now been created
                 IALLOT:
00364b 27ee      		clr ZL
00364c c0dc      		rjmp ALLOT_0
                 
                 
00364d e894      		fdw		DIGITQ_L
                 ; CREATE ( "name" -- )			create an empty definition
                 ; create a definition header and append DOCREATE and the current data space dictionary pointer
                 ; examples :
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
                 CREATE_L:
00364e 6386
00364f 6572
003650 7461
003651 ff65      		.db		NFA|6,"create",0xff
                 CREATE:
003652 dfc1      		rcall CREATE0
003653 939a
003654 938a      		pushtos
003655 ea89      		ldi tosl, LOW(DOCREATE)	; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
003656 e393      		ldi tosh,HIGH(DOCREATE)
003657 d8ad      		rcall STORECFF2			; append an exeution token (call !)
003658 d887      		rcall HERE				; compile the current dataspace dp into the dictionary
003659 b50a      		in t0,cse
00365a 2300      		tst t0
00365b f409      		brne PC+2
00365c 9602      		  adiw TOP,2			; in FLASH
00365d c61b      		rjmp ICOMMA				; dp now points to a free cell
                 
                 
00365e dd2c      		fdw    VARIABLE_L
                 ; POSTPONE
                 POSTPONE_L:
00365f 70d8
003660 736f
003661 7074
003662 6e6f
003663 ff65      		.db		NFA|IMMED|COMPILE|8,"postpone",0xff
                 ;POSTPONE:
003664 dbbc      		rcall BL_WORD
003665 db3c      		rcall FIND				; leaves valid Z-flag
003666 f409      		brne PC+2
003667 df50      		  rcall QABORTQ			; never returns
003668 2399      		tst tosh
003669 9189
00366a 9199      		poptos
00366b f41a      		  brpl POSTPONE_immediate
                 POSTPONE_normal:				; -1
00366c dd47      		rcall DOCOMMAXT
00366d e768      		fdw DOCOMMAXT
00366e c051      		rjmp ICOMMA_
                 
                 POSTPONE_immediate:				;  1
00366f c87c      		rjmp COMMAXT
                 
                 
003670 f382      		fdw		DPLUS_L
                 ; CR ( -- )						output newline
                 CR_L:
003671 6382
003672 ff72      		.db		NFA|2,"cr",0xff
                 CR:
003673 e00d      		ldi t0,0x0d
                 	  .if CR_with_LF == 1
                 	  .endif
                 EMIT_t0:
003674 939a
003675 938a      		pushtos
003676 2f80      		mov tosl,t0
003677 c7f2      		rjmp EMIT
                 
                 KEY_A:
003678 c7fb      		rjmp KEY
                 
                 
                 ; (DOES>) ( -- )				run-time action of DOES>
003679 2887
00367a 6f64
00367b 7365
00367c 293e      		.db		NFA|7,"(does>)"	; just for 'see' to work
                 XDOES:
00367d 939a
00367e 938a      		pushtos
                 XDOES_pushed:
00367f 9180 02c2
003681 9190 02c3 		lds16 tos,dpLATEST		; LATEST_ @
003683 deb9      		rcall NFATOCFA			; 'call DOCREATE'
003684 9602      		adiw TOP,2				; point to address
003685 01fc      		movw Z,TOP
003686 919f      		pop tosh				; get caller return address
003687 918f      		pop tosl
003688 9468      		set
003689 c69e      		rjmp STORE_Z
                 
                 
00368a f710      		fdw		EMPTY_L
                 ; DOES> ( -- )					declare run-time action
                 DOES_L:
00368b 64d5
00368c 656f
00368d 3e73      		.db		NFA|IMMED|COMPILE|5,"does>"
                 ;DOES:
00368e dd25      		rcall DOCOMMAXT
00368f ecfa      		fdw  XDOES
003690 dd23      		rcall DOCOMMAXT
003691 f554      		fdw  DODOES
003692 9508      		ret
                 
                 
003693 e0a4      		fdw		STORE_P_L
                 ; ] ( -- )						enter compiling state
                 RIGHTBRACKET_L:
003694 5da1      		.db		NFA|INLINE|1,"]"
                 RIGHTBRACKET:
003695 6870      		sbr FLAGS2,(1<<fSTATE)
003696 9508      		ret
                 
                 
003697 ed46      		fdw		SEMICOLON_L
                 ; : ( -- )						begin a colon definition
                 COLON_L:
003698 3a81      		.db		NFA|1,":"
                 COLON:
003699 6870      		 sbr FLAGS2,(1<<fSTATE)	; RIGHTBRACKET
00369a cf79      		 rjmp CREATE0
                 
                 
00369b e39a      		fdw		TONUMBER_L
                 ; :noname ( -- a )				define headerless forth code
                 NONAME_L:
00369c 3a87
00369d 6f6e
00369e 616e
00369f 656d      		.db		NFA|7,":noname"
                 NONAME:
0036a0 df65      		rcall IHERE
0036a1 cff3      		rjmp RIGHTBRACKET
                 
                 
0036a2 e04c      		fdw		LESS_L
                 ; ; ( -- )						end a colon definition
                 SEMICOLON_L:
0036a3 3bd1      		.db		NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
0036a4 777f      		cbr FLAGS2,(1<<fSTATE)	; LEFTBRAKET
                 SEMICOLON_0:
0036a5 fd61      		sbrc FLAGS1,fTAILC
0036a6 c015      		  rjmp ADD_RETURN_1
0036a7 df5e      		rcall IHERE
0036a8 d02d      		rcall MINUS_FETCH
0036a9 018c      		movw t1t0,TOP
0036aa 7f10      		andi t1,0xf0
0036ab 5d10      		subi t1,0xd0
0036ac f041      		  breq RCALL_TO_RJMP
0036ad 9189
0036ae 9199      		poptos
0036af d026      		rcall MINUS_FETCH
0036b0 3994      		cpi tosh,0x94
                 .ifdef EIND
                 .else
0036b1 408e      			sbci tosl,0x0e
                 .endif
0036b2 f439      		brne ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
                 .else
0036b3 e08c      			ldi tosl,0x0c
                 .endif
0036b4 c001      		rjmp SWOP_STORE
                 
                 RCALL_TO_RJMP:
0036b5 7e9f      		cbr tosh,0x10			; 0xd... (rcall) -> 0xc... (rjmp)
                 SWOP_STORE:
0036b6 91e9
0036b7 91f9      		pop_Z
                 SWOP_STORE_Z:
0036b8 9468      		set
0036b9 c66e      		rjmp STORE_Z
                 
                 ADD_RETURN:
0036ba 9622      		adiw Y,2				; 2drop
0036bb c002      		rjmp ADD_RETURN_2
                 ADD_RETURN_1:
0036bc 939a
0036bd 938a      		pushtos
                 ADD_RETURN_2:
0036be e088      		ldi tosl, LOW(0x9508)	; compile a 'ret'
0036bf e995      		ldi tosh,HIGH(0x9508)
                 ICOMMA_:
0036c0 c5b8      		rjmp ICOMMA
                 
                 .if optimizingCOMPILER == 1
                 	; recompile 'lit' ('pushtos  ldi16 tos,<lit>')
                 	;..to 			  ('ldi16 <t1>,<lit>')
                 
                 	ldi16_t1t0_C_:
0036c1 e010      			ldi t1,regt1t0			; -> t1:t0
                 	ldi16_thtl_C_:
0036c2 e008      			ldi t0,8
                 	ldi16_thtl_C_DUP_:
0036c3 d17e      			rcall IDPMINUS			; replace 'LIT' by
0036c4 5002      			subi t0,2
                 	ldi16_thtl_C_0:
0036c5 df40      			rcall IHERE
0036c6 0f80      			add tosl,t0
0036c7 1d97      			adc tosh,r_zero
0036c8 d643      			rcall FETCH				;  'ldi tosh,<lit.1>'
0036c9 718f      			andi tosl,0x1f
0036ca 2b81      			or tosl,t1				; -> 'ldi th,<lit.1>'
0036cb 939a
0036cc 938a      			pushtos
0036cd 9734      			sbiw Z,4				; valid addr in Z returned by 'FETCH'
0036ce d63e      			rcall FETCH_Zplus		;  'ldi tosl,<lit.0>'
0036cf 718f      			andi tosl,0x1f
0036d0 2b81      			or tosl,t1				; -> 'ldi tl,<lit.0>
0036d1 d5a7      			rcall ICOMMA			; ..'ldi tl,..'
0036d2 c5a6      			rjmp ICOMMA				; ..'ldi th,..'
                 .endif	
                 
                 
0036d3 d784      		fdw		DOTQUOTE_L
                 MINUS_FETCH_L:
0036d4 2d82
0036d5 ff40      		.db		NFA|2,"-@",0xff
                 MINUS_FETCH:
0036d6 9702      		sbiw TOP,2
0036d7 939a
0036d8 938a      		duptos
0036d9 c632      		rjmp FETCH
                 
                 
0036da d89e      		fdw		SWOPMINUS_L
                 ; STATE ( -- f )				put compiler state onto data stack
                 STATE_L:
0036db 73a5
0036dc 6174
0036dd 6574      		.db		NFA|INLINE5|5,"state"
                 STATE_:
0036de 939a
0036df 938a      		pushtos
                 STATE_0:
0036e0 01c3      		movw TOP,r_one
0036e1 ff77      		sbrs FLAGS2,fSTATE
0036e2 2788      		  clr tosl				; 5 / 7
0036e3 9508      		ret
                 
                 
0036e4 e836      		fdw		LSHIFT_L
                 ; LATEST ( -- a-addr )
                 LATEST_L:
0036e5 6ca6
0036e6 7461
0036e7 7365
0036e8 ff74      		.db		NFA|INLINE4|6,"latest",0xff
                 LATEST_:
0036e9 939a
0036ea 938a      		 pushtos
                 LATEST_0:
0036eb ec82
0036ec e092      		 ldi16 tos,dpLATEST		; 4 / 6	
0036ed 9508      		 ret
                 
                 
0036ee f5e6      		fdw		TO_L
                 ; S0 ( -- a-addr )				start of parameter stack
                 S0_L:
0036ef 73a2
0036f0 ff30      		.db		NFA|INLINE4|2,"s0",0xff
                 S0:
0036f1 939a
0036f2 938a
0036f3 01c1
0036f4 974c      		inline_DOUSER us0		; 4 / 7
0036f5 9508      		ret
                 
                 
0036f6 deee      		fdw		RFROM_L
                 ; R0 ( -- a-addr )				start of parameter stack
                 R0_L:
0036f7 72a2
0036f8 ff30      		.db		NFA|INLINE4|2,"r0",0xff
                 R0_:
0036f9 939a
0036fa 938a
0036fb 01c1
0036fc 974a      		inline_DOUSER ur0		; 4 / 7
0036fd 9508      		ret
                 
                 
0036fe fb54      		fdw		USLASHMOD_L
                 ; ticks ( -- u )				system ticks (0-ffff) in milliseconds
                 TICKS_L:
0036ff 74a5
003700 6369
003701 736b      		.db		NFA|INLINE|5,"ticks"
                 TICKS:  
003702 939a
003703 938a      		pushtos
                 TICKS_0:
003704 01c7      		movw TOP,MS_COUNT		; 3 / 5
003705 9508      		ret
                 
                 
003706 ea10      		fdw		USSMOD_L
                 ; ticks= ( u -- t )				leave time in ms from u to actual ms_count
                 TICKSCOMPUTE_L:
003707 74a6
003708 6369
003709 736b
00370a ff3d      		.db		NFA|INLINE4|6,"ticks=",0xff
                 TICKSCOMPUTE:
00370b 018c      		movw t1t0,TOP
00370c 01c7      		movw TOP,MS_COUNT
00370d 1b80      		sub tosl,t0
00370e 0b91      		sbc tosh,t1				; 4 / 4
00370f 9508      		ret
                 
                 	
003710 f5ee      		fdw		TURNKEY_L
                 ; ticks>n  ( x -- u x )			push system ticks to NEXT
                 TICKStoNEXT_L:
003711 74a7
003712 6369
003713 736b
003714 6e3e      		.db		NFA|INLINE|7,"ticks>n"
                 TICKStoNEXT:
003715 0187      		movw t1t0,MS_COUNT
003716 931a
003717 930a      		push_t1t0				; 3 / 5
003718 9508      		ret
                 
                 
003719 0000      		.dw		0
                 ; us ( u -- )					pause for u microseconds
                 ;	begin 1- dup while waste9 waste2 repeat drop ;
                 ; for ATmega328/p with 16 MHz
                 MICROS_L:
00371a 7582
00371b ff73      		.db		NFA|2,"us",0xff
                 MICROS:							; CPU ticks
00371c 9701      		  sbiw TOP,1			; 2(2)
00371d f019      			breq MICROS_xxx		; 1(2)
00371e daf8      		  rcall waste9			; 9				(2-)
00371f 9602      		  adiw TOP,2			; 2 
003720 cffb      		rjmp MICROS				; 2______________16 ticks (= 1 us) per loop
                 MICROS_xxx:
003721 9189
003722 9199      		poptos					;  (4)
003723 9508      		ret						;(4+4) call/ret__16 ticks for entry+exit
                 
                 
003724 f16a      		fdw		BEGIN_L
                 ALLOT_L:
003725 6185
003726 6c6c
003727 746f      		.db		NFA|5,"allot"
                 ALLOT:
003728 b5ea      		 in ZL,cse
                 ALLOT_0:
003729 27ff      		 clr ZH
00372a 54e4      		 subi ZL, LOW(-dpFLASH)
00372b 4ffd      		 sbci ZH,HIGH(-dpFLASH)	; DP
00372c 9101      		 ld t0,Z+
00372d 9111      		 ld t1,Z+				; 	@
00372e 0f80      		 add tosl,t0
00372f 1f91      		 adc tosh,t1			;		+
                 ALLOT_1:
003730 9392      		 st -Z,tosh
003731 9382      		 st -Z,tosl				;		  !
003732 c81a      		 rjmp DROP
                 
                 		
003733 f85c      		fdw		IRQ_SEMI_L
                 ; 2@ ( a-addr -- x1 x2 )		fetch 2 cells
                 ;	DUP @ SWAP CELL+ @ ;
                 TWOFETCH_L:
003734 3282
003735 ff40      		.db		NFA|2,"2@",0xff
                 TWOFETCH:
                 ;		rcall FETCHPP
                 ;		rcall SWOP
                 ;		rjmp  FETCH
003736 d5d5      	rcall FETCH
003737 939a
003738 938a      	pushtos
003739 c5d3      	rjmp FETCH_Zplus
                 
                 
00373a dfc0      		fdw		SPFETCH_L
                 ; SHB ( bitmask -- )			set header bit
                 SHB_L:
00373b 7383
00373c 6268      		.db		NFA|3,"shb"
                 SHB:
00373d 2f18      		 mov t1,tosl			; save mask
                 SHB0:
00373e 91e0 02c2
003740 91f0 02c3 		 lds16 Z,dpLATEST
003742 d5d9      		 rcall CFETCH_Zplus
003743 9731      		 sbiw Z,1
003744 2b81      		 or tosl,t1
003745 94e8      		 clt					; 'write char'-flag
003746 c5e1      		 rjmp STORE_Z			; store tosl to (Z)
                 
                 
003747 e568      		fdw		INTERPRET_L
                 IMMEDIATE_L:
003748 6989
003749 6d6d
00374a 6465
00374b 6169
00374c 6574      		.db		NFA|9,"immediate" ; 
                 IMMEDIATE:
00374d e410      		 ldi t1,IMMED
                 pre_SHB:
00374e 939a
00374f 938a      		 pushtos
003750 cfed      		 rjmp SHB0
                 
                 
003751 f890      		fdw		LITERAL_L
                 INLINED_L:
003752 6987
003753 6c6e
003754 6e69
003755 6465      		.db		NFA|7,"inlined" ; 
                 INLINED:
003756 e210      		 ldi t1,INLINE
003757 cff6      		 rjmp pre_SHB
                 
                 
003758 e77a      		fdw		DOTSTATUS_L
                 ;  .id ( nfa -- ) 
                 DOTID_L:
003759 2e83
00375a 6469      		.db		NFA|3,".id"
                 DOTID:
00375b d3f8      		rcall CFETCHPP
00375c 708f      		andi tosl,NFAmask
00375d c08f      		rjmp TYPE
                 
                 
00375e d91a      		fdw		TWOSTAR_L
                 ; 2! ( x1 x2 a-addr -- )		store 2 cells
                 ;	SWAP OVER ! CELL+ ! ;
                 TWOSTORE_L:
00375f 3282
003760 ff21      		.db		NFA|2,"2!",0xff
                 TWOSTORE:
003761 d938      		rcall TUCK
003762 9602      		adiw TOP,2
003763 d5c0      		rcall STORE
003764 c5bf      		rjmp STORE
                 
                 
003765 e370      		fdw 	TIBSIZE_L
                 ; SQR  ( u -- u^2 )				16-bit square
                 ; valid results for u < 256 only
                 SQUARE_L:
003766 73a3
003767 7271      		.db		NFA|INLINE|3,"sqr"
                 ;SQUARE:
003768 9f88      		mul tosl,tosl
003769 01c0      		movw TOP,R1:R0			; 2 / 3
00376a 9508      		ret
                 
                 
00376b dea2      		fdw		SWOP_L
                 ; SQRT  ( u -- u' )				16-bit square root
                 ; no rounding, no remainder on stack
                 SQUAREROOT_L:
00376c 7384
00376d 7271
00376e ff74      		.db		NFA|4,"sqrt",0xff
                 ;SQUAREROOT:
00376f 018c      		movw t1t0,TOP
003770 2788      		clr tosl
003771 e890      		ldi tosh,0x80
                 SQRT_loop:
003772 2789      		  eor tosl,tosh
003773 9f88      		  mul tosl,tosl
003774 1500      		  cp  t0,R0
003775 0511      		  cpc t1,R1
003776 f408      		  brcc PC+2
003777 2789      			eor tosl,tosh
003778 9596      		lsr tosh
003779 f7c1      		brne SQRT_loop
                 
00377a 9508      		ret
                 
                 
00377b df24      		fdw		PLUS_L
                 ; 								16 x 16 bit to 16 bit multiply
                 STAR_L:
00377c 2aa1      		.db		NFA|INLINE5|1,"*"
                 STAR: 
00377d 9109
00377e 9119      		pop_t1t0
                 STAR_0:
00377f 01fc      		movw t7t6,TOP
003780 9f0e      		mul t0,t6
003781 01c0      		movw TOP,R1:R0
003782 9f1e      		mul t1,t6
003783 0d90      		add tosh,R0
003784 9f0f      		mul t0,t7
003785 0d90      		add tosh,R0				;  9 / 14
003786 9508      		ret						;  7 / 10 for  'LIT *'
                 
                 .if optimizingCOMPILER == 1
                 	cSTAR_0:						; inline code for 'cLIT *'
003787 01fc      			 movw t7t6,TOP
003788 9f0e      			 mul t0,t6
003789 01c0      			 movw TOP,R1:R0
00378a 9f0f      			 mul t0,t7
00378b 0d90      			 add tosh,R0			;  5 / 7
00378c 9508      			 ret
                 .endif
                 
                 
                 ; (S" ( -- c-addr u )			run-time code for S"
00378d 2883
00378e 2273      		.db      NFA|3,"(s",0x22	; just for 'see' to work
                 XSQUOTE:				; #### do NOT change distance to 'STAR:' for 'see' to work ####
                 		m_pop_zh
00378f 91ff      		pop ZH
003790 91ef      		pop ZL
003791 0fee      		lsl ZL
003792 1fff      		rol ZH
003793 9105      		lpm_ t0,Z+
003794 939a
003795 938a      		pushtos
003796 01cf      		movw TOP,Z
003797 5890      		add_pflash_tos
003798 939a
003799 938a      		pushtos
00379a 2f80      		mov tosl,t0
00379b 0fe0      		add ZL,t0
00379c 1df7      		adc ZH,r_zero
00379d 9631      		adiw Z,1
                 		;rampv_to_c
                 		;ror zh
00379e 95f6      		lsr ZH
00379f 95e7      		ror ZL
0037a0 9409      		mijmp
                 
                 
0037a1 f184      		fdw		ZEROUNTIL_L
                 ; WORDS   ( "filter" -- ) 		list words beginning with 'filter'
                 WORDS_L:
0037a2 7785
0037a3 726f
0037a4 7364      		.db		NFA|5,"words"
                 WORDS:
0037a5 decd      		rcall CR
0037a6 da7a      		rcall BL_WORD				; c-addr, valid Z-flag
0037a7 f409      		brne PC+2
0037a8 6078      		  sbr FLAGS2,(1<<fWORDSall)	; list all words
0037a9 939a
0037aa 938a      		pushtos
0037ab e486
0037ac ef9a      		ldi16 tos,((kernellink_short<<1)+PFLASH); (c-addr NFA)
0037ad d00d      		rcall WORDS_dict
0037ae e48c
0037af ee94      		ldi16 tos,((kernellink_mid<<1)+PFLASH)	; (c-addr NFA)
0037b0 d00a      		rcall WORDS_dict
0037b1 ed86
0037b2 ed9a      		ldi16 tos,((kernellink_long<<1)+PFLASH)	; (c-addr NFA)
0037b3 d007      		rcall WORDS_dict
0037b4 9180 02c2
0037b6 9190 02c3 		lds16 tos,dpLATEST			; (c-addr NFA)
0037b8 d002      		rcall WORDS_dict
                 
0037b9 7f77      		cbr FLAGS2,(1<<fWORDSall)
0037ba c14a      		rjmp TWODROP_A
                 
                 WORDS_dict:
0037bb fd73      		sbrc FLAGS2,fWORDSall
0037bc c00f      		  rjmp WORDS_match
0037bd 01fc      		movw Z,TOP				; NFA
0037be 58f0      		sub_pflash_z
0037bf 81a8      		ldd XL,Y+0				; c-addr
0037c0 81b9      		ldd XH,Y+1
0037c1 910d      		ld  t0,X+				; check length
0037c2 9115      		lpm t1,Z+
0037c3 701f      		andi t1,0x0f
0037c4 1710      		cp t1,t0
0037c5 f050      		  brcs WORDS_next		; <string> longer than dict entry
                 WORDS_loop:
0037c6 900d      		  ld t2,X+
0037c7 9015      		  lpm t3,Z+
0037c8 1401      		  cp t2,t3
0037c9 f431      			brne WORDS_next		; char mismatch
0037ca 950a      		dec t0
0037cb f7d1      		brne WORDS_loop
                 
                 WORDS_match:					; type name
0037cc 939a
0037cd 938a      		duptos					; (c-addr NFA NFA)
0037ce df8c      		rcall DOTID
0037cf d941      		rcall SPACE_A
                 
                 WORDS_next:
0037d0 9702      		sbiw TOP,2				; (c-addr LFA)
0037d1 d53a      		rcall FETCH				; (c-addr NFA')
0037d2 9700      		sbiw TOP,0
0037d3 f739      		  brne WORDS_dict
                 								; end of dict
0037d4 ce9e      		rjmp CR
                 
                 
                 ; .S ( -- )						print stack contents
                 ;	space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
0037d5 d9c8      		fdw		ZEROLESS_L
                 DOTS_L:
0037d6 2e82
0037d7 ff73      		.db		NFA|2,".s",0xff
                 DOTS:
0037d8 d938      		rcall SPACE_A
0037d9 939a
0037da 938a      		pushtos
0037db d806      		rcall SPFETCH
0037dc df14      		rcall S0
0037dd d52e      		rcall FETCH
0037de 9702      		sbiw TOP,2
                 DOTS_1:
0037df 8108      		  ldd t0,Y+0
0037e0 8119      		  ldd t1,Y+1
0037e1 1708      		  cp t0,tosl
0037e2 0719      		  cpc t1,tosh
0037e3 f418      			brcc DOTS_2
0037e4 def1      		  rcall MINUS_FETCH
0037e5 d922      		  rcall UDOT
0037e6 cff8      		rjmp DOTS_1
                 DOTS_2:
0037e7 9624      		adiw Y,4
0037e8 c544      		rjmp DROP_A
                 
                 
0037e9 d888      		fdw		 UMAX_L
                 ; TYPE ( c-addr u -- )			type line to terminal u < $100
                 ;	for c@+ emit next drop ;
                 TYPE_L:
0037ea 7484
0037eb 7079
0037ec ff65      		.db		NFA|4,"type",0xff
                 TYPE:
0037ed 2e88      		mov t8,tosl
0037ee 9189
0037ef 9199      		poptos
0037f0 2088      		tst t8
0037f1 f021      		  breq TYPE_2
                 TYPE_loop:
0037f2 d361      		  rcall CFETCHPP
0037f3 d676      		  rcall EMIT
0037f4 948a      		dec t8
0037f5 f7e1      		brne TYPE_loop
                 TYPE_2:
0037f6 c536      		rjmp DROP_A
                 
                 
0037f7 f132      		fdw		ELSE_L
                 ; DUMP ( addr u -- )			display memory
                 DUMP_L:
0037f8 6484
0037f9 6d75
0037fa ff70      		.db		NFA|4,"dump",0xff
                 DUMP:
0037fb e004      		ldi t0,4
                 dump_0:
0037fc 9596      		  lsr tosh
0037fd 9587      		  ror tosl
0037fe 950a      		dec t0
0037ff f7e1      		brne dump_0
                 
003800 01f1      		movw Z,UP
003801 9772      		sbiw Z,(-ubase)
003802 81a0      		ld t4,Z
003803 31a0      		cpi t4,16
003804 f408      		brcc PC+2
003805 6078      		  sbr FLAGS2,(1<<fDUMPxxx)	; dump 3-digit numbers for base<16
003806 01dc      		movw X,TOP				; save line count
003807 9189
003808 9199      		poptos
                 DUMP_loop:  
003809 93af      		  push XL
00380a 93bf      		  push XH
00380b de67      		  rcall CR
00380c 939a
00380d 938a      		  duptos
00380e 939a
00380f 938a      		  pushtos
003810 2799      		  clr tosh
003811 e084      		  ldi tosl,4
003812 fd73      		  sbrc FLAGS2,fDUMPxxx
003813 9583      			inc tosl
003814 d8d9      		  rcall UDOTR			; type line address
                 
003815 e0af      		  ldi XL,15				; byte loop count	(hex dump)
                   DUMP2:
003816 93af      			push XL				; type 16 byte values
003817 d33c      			rcall CFETCHPP
003818 939a
003819 938a      			pushtos
00381a 2799      			clr tosh
00381b e082      			ldi tosl,2
00381c fd73      			sbrc FLAGS2,fDUMPxxx
00381d 9583      			  inc tosl
00381e d8cf      			rcall UDOTR
00381f 91af      			pop XL				; byte loop count
003820 50a1      		  subi XL,1
003821 f7a0      		  brcc DUMP2
                   
003822 9740      		  sbiw TOP,16
003823 e100      		  ldi t0,16
003824 2e80      		  mov t8,t0				; byte loop count	(ASCII dump)
                   DUMP4:
003825 d32e      			rcall CFETCHPP		; type 16 ASCII char
003826 d85c      			rcall TO_PRINTABLE
003827 d642      			rcall EMIT
003828 948a      		  dec t8
003829 f7d9      		  brne DUMP4
                   	
00382a 91bf      		  pop XH
00382b 91af      		  pop XL
00382c 9711      		sbiw X,1
00382d f6d8      		brcc DUMP_loop
                 
00382e 7f77      		cbr FLAGS2,(1<<fDUMPxxx)
                 		;rjmp DROP
00382f e08d      		ldi tosl,0x0d			; CR
003830 c639      		rjmp EMIT
                 
                 
                 ; ,?0= ( -- addr )				compile '?0=' and make place for a branch instruction
003831 2c84
003832 303f
003833 ff3d      		.db		NFA|4, ",?0=",0xff    ; just for 'see' to work
                 COMMAZEROSENSE:
003834 939a
003835 938a      		pushtos
003836 fd65      		sbrc FLAGS1,idup
003837 c003      		  rjmp COMMAZEROSENSE1
003838 ef88
003839 ee90      		ldi16 tos,((ZEROSENSE<<1)+PFLASH)
00383a c0c3      		rjmp INLINE0
                 
                 COMMAZEROSENSE1:				; DUPZEROSENSE
00383b e004      		ldi t0,4
00383c d005      		rcall IDPMINUS
00383d e080
00383e e997      		ldi16 tos,0x9700		; 'sbiw TOP,0'		
00383f 7d6f      		cbr FLAGS1,(1<<idup)
003840 c438      		rjmp ICOMMA
                 
                 IDP6MINUS:
003841 e006      		ldi t0,6
                 IDPMINUS:
003842 ebec
003843 e0f2      		ldi16 Z,dpFLASH
003844 91a1      		ld XL,Z+
003845 91b1      		ld XH,Z+
003846 1ba0      		sub XL,t0
003847 09b7      		sbc XH,r_zero
003848 93b2      		st -Z,XH
003849 93a2      		st -Z,XL
00384a 9508      		ret
                 		 
                 
                 BRNEC:
00384b 939a
00384c 938a
00384d e089
00384e ef94      		inline_DOLIT 0xf409 	; brne PC+2
00384f fd64      		sbrc FLAGS1,izeroeq
003850 7f9b      		  andi tosh, ~4			; breq PC+2
003851 c427      		rjmp ICOMMA
                 
                 
003852 f5ce      		fdw		IS_L
                 ; IF ( -- adrs )				conditional forward branch
                 ; leaves address of branch instruction and compiles the condition byte
                 IF_L:
003853 69d2
003854 ff66      		.db		NFA|IMMED|COMPILE|2,"if",0xff
                 IF_:
003855 d007      		rcall IF_createBranch
                 IF_1:
003856 7e6a      		cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)|(1<<iLITeq)
                 
                 IHERE_ZERO_RJMPC:
003857 ddae      		rcall IHERE
003858 939a
003859 938a
00385a e080
00385b ec90      		inline_DOLIT 0xc000		; 'rjmp 0' as dummy
00385c c41c      		rjmp ICOMMA
                 
                 IF_createBranch:
00385d fd60      		sbrc FLAGS1,icarryeq
00385e c01f      		  rjmp carryIF_
00385f fd65      		sbrc FLAGS1,idup
003860 ff62      		sbrs FLAGS1,iLITeq
003861 c018      		  rjmp IF_zeroeq
                 
                 IF_dupLITeq:					; (idup && iLITeq)
003862 939a
003863 938a
003864 e089
003865 ef90      		inline_DOLIT 0xf009		; 'breq PC+2'
003866 dd9f      		rcall IHERE
003867 970a      		sbiw TOP,10
003868 d4a3      		rcall FETCH				; 'subi tosl,lit.0' (leaves valid adr+2 in Z)
003869 709f      		andi tosh,0x0f
00386a 6390      		ori tosh,0x30			; -> 'cpi tosl,lit.0'
00386b 939a
00386c 938a
00386d e181
00386e ef94      		inline_DOLIT 0xf411		; 'brne PC+3'
00386f 939a
003870 938a      		pushtos
003871 d49b      		rcall FETCH_Zplus		; 'sbci tosh,lit.1'
003872 709f      		andi tosh,0x0f
003873 6390      		ori tosh,0x30			; -> 'cpi tosh,lit.1'
003874 e00e      		ldi t0,14
003875 dfcc      		rcall IDPMINUS
003876 d402      		rcall ICOMMA
003877 d401      		rcall ICOMMA
003878 d400      		rcall ICOMMA
003879 c3ff      		rjmp ICOMMA
                 
                 IF_zeroeq:
00387a fd64      		sbrc FLAGS1,izeroeq
00387b dfc5      		  rcall IDP6MINUS
00387c dfb7      		rcall COMMAZEROSENSE
00387d cfcd      		rjmp BRNEC
                 
                 carryIF_:
00387e ff65      		sbrs FLAGS1,idup
00387f c007      		  rjmp carryIF_noDUP
                 carryIF_DUP:					; for ULESS, UGREATER and GREATER only
003880 939a
003881 938a
003882 e088
003883 ef90      		inline_DOLIT 0xf008		; 'brcs PC+2'
003884 e004      		ldi t0,4				; skip 'drop'
003885 dfbc      		rcall IDPMINUS
003886 c3f2      		rjmp ICOMMA
                 
                 carryIF_noDUP:
003887 e004      		ldi t0,4
003888 dfb9      		rcall IDPMINUS
003889 939a
00388a 938a      		pushtos
00388b e18c
00388c ef91      		ldi16 tos,((BRCS_seq<<1)+PFLASH)	; 'brcs PC+2'
00388d c070      		rjmp INLINE0
                 
                 BRCS_seq:
00388e 9189
00388f 9199      		poptos
003890 f008      		brcs PC+2
003891 9508      		ret
                 
                 
003892 dd58      		fdw		EIGHTLSHIFT_L
                 ; 0if   ( -- adrs )				foreward branch on Z-flag - NO stack action
                 ZEROIF_L:
003893 30d3
003894 6669      		.db		NFA|IMMED|COMPILE|3,"0if"
                 ZEROIF:
003895 6160      		sbr FLAGS1,(1<<izeroeq)
003896 dfb4      		rcall BRNEC
003897 cfbf      		rjmp IHERE_ZERO_RJMPC
                 
                 	
003898 fcce      		fdw		EMIT_L
                 ; ELSE ( adrs1 -- adrs2 )		branch for IF..ELSE
                 ; leave adrs2 of bra instruction and store breq in adrs1
                 ; leave adress of branch instruction and FALSE flag on stack
                 ELSE_L:
003899 65d4
00389a 736c
00389b ff65      		.db		NFA|IMMED|COMPILE|4,"else",0xff
                 ELSE_:
00389c dfba      		rcall IHERE_ZERO_RJMPC
00389d d9f4      		rcall SWOP_A			; else-addr  if-addr 
00389e c004      		rjmp THEN_
                 
                 
00389f e824      		fdw		TRUE_L
                 ; THEN ( adrs  -- )				resolve forward branch
                 THEN_L:
0038a0 74d4
0038a1 6568
0038a2 ff6e      		.db		NFA|IMMED|COMPILE|4,"then",0xff
                 THEN_:
0038a3 ef0e      		ldi t0,0xfe				; -2
0038a4 ef1f      		ldi t1,0xff
                 THEN_0:
0038a5 01fc      		movw Z,TOP				; write forward branch at 'if', 'else','do' or 'for'
0038a6 9180 02bc
0038a8 9190 02bd 		lds16 tos,dpFLASH
0038aa 1b8e      		sub tosl,ZL
0038ab 0b9f      		sbc tosh,ZH
0038ac 0f80      		add tosl,t0
0038ad 1f91      		adc tosh,t1
0038ae 9595      		asr tosh
0038af 9587      		ror tosl
0038b0 709f      		andi tosh,0x0f
                 		;ori tosl, LOW(0xc000)
0038b1 6c90      		ori tosh,HIGH(0xc000)
0038b2 6062      		sbr FLAGS1,(1<<fTAILC)	; prevent tail jump  optimization
0038b3 ce04      		rjmp SWOP_STORE_Z		; write TOP at Z
                 
                 
0038b4 d7c4      		fdw		CELLPLUS_L
                 ; BEGIN ( -- adrs )				target for backward branch
                 BEGIN_L:
0038b5 62d5
0038b6 6765
0038b7 6e69      		.db		NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
0038b8 cd4d      		rjmp IHERE
                 
                 
0038b9 f5a2      		fdw		VALUE_L
                 ; UNTIL ( adrs -- )				branch backwards if true
                 UNTIL_L:
0038ba 75d5
0038bb 746e
0038bc 6c69      		.db		NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
0038bd 6062      		sbr FLAGS1,(1<<fTAILC)	; prevent tail jump  optimization
0038be df9e      		rcall IF_createBranch
0038bf 7e6a      		cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)|(1<<iLITeq)
0038c0 c018      		rjmp AGAIN_
                 
                 
0038c1 fafc      		fdw		SCALE_L
                 ; 0until   ( adrs -- )      backward branch on Z-flag - NO stack action
                 ; ########## small loops ONLY ##########
                 ZEROUNTIL_L:
0038c2 30d6
0038c3 6e75
0038c4 6974
0038c5 ff6c      		.db		NFA|IMMED|COMPILE|6,"0until",0xff
                 ZEROUNTIL:
0038c6 2da6      		 mov t4,r_one			; b001 for Z-flag
                 		 ;rjmp UNTILflag
                 		 						; branch on cpu-flag - NO stack action
                 UNTILflag:
0038c7 6062      		 sbr FLAGS1,(1<<fTAILC)	; prevent tail jump  optimization
0038c8 9100 02bc 		 lds t0,dpFLASH			; IHERE
                 		 ;lds t1,dpFLASH+1		; not needed ...
0038ca 1b80      		 sub tosl,t0
                 		 ;sbc tosh,t1			; not needed ...
                 		 ;sbiw TOP,2
0038cb 5082      		 subi tosl,2
0038cc 7f8e      		 andi tosl, LOW(0x00fe)
0038cd 7090      		 andi tosh,HIGH(0x00fe)	; distance in bytes (already shifted left by 1)
0038ce 0f88
0038cf 1f99      		 lsl tosl	rol tosh
0038d0 0f88
0038d1 1f99      		 lsl tosl	rol tosh	; distance in words (shifted left by 3) to be inserted into 'br..'-command
0038d2 2b8a      		 or tosl,t4				; which flag
0038d3 6f94      		 ori tosh,HIGH(0xf400)	; branch on cleared
0038d4 c3a4      		 rjmp ICOMMA
                 
                 
0038d5 df32      		fdw		ALIGN_L
                 ; AGAIN ( adrs -- )				uncondional backward branch
                 AGAIN_L:
0038d6 61d5
0038d7 6167
0038d8 6e69      		.db		NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
0038d9 6062      		sbr FLAGS1,(1<<fTAILC)	; prevent tail jump optimization
0038da 9100 02bc 		lds t0,dpFLASH
0038dc 9110 02bd 		lds t1,dpFLASH+1
0038de 1b80      		sub tosl,t0
0038df 0b91      		sbc tosh,t1
0038e0 9702      		sbiw TOP,2
                 ;		rjmp RJMPC
                 
                 ; rjmp, ( rel-addr -- )
                 RJMPC:
0038e1 9595      		asr tosh
0038e2 9587      		ror tosl
0038e3 709f      		andi tosh,0x0f
                 		;ori tosl, LOW(0xc000)	; 'rjmp ...'
0038e4 6c90      		ori  tosh,HIGH(0xc000)
0038e5 c393      		rjmp ICOMMA
                 
                 
0038e6 ef44      		fdw		WORDS_L
                 ; WHILE ( addr1 -- addr2 addr1 )	branch for WHILE loop
                 ; addr1: address of BEGIN
                 ; addr2: address where to store breq instruction
                 WHILE_L:
0038e7 77d5
0038e8 6968
0038e9 656c      		.db		NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
0038ea df6a      		rcall IF_
0038eb c9a6      		rjmp SWOP_A
                 
                 
0038ec e850      		fdw		RSHIFT_L
                 ; REPEAT ( addr2 addr1 -- )		resolve WHILE loop
                 REPEAT_L:
0038ed 72d6
0038ee 7065
0038ef 6165
0038f0 ff74      		.db		NFA|IMMED|COMPILE|6,"repeat",0xff
                 REPEAT_:
0038f1 dfe7      		rcall AGAIN_
0038f2 cfb0      		rjmp THEN_
                 
                 
0038f3 d8e0      		fdw		INVERT_L
                 INLINE_L:
0038f4 69d6
0038f5 6c6e
0038f6 6e69
0038f7 ff65      		.db      NFA|IMMED|COMPILE|6,"inline",0xff
                 ;INLINE
0038f8 7c6e      		cbr FLAGS1,(1<<izeroeq)|(1<<idup)|(1<<icarryeq)
0038f9 dcfd      		rcall TICK
0038fa c003      		rjmp INLINE0
                 
                 
0038fb fce4      		fdw		KEY_L
                 ; in, ( addr -- )
                 ;	begin @+ dup $9508 <> while i, repeat 2drop ;
                 INLINEC_L:
0038fc 6983
0038fd 2c6e      		.db      NFA|3,"in,"
                 INLINE0:
0038fe d25c      		  rcall FETCHPP
0038ff e915      		  ldi t1, HIGH(0x9508)	; 'ret'
003900 3088      		  cpi tosl,LOW(0x9508)
003901 0791      		  cpc tosh,t1
003902 f011      			breq INLINE1
003903 d375      		  rcall ICOMMA
003904 cff9      		rjmp INLINE0
                 TWODROP_A:
                 INLINE1:
003905 9622      		adiw Y,2
003906 c426      		rjmp DROP_A
                 
                 
003907 fb74      		fdw		GCD_L
                 ; FOR  ( -- bc-addr bra-addr )
                 FOR_L:
003908 66d3
003909 726f      		.db		NFA|IMMED|COMPILE|3,"for"
                 FOR:
00390a 939a
00390b 938a
00390c e386
00390d ef92      		inline_DOLIT ((XFOR<<1)+PFLASH)
                 
                 	.if optimizingCOMPILER == 1
00390e ff67      			sbrs FLAGS1,fLIT
00390f c004      			  rjmp FOR_0
                 		FORC_:
003910 7767      			cbr FLAGS1,(1<<fLIT)|(1<<f2LIT)
003911 ea10      			ldi t1,regX
003912 ddaf      			rcall ldi16_thtl_C_		; -> 'load literal to X'
003913 9606      			adiw TOP,6				; -> 'XFOR1'
                 		FOR_0:
                 	.endif
                 
003914 dfe9      		rcall INLINE0
003915 dcf0      		rcall IHERE
003916 9704      		sbiw TOP,4				; skip backwards 'push XL	push XH'
003917 939a
003918 938a      		duptos					; bc-addr
003919 9702      		sbiw TOP,2				; bra-addr
00391a 9508      		ret
                 
                 XFOR:
00391b 01dc      		movw X,TOP
00391c 9189
00391d 9199      		poptos
                 XFOR1:
00391e c000      		rjmp PC+1				; dummy address
00391f 93af      		push XL
003920 93bf      		push XH
003921 9508      		ret
                 
                 
003922 dda6      		fdw		DP_L
                 ; do (limit index --  R: -- limit index )
                 DO_L:
003923 64d2
003924 ff6f      		.db		NFA|IMMED|COMPILE|2,"do",0xff
                 DO:
003925 939a
003926 938a
003927 e58a
003928 ef92      		inline_DOLIT ((XDO<<1)+PFLASH)
003929 dfd4      		rcall INLINE0
00392a dcdb      		rcall IHERE
00392b 9708      		sbiw TOP,8				; adjust to '_LOOP:'
00392c 9508      		ret
                 
                 XDO:
00392d 01dc      		movw t5t4,TOP			; index
00392e 9189
00392f 9199      		poptos
003930 018c      		movw t1t0,TOP			; limit
003931 9189
003932 9199      		poptos
                 ;_LOOP:
003933 930f      		push t0					; limit
003934 931f      		push t1
003935 93af      		push t4					; index
003936 93bf      		push t5
003937 9508      		ret
                 
                 .if CPU_LOAD_LED == 0
                 .elif CPU_LOAD_LED == 1
003938 f4aa      		fdw		LOADON_L
                 .else .error "illegal value: CPU_LOAD_LED"
                 .endif
                 ; leave ( --  R: limit index -- )	  #### one LEAVE per word ONLY!!! ####
                 LEAVE_L:							; #### do not open a loop after LEAVE !!! ####
003939 6cd5
00393a 6165
00393b 6576      		.db		NFA|IMMED|COMPILE|5,"leave"
                 LEAVE:
00393c 939a
00393d 938a
00393e e984
00393f ef92      		inline_DOLIT ((XLEAVE<<1)+PFLASH)
003940 dfbd      		rcall INLINE0
003941 9af3      		sbi FLAGS3,fLEAVE
003942 ebea
003943 e0f2      		ldi16 Z,RAMvarBase
003944 81a2      		ldd t4,Z+_dpFLASH
003945 81b3      		ldd t5,Z+_dpFLASH+1
003946 9712      		sbiw t5t4,2
003947 87b7      		std Z+_LEAVEadr+1,t5
003948 87a6      		std Z+_LEAVEadr  ,t4
003949 9508      		ret
                 
                 XLEAVE:
00394a 910f      		pop t0
00394b 910f      		pop t0
00394c 910f      		pop t0
00394d 910f      		pop t0
00394e c000      		rjmp PC+1				; dummy to be replaced by 'LOOP'
00394f 9508      		ret
                 
                 
003950 db42      		fdw		MCLR_L
                 ; loop ( --  R: limit index -- limit index+1 )
                 ;      (     R: limit index --  )
                 LOOP_L:
003951 6cd4
003952 6f6f
003953 ff70      		.db		NFA|IMMED|COMPILE|4,"loop",0xff
                 LOOP:
003954 939a
003955 938a
003956 ec8c
003957 ef92      		inline_DOLIT ((XLOOP<<1)+PFLASH)
003958 dfa5      		rcall INLINE0
003959 9bf3      		sbis FLAGS3,fLEAVE
00395a cf7e      		  rjmp AGAIN_			; write backward branch to '_LOOP'
                 LOOP_LEAVE:
00395b 98f3      		cbi FLAGS3,fLEAVE
00395c 939a
00395d 938a      		pushtos
00395e 9180 02c8 		lds tosl,LEAVEadr
003960 9190 02c9 		lds tosh,LEAVEadr+1
003962 e000      		ldi t0,0				; 0
003963 e010      		ldi t1,0
003964 df40      		rcall THEN_0			; write forward branch at LEAVE
003965 cf73      		rjmp AGAIN_				; write backward branch to '_LOOP'
                 
                 XLOOP:
003966 91bf      		pop t5					; index
003967 91af      		pop t4
003968 911f      		pop t1					; limit
003969 910f      		pop t0
00396a 9611      		adiw t5t4,1
00396b 170a      		cp  t0,t4
00396c 071b      		cpc t1,t5
00396d f008      		  brcs PC+2
00396e 9508      		ret
                 
00396f f2f2      		fdw		outerINDEX_L
                 ; i	( -- index  R: limit index -- limit index )
                 innerINDEX_L:
003970 69a1      		.db		NFA|0x20|1,"i"
                 innerINDEX:			; ++++ must be inlined ++++
003971 939a
003972 938a      		pushtos
003973 b7ed      		in ZL,SPL
003974 b7fe      		in ZH,SPH
003975 8182      		ldd tosl,Z+2			; index
003976 8191      		ldd tosh,Z+1			; 6 / 10
003977 9508      		ret
                 
                 
003978 d77c      		fdw		LEFTBRACKET_L
                 ; j ( -- index'  R: limit' index' limit index -- limit' index' limit index )
                 outerINDEX_L:
003979 6aa1      		.db		NFA|0x20|1,"j"
                 outerINDEX:			; ++++ must be inlined ++++
00397a 939a
00397b 938a      		pushtos
00397c b7ed      		in ZL,SPL
00397d b7fe      		in ZH,SPH
00397e 8186      		ldd tosl,Z+6			; index'
00397f 8195      		ldd tosh,Z+5			; 6 / 10
003980 9508      		ret
                 
                 
003981 decc      		fdw		OVER_L
                 ; NEXT ( bc-addr bra-addr -- )
                 NEXT_L:
003982 6ed4
003983 7865
003984 ff74      		.db		NFA|IMMED|COMPILE|4,"next",0xff
                 NEXT:
003985 e002      		ldi t0,2				; +2
003986 e010      		ldi t1,0
003987 df1d      		rcall THEN_0			; write forward branch at 'for'
003988 939a
003989 938a
00398a e28a
00398b ef93      		inline_DOLIT ((XNEXT<<1)+PFLASH)
00398c df71      		rcall INLINE0
00398d 9100 02bc 		lds t0,dpFLASH
00398f 9110 02bd 		lds t1,dpFLASH+1
003991 1b80      		sub tosl,t0
003992 0b91      		sbc tosh,t1
003993 9702      		sbiw TOP,2
003994 cf4c      		rjmp RJMPC
                 
                 
                 ; (next) decrement top of return stack
                 ;		.db		NFA|0x20|6,"(next)",0xff
                 XNEXT:
003995 91bf      		pop XH
003996 91af      		pop XL
003997 9711      		sbiw X,1
003998 f008      		brcs PC+2
003999 9508      		ret
                 
                 
00399a fcfa      		fdw		EXECUTE_L
                 DNEGATE_L:
00399b 6487
00399c 656e
00399d 6167
00399e 6574      		.db		NFA|7,"dnegate"
                 DNEGATE:
00399f 9109
0039a0 9119      		 pop_t1t0				; d.l in t1:t0
                 DNEGATE_0:
0039a1 1906      		sub t0,r_one
0039a2 0917      		sbc t1,r_zero
0039a3 0987      		sbc tosl,r_zero
0039a4 0997      		sbc tosh,r_zero
0039a5 c042      		rjmp DINVERT_0
                 
                 
0039a6 e252      		fdw		CONSTANT_L
                 QDNEGATE_L:
0039a7 3f88
0039a8 6e64
0039a9 6765
0039aa 7461
0039ab ff65      		.db		NFA|8,"?dnegate",0xff
                 QDNEGATE:
0039ac 0f99      		lsl tosh				; mov sign to C-flag
0039ad 9189
0039ae 9199      		poptos
0039af f378      		  brcs DNEGATE
0039b0 9508      		ret
                 
                 
0039b1 de94      		fdw		DROP_L
                 DABS_L:
0039b2 6484
0039b3 6261
0039b4 ff73      		.db		NFA|4,"dabs",0xff
                 DABS:
0039b5 fd97      		sbrc tosh,7
0039b6 cfe8      		  rjmp DNEGATE
0039b7 9508      		ret
                 
                 
0039b8 d992      		fdw		MFETCH_L
                 ; m+  ( d n -- d1 )
                 MPLUS_L:
0039b9 6d82
0039ba ff2b      		.db		NFA|2, "m+",0xff
                 ;MPLUS:
0039bb 018c      		 movw t1t0,TOP			; n		(d2.l)
0039bc 0f99      		 lsl tosh				; s>d	(d2.h)
0039bd 0b88      		 sbc tosl,tosl
0039be 0b99      		 sbc tosh,tosh
0039bf c005      		 rjmp DPLUS_0
                 
                 
0039c0 f3a2      		fdw		DMINUS_L
                 DPLUS_L:
0039c1 6482
0039c2 ff2b      		.db		NFA|2,"d+",0xff
                 DPLUS:
0039c3 9109
0039c4 9119      		pop_t1t0				; d2.l
                 DPLUS_0:
0039c5 91e9
0039c6 91f9      		pop_t7t6				; d1.h
0039c7 91a9
0039c8 91b9      		pop_t5t4				; d1.l
0039c9 0f0a      		add t0,t4
0039ca 1f1b      		adc t1,t5
0039cb 1f8e      		adc tosl,t6
0039cc 1f9f      		adc tosh,t7
0039cd 931a
0039ce 930a      		push_t1t0
0039cf 9508      		ret
                 
                 
0039d0 e240      		fdw		DDOT_L
                 DMINUS_L:
0039d1 6482
0039d2 ff2d      		.db		NFA|2,"d-",0xff
                 DMINUS:
0039d3 9109
0039d4 9119      		 pop_t1t0				; d2.l
                 DMINUS_0:
0039d5 01fc      		 movw t7t6,TOP			; d2.h
0039d6 9189
0039d7 9199      		 poptos					; d1.h
0039d8 91a9
0039d9 91b9      		 pop_t5t4				; d1.l
0039da 1ba0      		 sub t4,t0
0039db 0bb1      		 sbc t5,t1
0039dc 0b8e      		 sbc tosl,t6
0039dd 0b9f      		 sbc tosh,t7
0039de 93ba
0039df 93aa      		 push_t5t4				; Z-flag valid
0039e0 9508      		 ret					; 13 / 21+4
                 
                 
0039e1 f336      		fdw		DNEGATE_L
                 DINVERT_L:
0039e2 64a7
0039e3 6e69
0039e4 6576
0039e5 7472      		.db		NFA|INLINE5|7,"dinvert"
                 DINVERT:
0039e6 9109
0039e7 9119      		pop_t1t0
                 DINVERT_0:
0039e8 9500      		com t0
0039e9 9510      		com t1
0039ea 9580      		com tosl
0039eb 9590      		com tosh
0039ec 931a
0039ed 930a      		push_t1t0				; 8 / 12
0039ee 9508      		ret
                 
                 
0039ef d956      		fdw		DTWOSTAR_L
                 DZEROEQUAL_L:
0039f0 64a3
0039f1 3d30      		.db		NFA|INLINE5|3,"d0="
                 DZEROEQUAL:
0039f2 9109
0039f3 9119      		pop_t1t0
                 DZEROEQUAL_0:
0039f4 2b89      		or tosl,tosh
0039f5 2b80      		or tosl,t0
0039f6 2b81      		or tosl,t1
0039f7 9701      		sbiw TOP,1				; TOP == 0 -> C-flag
0039f8 0b88      		sbc tosl,tosl
0039f9 0b99      		sbc tosh,tosh			; 8 / 11
0039fa 9508      		ret
                 
                 
0039fb f41a      		fdw		DGREATER_L
                 DEQUAL_L:
0039fc 6482
0039fd ff3d      		.db		NFA|2,"d=",0xff
0039fe dfd4      		rcall DMINUS			; d1 d2 -
0039ff 9701      		sbiw TOP,1
003a00 c007      		rjmp putFlag
                 
                 
003a01 f3f8      		fdw		DEQUAL_L
                 DLESS_L:
003a02 6482
003a03 ff3c      		.db		NFA|2,"d<",0xff
                 DLESS:
003a04 dfce      		rcall DMINUS			; d1 d2 -
003a05 f40b      		brvc PC+2
                 DG_2:
003a06 9590      		  com tosh
                 DG_1:
003a07 0f99      		lsl tosh
                 putFlag:
003a08 0b88      		sbc tosl,tosl
003a09 0b99      		sbc tosh,tosh
003a0a 9622      		adiw Y,2				; NIP d'.l (from DMINUS)
003a0b 9508      		ret
                 
                 
003a0c d812      		fdw		DI_L
                 DGREATER_L:
003a0d 6482
003a0e ff3e      		.db		NFA|2,"d>",0xff
                 DGREATER:
003a0f dfc3      		rcall DMINUS
003a10 f3b9      		  breq putFlag			; d1 == d2 -> C=0 -> put FALSE
003a11 f3ab      		brvs DG_1
003a12 f79b      		brvc DG_2
                 
                 
                 
                 .if FLASHEND > 0x3fff
                   .ifdef RAMPZ
                   .endif
                   .ifdef RAMPZ
                   .endif
                 .endif
                 
                 
003a13 0000      		.dw     0
                 ; FORGET ( "name" -- ) 
                 ;  bl word latest @ (f) ?abort?
                 ;  c>n 2- dup @ ?abort?
                 ;  dup flash dp ! @ latest ! ram
                 FORGET_L:
003a14 6686
003a15 726f
003a16 6567
003a17 ff74      		.db		NFA|6,"forget",0xff
                 FORGET:
003a18 d808      		rcall BL_WORD
003a19 dccf      		rcall LATEST_
003a1a d2f1      		rcall FETCH
003a1b d80c      		rcall findi
003a1c db9b      		rcall QABORTQ
003a1d db2a      		rcall CFATONFA
003a1e 9702      		sbiw TOP,2				; LFA
003a1f 939a
003a20 938a      		duptos
003a21 d2ea      		rcall FETCH
003a22 db95      		rcall QABORTQ
003a23 9390 02bd
003a25 9380 02bc 		sts16 dpFLASH,tos		; dup idp !
003a27 d2e4      		rcall FETCH
003a28 dcc0      		rcall LATEST_
003a29 c2fa      		rjmp STORE
                 
                 
003a2a f428      		fdw		FORGET_L
                 ; marker ( "name" -- )
                 MARKER_L:
                 lastword:
003a2b 6d86
003a2c 7261
003a2d 656b
003a2e ff72      		.db		NFA|6,"marker",0xff
                 MARKER:
003a2f bc7a      		out cse,r_zero			; 'flash'
003a30 dc21      		rcall CREATE
003a31 dbbd      		rcall DOLIT 
003a32 0900      		.dw dp_start
003a33 dbd2      		rcall IHERE
003a34 d00e      		rcall TEN_CMOVE
003a35 dbd0      		rcall IHERE
003a36 960a      		adiw TOP,10
003a37 9390 02bd
003a39 9380 02bc 		sts16 dpFLASH,tos
003a3b e004      		ldi t0,4
003a3c bd0a      		out cse,t0				; 'ram'
003a3d dc41      		rcall XDOES_pushed
003a3e d06b      		rcall DODOES
                 ;		rcall INI
                 ; ini ( -- a-addr )				ini variable contains the user-start xt
                 ; In RAM
003a3f 939a
003a40 938a      INI:	pushtos
003a41 eb8a
003a42 e092      		ldi16 tos,dpSTART
                 
                 TEN_CMOVE:
003a43 dbab      		rcall DOLIT
003a44 000a      		.dw 10
003a45 cace      		rjmp CMOVE
                 
                 
003a46 dede      		fdw		TOR_L
                 TO_A_L:
003a47 3ea2
003a48 ff61      		.db		NFA|INLINE|2, ">a",0xff
                 TO_A:
003a49 015c      		movw A,TOP
003a4a 9189
003a4b 9199      		poptos					; 3 / 5
003a4c 9508      		ret
                 
                 
003a4d e434      		fdw		BL_L
                 A_FROM_L:
003a4e 61a2
003a4f ff3e      		.db		NFA|INLINE|2, "a>",0xff
                 A_FROM:
003a50 939a
003a51 938a      		pushtos
                 A_FROM_0:
003a52 01c5      		movw TOP,A				; 3 / 5
003a53 9508      		ret
                 
                 
                 .if CPU_LOAD_LED == 1
                 	;;; Enable load-LED
003a54 f4b6      			fdw		LOADOFF_L
                 	LOADON_L:
003a55 6ca5
003a56 616f
003a57 2b64      			.db		NFA|INLINE|5,"load+"
003a58 6071      			sbr FLAGS2,(1<<fLOADled)
003a59 9508      			ret
                 
                 	;;; Disable load-LED
003a5a db5e      			fdw		MTSTZ_L
                 	LOADOFF_L:
003a5b 6ca5
003a5c 616f
003a5d 2d64      			.db		NFA|INLINE|5,"load-"
003a5e 7f7e      			cbr FLAGS2,(1<<fLOADled)
                 			.if CPU_LOAD_LED_POLARITY == 1
003a5f 982d      				cbi_ CPU_LOAD_PORT,CPU_LOAD_BIT
                 			.elif CPU_LOAD_LED_POLARITY == 0
                 			.else .error "illegal value: CPU_LOAD_LED_POLARITY"
                 			.endif
003a60 9508      			ret
                 .endif
                  
                 .if CPU_LOAD == 1
003a61 f2a2      			fdw		LOOP_L
                 	LOAD_L:
003a62 6ca4
003a63 616f
003a64 ff64      			.db		NFA|INLINE|4,"load",0xff
003a65 939a
003a66 938a      			pushtos
003a67 9180 02c6 			lds tosl,load_res
003a69 2799      		 	clr tosh
003a6a 9508      			ret
                 .endif
                 
                 .ifdef UCSR1A
                   .if U1FC_TYPE == 1
                   .elif U1FC_TYPE == 2
                   .else .error "illegal value: U1FC_TYPE"
                   .endif
                   .if OPERATOR_UART == 1
                     .if CTRL_O_WARM_RESET == 1
                     .endif
                   .endif
                   .if U1FC_TYPE == 1
                   .elif U1FC_TYPE == 2
                   .else .error "illegal value: U1FC_TYPE"
                   .endif
                 .endif
                 
                 
                 .if IDLE_MODE == 1
                   IDLE_LOAD:
                 ;			sbrs FLAGS2,fIDLE			; (moved to PAUSE)
                 ;			  rjmp IDLE_LOAD1			; 'busy' -> leave
003a6b ee06      			ldi t0,LOW(up0)
003a6c 1620      			cp upL,t0
003a6d f4b1      			  brne IDLE_LOAD1			; not in 'operator' task -> leave
003a6e b70f      			in_ t0,SREG
003a6f 94f8      			cli
003a70 9000 02b8 			lds t2,rbuf0_lv				; in OPERATOR task -> check rbuf0_lv/rbuf1_lv
003a72 9010 02b9 			lds t3,rbuf0_lv+1
003a74 2801      			or t2,t3
003a75 bf0f      			out_ SREG,t0
                 ;	sei
                     	  .ifdef rbuf1_lv
                     	  .endif
003a76 f469      			brne IDLE_LOAD1				; rbuf0/rbuf1 not empty -> leave
                 
                 		  .if CPU_LOAD_LED == 1
003a77 fd70      			sbrc FLAGS2,fLOADled
                     		  .if CPU_LOAD_LED_POLARITY == 1	; LED off
003a78 982d      				cbi_ CPU_LOAD_PORT,CPU_LOAD_BIT
                     		  .else
                     		  .endif
                 		  .endif
                 
                 		  .ifdef SMCR					; buffers empty -> enable sleep mode
003a79 be63      			out_ SMCR,r_one
                 		  .else
                 		  .endif
                 
                 		  .if CPU_LOAD == 1
003a7a 9270 0081        		out_ TCCR1B,r_zero    		; stop load-counter (restarted by any int)
                 		  .endif
                 
                 		  .if OPERATOR_UART == 0		; #### must be placed right before 'sleep' ####
003a7c eb08      			ldi t0,(1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)|(1<<UDRIE0)
003a7d fd72      			sbrc FLAGS2,fTX0pending		; if a char for TX0 is pending
003a7e 9300 00c1 			  out_ UCSR0B,t0			; .. enable UDRE0-interrupt (disabled by UDRE_ISR)
                 		  .endif
003a80 9588      			sleep		       			; enter sleep mode 'IDLE'
                 
                 		  .ifdef SMCR					; disable sleep mode
003a81 be73      			out_ SMCR,r_zero
                 		  .else
                 		  .endif
                 
                 		  .if CPU_LOAD_LED == 1
003a82 fd70      			sbrc FLAGS2,fLOADled		; LED on
                     		  .if CPU_LOAD_LED_POLARITY == 1
003a83 9a2d      				sbi_ CPU_LOAD_PORT,CPU_LOAD_BIT
                     		  .else
                     		  .endif
                 		  .endif
                 
                   IDLE_LOAD1:
003a84 9508      			ret
                 .endif
                 
                 
                 ; unsigned 16/16 -> 32 multiply
                 umstar0:						; product.l in tos, product.h in t7:t6
003a85 9109
003a86 9119      		 pop_t1t0
                 umstar0_0:
003a87 9f80      		 mul tosl,t0
003a88 01d0      		 movw t5t4,R1:R0
003a89 9f91      		 mul tosh, t1
003a8a 01f0      		 movw t7t6,R1:R0
003a8b 9f90      		 mul tosh, t0
003a8c 0db0      		 add t5,R0
003a8d 1de1      		 adc t6,R1
003a8e 1df7      		 adc t7,r_zero
003a8f 9f81      		 mul tosl, t1
003a90 0db0      		 add t5,R0
003a91 1de1      		 adc t6,R1
003a92 1df7      		 adc t7,r_zero
003a93 01cd      		 movw TOP,t5t4
003a94 9508      		 ret					; 16 / 21+4
                 
                 
003a95 d7b4      		fdw		ALIGNED_L
                 QNEGATE_L:
003a96 3f87
003a97 656e
003a98 6167
003a99 6574      		.db		NFA|7,"?negate"
                 ;QNEGATE:
003a9a 0f99      		lsl tosh				; copy sign into C-flag
003a9b 9189
003a9c 9199      		poptos
003a9d f030      		  brcs NEGATE
003a9e 9508      		ret
                 
                 
003a9f eb48      		fdw		PROMPT_L
                 NEGATE_L:
003aa0 6ea6
003aa1 6765
003aa2 7461
003aa3 ff65      		.db		NFA|INLINE|6, "negate",0xff
                 NEGATE:
003aa4 9580      		com tosl
003aa5 9590      		com tosh
003aa6 9601      		adiw TOP,1				; 3 / 4
003aa7 9508      		ret
                 
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
003aa8 2883
003aa9 2964      		.db		NFA|3,"(d)"		; just for 'see' to work
                 DODOES:
                 		m_pop_xh
003aaa 91bf      		pop XH
003aab 91af      		pop XL
                 		m_pop_zh
003aac 91ff      		pop ZH
003aad 91ef      		pop ZL
003aae d8fc      		rcall FETCHLIT
003aaf 01fd      		movw Z,X
003ab0 9409      		mijmp					; 7 / 30
                 
                 
                 ; rx0 complete interrupt
                 RX0_ISR:
003ab1 9100 00c6 		in_ t0,UDR0_
                 
                 	.if (OPERATOR_UART == 0) && (CTRL_O_WARM_RESET == 1)
003ab3 300f      			cpi t0,0xf
003ab4 f409      			brne PC+2
003ab5 c44a      			  rjmp RESET_
                 	.endif
003ab6 ebe4      		 ldi ZL, LOW(rx0queue)
003ab7 e0f2      		 ldi ZH,HIGH(rx0queue)
003ab8 81a4      		 ldd XL,Z+_lv0
003ab9 81b5      		 ldd XH,Z+_lv1
003aba 30b1      		 cpi XH,HIGH(RX0_BUF_SIZE)	; (buf size is a multiple of 0x100)
003abb f460      		   brcc RX0_OVF
003abc 9611      		 adiw X,1
003abd 83b5      		 std Z+_lv1,XH
003abe 83a4      		 std Z+_lv0,XL
                 
                 	.if U0FC_TYPE > 0
                 	  .if U0FC_TYPE == 1
                 	  .elif U0FC_TYPE == 2
                 	  .endif
                 	.endif
                 
003abf 81a0      		 ldd XL,Z+_wr0
003ac0 81b1      		 ldd XH,Z+_wr1
003ac1 930d      		 st X+,t0
003ac2 30b2      		 cpi XH,HIGH(rbuf0 + RX0_BUF_SIZE)	; (buf size is a multiple of 0x100)
003ac3 f008      		 brcs PC+2
003ac4 e0b1      		   ldi XH,HIGH(rbuf0)	;clr XL		; wrap around pointer (rbuf0 on page boundary!!)
                 ;RX0_ISR_0:
003ac5 83b1      		 std Z+_wr1,XH
003ac6 83a0      		 std Z+_wr0,XL
003ac7 c403      		 rjmp OF_ISR_EXIT
                 
                 RX0_OVF:
003ac8 e7fc      		 ldi ZH,'|'
003ac9 d043      		 rcall TX0_SEND
003aca c400      		 rjmp OF_ISR_EXIT
                 
                 
                 	.ifdef UCSR1A
                 	.endif
                 
                 
003acb df12      		fdw		ABS_L
                 ; ['] ( "name" -- )				find word & compile as DOLITeral
                 BRACTICK_L:
003acc 5bd3
003acd 5d27      		.db		NFA|IMMED|COMPILE|3,"[']"
                 ;BRACTICK:
003ace db28      		rcall TICK				; get xt of 'xxx'
003acf c17c      		rjmp LITERAL
                 
                 
003ad0 f1ce      		fdw		WHILE_L
                 VALUE_L:
003ad1 7685
003ad2 6c61
003ad3 6575      		.db		NFA|5,"value"
                 VALUE:
003ad4 db7d      		rcall CREATE
003ad5 da55      		rcall COMMA
003ad6 dba6      		rcall XDOES
                 VALUE_DOES:
003ad7 dfd2      		rcall DODOES
003ad8 c233      		rjmp FETCH
                 
                 
003ad9 e184      		fdw		TODIGIT_L
                 DEFER_L:
003ada 6485
003adb 6665
003adc 7265      		.db		NFA|5,"defer"
                 DEFER:
003add db74      		rcall CREATE
003ade 939a
003adf 938a
003ae0 e58c
003ae1 ee9b      		inline_DOLIT ((ABORT<<1)+PFLASH)
003ae2 da48      		rcall COMMA
003ae3 db99      		rcall XDOES
                 DEFER_DOES:
003ae4 dfc5      		rcall DODOES
003ae5 c3a5      		rjmp FEXECUTE
                 
                 
003ae6 f372      		fdw		MPLUS_L
                 IS_L:
003ae7 69c2
003ae8 ff73      		.db		NFA|IMMED|2,"is",0xff
                 IS:
003ae9 db0d      		rcall TICK				; -> fdw TURNKEY
003aea 9604      		adiw TOP,4				; '.dw dpSTART'
003aeb d220      		rcall FETCH
003aec ff77      		sbrs FLAGS2,fSTATE
003aed c236      		  rjmp STORE
003aee d15d      		rcall LITERAL
003aef d8c4      		rcall DOCOMMAXT
003af0 fa48      		fdw STORE
003af1 9508      		ret
                 
                 
003af2 e20c      		fdw		UDOT_L
                 TO_L:
003af3 74c2
003af4 ff6f      		.db		NFA|IMMED|2,"to",0xff
                 TO:
003af5 cff3      		rjmp IS
                 
                 
003af6 f34e      		fdw		QDNEGATE_L
                 TURNKEY_L:
003af7 7487
003af8 7275
003af9 6b6e
003afa 7965      		.db		NFA|7,"turnkey"
                 TURNKEY:
                 		;--------------------------------------------------
003afb 940e 3ad7 		call VALUE_DOES      	; 'call ..' for IS to work!
                 		;--------------------------------------------------
003afd 02ba      		.dw dpSTART
                 
                 
003afe e9f4      		fdw		STARSLASH_L
                 ; TX0  ( c -- )					output character to UART0
                 TX0_L:
003aff 7483
003b00 3078      		.db		NFA|3,"tx0"
                 TX0_:
                 	  .if U0FC_TYPE == 1
                 	  .endif
                 
                 TX0_LOOP:
                 		.if IDLE_MODE == 1
003b01 6074      		  sbr FLAGS2,(1<<fTX0pending)
                 		.endif
003b02 d256      		  rcall PAUSE
                 TX0_quick:
003b03 9190 00c0 		  in_ tosh,UCSR0A
003b05 ff95      		  sbrs tosh,UDRE0		; USART0 Data Register Empty
003b06 cffa      		rjmp TX0_LOOP
                 
003b07 9380 00c6 		out_ UDR0_,tosl
003b09 9189
003b0a 9199      		poptos
                 	  .if IDLE_MODE == 1
003b0b 7f7b      		cbr FLAGS2,(1<<fTX0pending)
                 	  .endif
                 
003b0c 9508      		ret
                 
                 	.if U0FC_TYPE == 1
                 	.endif
                 
                 TX0_SEND:
003b0d 91e0 00c0 		  in_ ZL,UCSR0A
003b0f ffe5      		  sbrs ZL,UDRE0			; USART0 Data Register Empty
003b10 cffc      		rjmp TX0_SEND
003b11 93f0 00c6 		out_ UDR0_,ZH
003b13 9508      		ret
                 
                 
                 .if IDLE_MODE == 0
                 	  .ifdef SMCR				; buffers empty -> enable sleep mode
                 	  .else
                 	  .endif
                 	  .ifdef SMCR				; disable sleep mode
                 	  .else
                 	  .endif
                 .endif
                 
                 ;***************************************************
                 ; RX0    -- c    get character from the UART0 buffer
003b14 da42      		fdw		STOD_L
                 RX0_L:
003b15 7283
003b16 3078      		.db		NFA|3,"rx0"
                 RX0_:
003b17 d241      		  rcall PAUSE
003b18 ebe4      		  ldi ZL, LOW(rx0queue)
003b19 e0f2      		  ldi ZH,HIGH(rx0queue)
003b1a b70f      		  in_ t0,SREG
003b1b 94f8      		  cli
003b1c 81a4      		  ldd XL,Z+_lv0
003b1d 81b5      		  ldd XH,Z+_lv1
003b1e 9711      		  sbiw X,1
003b1f f420      			brcc RX0_1
                 
003b20 bf0f      		  out_ SREG,t0
                 ;	sei
                 								; buffer empty -> switch off LED
003b21 ff70      		  sbrs FLAGS2,fLOADled	; .. if it is NOT in use by CPU_LOAD_LED
                 			.if CPU_LOAD_LED_POLARITY == 1
003b22 982d      				cbi_ CPU_LOAD_PORT,CPU_LOAD_BIT
                 			.else
                 			.endif
                 		  
                 		  .if U0FC_TYPE == 1	; .. send 'XON' if this kind of handshake is enabled
                 		  .elif U0FC_TYPE == 2	; .. set 'RTS' if this kind of handshake is enabled
                 		  .endif
                 
                 		.if IDLE_MODE == 0
                 		.endif
003b23 cff3      		rjmp RX0_
                 
                 RX0_1:
                 
003b24 83b5      		std Z+_lv1,XH
003b25 83a4      		std Z+_lv0,XL
003b26 81a2      		ldd XL,Z+_rd0
003b27 81b3      		ldd XH,Z+_rd1
003b28 939a
003b29 938a      		pushtos
003b2a 918d      		ld tosl,X+
003b2b 2799      		clr tosh
003b2c 30b2      		cpi XH,HIGH(rbuf0+RX0_BUF_SIZE)
003b2d 05a7      		cpc XL,r_zero
003b2e f409      		brne RX0_2
003b2f e0b1      		  ldi XH,HIGH(rbuf0)	;clr XL	; wrap around pointer, rbuf0 on page boundary!!
                 
                 RX0_2:
003b30 83b3      		std Z+_rd1,XH
003b31 83a2      		std Z+_rd0,XL
003b32 bf0f      		out_ SREG,t0
                 ;	sei
                 								; char read  -> switch on LED
003b33 ff70      		sbrs FLAGS2,fLOADled	; .. if it is NOT in use by CPU_LOAD_LED
                 		  .if CPU_LOAD_LED_POLARITY == 1
003b34 9a2d      			sbi_ CPU_LOAD_PORT,CPU_LOAD_BIT
                 		  .else
                 		  .endif
003b35 9508      		ret
                 
                 ;***************************************************
003b36 dd00      		fdw		SCAN_L
                 ; RX0?  ( -- n )				return the number of characters in queue
                 RX0Q_L:
003b37 7284
003b38 3078
003b39 ff3f      		.db		NFA|4,"rx0?",0xff
                 RX0Q:
003b3a 939a
003b3b 938a      		pushtos
003b3c b70f      		in_ t0,SREG
003b3d 94f8      		cli
003b3e 9180 02b8 		lds tosl,rbuf0_lv
003b40 9190 02b9 		lds tosh,rbuf0_lv+1
003b42 bf0f      		out_ SREG,t0
                 ;	sei
003b43 9508      		ret
                 
                 
003b44 d792      		fdw		RPFETCH_L
                 ROT_L:
003b45 7283
003b46 746f      		.db		NFA|3, "rot"
                 ROT:
003b47 91a9
003b48 91b9      		 pop_t5t4
003b49 9109
003b4a 9119      		 pop_t1t0
003b4b 93ba
003b4c 93aa      		 push_t5t4
003b4d 939a
003b4e 938a      		 pushtos
003b4f 01c8      		 movw TOP,t1t0			; 9 / 17
003b50 9508      		 ret
                 
                 
                 ; c@+  ( addr -- addr+1 n )
                 ;   dup 1+ swap c@ ;
003b51 ddd4      		fdw		COMMAXT_L
                 CFETCHPP_L:
003b52 6383
003b53 2b40      		.db		NFA|3,"c@+"
                 CFETCHPP:
003b54 d1c6      		rcall CFETCH
003b55 93fa
003b56 93ea      		push_Z
003b57 9508      		ret
                 
                 
                 ; @+   ( addr -- addr+2 n )
                 ;   dup 2+ swap @ ;
003b58 da6c      		fdw		L_FETCH_P
                 FETCHPP_L:
003b59 4082
003b5a ff2b      		.db		NFA|2,"@+",0xff
                 FETCHPP:
003b5b d1b0      		rcall FETCH
003b5c 93fa
003b5d 93ea      		push_Z
003b5e 9508      		ret
                 
                 
                 .if (FLASHEND < 0x1ffff)
003b5f f6dc      			fdw		WDOFF_L
                 	; WD+ ( n -- )				n < 8, start watchdog timer
                 	WDON_L:
003b60 7783
003b61 2b64      			.db		NFA|3,"wd+"
                 	WDON:
003b62 94f8      			cli
003b63 95a8      			wdr
003b64 7087      			andi tosl,7
003b65 6088      			ori tosl,(1<<WDE)
003b66 e198      			ldi tosh,(1<<WDCE)|(1<<WDE)
003b67 9390 0060 			sts WDTCSR,tosh
003b69 9380 0060 			sts WDTCSR,tosl
003b6b 9478      			sei
003b6c c1c0      			rjmp DROP_A
                 
                 
003b6d d9d6      			fdw		X_TO_R_L
                 	; WD- ( -- )				stop the watchdog 
                 	WDOFF_L:
003b6e 7783
003b6f 2d64      			.db		NFA|3,"wd-"
                 	WDOFF:
003b70 94f8      			cli
003b71 95a8      			wdr
                   	.ifdef MCUSR
003b72 be74      				out MCUSR,r_zero
                   	.else
                   	.endif
003b73 e108      			ldi t0,(1<<WDCE)|(1<<WDE)
003b74 9300 0060 			sts WDTCSR,t0
003b76 9270 0060 			sts WDTCSR,r_zero
003b78 9478      			sei
003b79 9508      			ret
                 
                 
003b7a d96e      			fdw 	DZEROLESS_L
                 	; cwd  ( -- )				kick watchdog
                 	CWD_L:
003b7b 63a3
003b7c 6477      			.db		NFA|INLINE|3,"cwd"
                 	;CWD:
003b7d 95a8      			wdr
003b7e 9508      			ret
                 .endif
                 
003b7f e32c      		 fdw		IMMEDQ_L
                 IFLUSH_L:
003b80 6986
003b81 6c66
003b82 7375
003b83 ff68      		.db		NFA|6,"iflush",0xff
                 IFLUSH:
003b84 99f1      		sbic FLAGS3,idirty
003b85 c332      		  rjmp IWRITE_BUFFER
003b86 9508      		ret
                 
                 
                 .ifdef UCSR1A
                 .else
003b87 da22      		fdw		ENDIT_L
                 .endif
                 EMPTY_L:
003b88 6585
003b89 706d
003b8a 7974      		.db		NFA|5,"empty"
                 EMPTY:
003b8b da63      		rcall DOLIT
003b8c d748      		fdw COLDLIT
003b8d da61      		rcall DOLIT
003b8e 0900      		.dw dp_start
003b8f da5f      		rcall DOLIT
003b90 000c      		.dw coldlitsize
003b91 d982      		rcall CMOVE				; burn DP's to EEPROM
003b92 c867      		rjmp DP_TO_RAM			; .. and copy to RAM
                 
                 
003b93 e316      		fdw		WORD_L
                 WARM_L:
003b94 7784
003b95 7261
003b96 ff6d      		.db		NFA|4,"warm",0xff
                 WARM_:
003b97 27dd      		clr YH
                 
                 	.ifdef MCUCSR
                 	.endif
                 	.ifdef MCUSR
003b98 b604      			in_ R0,MCUSR
003b99 bfd4      			out_ MCUSR,YH
                 	.endif
                 WARM_0:
003b9a b61f      		in_ R1,SREG	
003b9b 94f8      		cli
                 ; zero memory
003b9c e0a2      		ldi XL,2
003b9d e0b0      		ldi XH,0
                 WARM_1:							; clear register R2..R25 (r_zero, FLAGS1, FLAGS2, TOP included)
003b9e 93dd      		  st X+,YH
003b9f 31aa      		  cpi XL,26
003ba0 f7e9      		brne WARM_1
                 
003ba1 9100 0066 		in_ t0,OSCCAL			; save OSCCAL for ...
                 
003ba3 e1ac      		ldi XL,28  				; clear ram from y register upwards (FLAGS3, cse included)
                 WARM_2:
003ba4 927d      		  st X+,r_zero
003ba5 30b9      		  cpi XH,HIGH(PEEPROM)	; up to the end of SRAM
003ba6 f7e9      		brne WARM_2
                 
003ba7 9300 0066 		out_ OSCCAL,t0			; .. flash + eeprom write timing
                 
                 ; init empty flash buffer
003ba9 94da      	    dec ibaseH				; 0xff
                 
                 	.ifdef RAMPZ
                 	.endif
                 
                 ; init Stack pointer
003baa e6c4      		ldi YL, low(utibbuf-4)	; 2 cells safety
003bab e0d3      		ldi YH,high(utibbuf-4)
                 ; init Return stack pointer
003bac e206      		ldi t0, LOW(usbuf-2)	; 1 cell safety
003bad e013      		ldi t1,HIGH(usbuf-2)
003bae bf0d      		out SPL,t0
003baf bf1e      		out SPH,t1
                 
                 		;rcall   INIT_012		; Init constant registers
                 ;INIT_012:
                 		;clr r_zero				; already there
003bb0 9463      		inc r_one				; from 0 to 1
                 ;		inc r_two	inc r_two	; no r_two anymore
                 
003bb1 dfbe      		rcall WDOFF
                 ; init user pointer
003bb2 ee06      		ldi t0, LOW(up0)
003bb3 e012      		ldi t1,HIGH(up0)
003bb4 0118      		movw UP,t1t0
                 
                 	.ifdef RAMPZ
                 	.endif
                 	.ifdef EIND
                 	.endif
                 
                 ; init warm literals
003bb5 da39      		rcall DOLIT
003bb6 d736      		fdw WARMLIT
003bb7 da37      		rcall DOLIT
003bb8 02ca      		.dw uvars
003bb9 da35      		rcall DOLIT
003bba 0014      		.dw warmlitsize
003bbb d958      		rcall CMOVE
                 
                 		;out cse,r_zero			; initialized to 0 (= 'flash')
                 		;out state,r_two		; initialized to 0 (= 'interpret') with FLAGS2
                 
                 ; init cold data to eeprom
003bbc e0e0      		ldi ZL, LOW(dp_start)
003bbd e0f9      		ldi ZH,HIGH(dp_start)
                 ;		pushtos					; stack is empty -> nothing to save
003bbe 9468      		set
003bbf d125      		rcall EFETCH			; Z+ included
003bc0 9601      		adiw TOP,1				; if 'turnkey' is 0xffff then burn DP's to EEPROM
                 ;		poptos					; nothing pushed yet
003bc1 f409      		brne PC+2
003bc2 dfc8      		  rcall EMPTY
                 								; move interrupts to boot flash section
003bc3 be65      		out_ MCUCR,r_one   		; (1<<IVCE)
003bc4 e0f2      		ldi t7,2				; (1<<IVSEL)
003bc5 bff5      		out_ MCUCR,t7
                 
                 ; init MS timer
                 	.if MS_TIMER == 0
                 	  .ifdef TIMSK0
003bc6 bdf4      			out_ TCCR0A,t7			; 0x02 (CTC mode)
003bc7 e003      	       	ldi t0,ms_pre_tmr0
003bc8 bd05      	       	out_ TCCR0B,t0
003bc9 ef09      	       	ldi t0,ms_value_tmr0
003bca bd07      	       	out_ OCR0A,t0
003bcb 93f0 006e 			out_ TIMSK0,t7			; 0x02 (1<<OCIE0A)
                 	  .endif
                 	  .ifdef TIMSK
                 	  .endif
                 	.elif MS_TIMER == 1
                   	  .ifdef TIMSK
                   	  .endif
                   	  .ifdef TIMSK1
                   	  .endif
                 	.elif MS_TIMER == 2
                   	  .ifdef TIMSK2
                   	  .endif
                   	  .ifdef TIMSK
                   	  .endif
                 	.endif
                 
                 	.if CPU_LOAD == 1
003bcd ef0f        			ldi t0, LOW(CPU_LOAD_VAL - 1)
003bce e41f      			ldi t1,HIGH(CPU_LOAD_VAL - 1)
003bcf 9310 0089 			out_ OCR1AH,t1
003bd1 9300 0088 			out_ OCR1AL,t0			; load counter is started by any interrupt
                   	  .ifdef TIMSK
                   	  .endif
                   	  .ifdef TIMSK1
003bd3 93f0 006f 			out_ TIMSK1,t7			; 0x02(1<<OCIE1A)
                   	  .endif
                 	.endif
                 
                 ; init UART0
                 .ifdef UBRR0L
003bd5 eb01      		ldi t0, LOW(RX0_ISR)
003bd6 e31a      		ldi t1,HIGH(RX0_ISR)
                 
                   .ifdef URXC0addr
                   .else
003bd7 9310 02a5   			sts (URXCaddr+ivec+1),t1
003bd9 9300 02a4 			sts (URXCaddr+ivec)  ,t0
                   .endif
                 
003bdb e100      		ldi t0,ubrr0val				; set baud rate
003bdc 9300 00c4 		out_ UBRR0L,t0
003bde 93f0 00c0 		out_ UCSR0A,t7				; 0x02 -> set double speed mode			
003be0 e908      		ldi t0,(1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)	; enable receiver, transmitter, rx0 interrupts
003be1 9300 00c1 		out_ UCSR0B,t0
003be3 e006      		ldi t0,(3<<UCSZ00)|URSEL_	; set frame format: 8data, 1stop bit
003be4 9300 00c2 		out_ UCSR0C,t0
                 
                   .if U0FC_TYPE == 1
                   .elif U0FC_TYPE == 2
                   .endif
                 .endif
                 								; init rbuf0 pointer
                 		;sts rbuf0_lv  ,r_zero		; level starts at 0000
                 		;sts rbuf0_lv+1,r_zero
003be6 e011      		ldi t1,HIGH(rbuf0)			; rbuf0 on page boundary!!
003be7 9310 02b5 		sts rbuf0_wr+1,t1
003be9 9310 02b7 		sts rbuf0_rd+1,t1
                 
                 
                 	; init UART1
                 	.ifdef UBRR1L
                   	  .if U1FC_TYPE == 1
                   	  .endif
                   	  .if U1FC_TYPE == 2
                   	  .endif
                 	.endif
                 	.ifdef rbuf1_lv
                 	.endif
                 
003beb d80e      		rcall DP_TO_RAM
                 
003bec 9478      		sei
                 		 ;rcall RQ_EMIT
                 ;RQ_EMIT:
003bed e200      		ldi t0,' '
003bee fc02      		sbrc R0,BORF
003bef e402      		  ldi t0,'B'
003bf0 fc03      		sbrc R0,WDRF
003bf1 e507      		  ldi t0,'W'
003bf2 fc01      		sbrc R0,EXTRF
003bf3 e405      		  ldi t0,'E'
003bf4 fc00      		sbrc R0,PORF			; (MCUSR reset value in R0)
003bf5 e500      		  ldi t0,'P'
003bf6 fc16      		sbrc R1,6				; T with MATH error (SREG reset value in R1)
003bf7 e40d      		  ldi t0,'M'
003bf8 da7b      		rcall EMIT_t0
                 
003bf9 d01e      		rcall VER
                 ; init LED
003bfa 9a25      		sbi_ CPU_LOAD_DDR,CPU_LOAD_BIT
                        .if CPU_LOAD_LED_POLARITY == 1
003bfb 982d      			cbi_ CPU_LOAD_PORT,CPU_LOAD_BIT
                        .else
                        .endif
                 
                 WARM_4:							; write protect bootloader section
003bfc 99f9
003bfd cffe      		  sbic EECR,EEPE	rjmp WARM_4	; EEPROM write in progress?
                 
                 
003bfe 01f3      		movw Z,r_one
003bff ee0f      		ldi t0,0xef				; BLB11 = 0
003c00 2e00      		mov R0,t0
003c01 e019      		ldi t1,(1<<BLBSET) | (1<<SPMEN)
003c02 d332      		rcall DO_SPM
                 
                 ; check 'turnkey'
003c03 def7      		rcall TURNKEY
003c04 9700      		sbiw TOP,0
003c05 f071      		  breq STARTQ2
003c06 db88      		rcall XSQUOTE
003c07 7306
003c08 6174
003c09 7472
003c0a 003f      		.db  6,"start?",0
003c0b dbe1      		rcall TYPE
003c0c ed80
003c0d e097      		ldi16 tos,TURNKEY_DELAY
003c0e d13d      		rcall MS
003c0f d26a      		rcall KEYQ
003c10 9700      		sbiw TOP,0
003c11 f411      		  brne STARTQ2
                 STARTQ1:						; no key -> execute
003c12 dee8      		rcall TURNKEY
003c13 d26d      		rcall EXECUTE
                 STARTQ2:
003c14 c999      		rjmp ABORT
                 
                 ;.equ partlen = strlen(partstring)
                 .equ datelen = strlen(DATE)
                 
003c15 f6c0      		fdw		WDON_L
                 VER_L:
003c16 7683
003c17 7265      		.db		NFA|3,"ver"
                 VER:
003c18 db76      		rcall XSQUOTE
                 		;        123456789012345678901234567890123456    7
                 		;.db 37," OptiForth 5.2  ATmega328 dd.mm.yyyy",0xd
003c19 2025
003c1a 704f
003c1b 6974
003c1c 6f46
003c1d 7472
003c1e 2068
003c1f 2e35
003c20 2032
003c21 4120
003c22 6d54
003c23 6765
003c24 3361
003c25 3832
003c26 3020
003c27 2e35
003c28 3231
003c29 322e
003c2a 3230
003c2b 0d30      		.db 27+datelen," OptiForth 5.2  ATmega328 ",DATE,0xd		;partstring
                 TYPE_A:
003c2c cbc0      		rjmp TYPE
                 
                 
                 ;*******************************************************
                 ; ;i ( -- )						end definition of user interrupt routine
003c2d e172      		fdw		LESSNUM_L
                 IRQ_SEMI_L:
003c2e 3bc2
003c2f ff69      		.db		NFA|IMMED|2,";i",0xff
                 ;IRQ_SEMI:
003c30 d9be      		rcall DOLIT
                 
                 	.ifdef EIND
                 	.else
003c31 940c      			.dw 0x940C			; jmp <page 0>
                 	.endif
                 
003c32 d046      		rcall ICOMMA
003c33 d9bb      		rcall DOLIT
003c34 3ecb      		.dw OF_ISR_EXIT
003c35 777f      		cbr FLAGS2,(1<<fSTATE)
003c36 c042      		rjmp ICOMMA
                 
                 
003c37 fcee      		fdw		KEYQ_L
                 ; int! ( addr n  --  )			store to interrupt vector number
                 IRQ_V_L:
003c38 6984
003c39 746e
003c3a ff21      		.db		NFA|4,"int!",0xff
                 ;IRQ_V:
003c3b 5081      		subi tosl,1
003c3c 0f88      		lsl tosl
003c3d e8e0      		ldi ZL, LOW(ivec)
003c3e e0f2      		ldi ZH,HIGH(ivec)
003c3f 0fe8      		add ZL,tosl
003c40 1df7      		adc ZH,r_zero
003c41 9189
003c42 9199      		poptos
003c43 5890      		sub_pflash_tos			; TO_XA (virtual addr -> real addr)
003c44 9596      		lsr tosh
003c45 9587      		ror tosl
003c46 c0e4      		rjmp SRZ_w				; store word to RAM
                 
                 
003c47 e6c4      		fdw		NUMBERQ_L
                 ; DOLITERAL ( x -- )			compile DOLITeral x as native code
                 LITERAL_L:
003c48 6cc7
003c49 7469
003c4a 7265
003c4b 6c61      		.db		NFA|IMMED|7,"literal"
                 LITERAL:
003c4c 939a
003c4d 938a      		pushtos
003c4e eb82
003c4f ed99      		ldi16 tos,((DUP<<1)+PFLASH)
003c50 dcad      		rcall INLINE0
                 ;LITERAL_2:
003c51 fd67      		sbrc FLAGS1,fLIT
003c52 6068      		  sbr FLAGS1,(1<<f2LIT)
003c53 6860      		sbr FLAGS1,(1<<fLIT)
003c54 786e      		cbr FLAGS1,(1<<izeroeq)|(1<<idup)|(1<<icarryeq)|(1<<doclear)
003c55 9380 02c7 		sts litbuf0,tosl
003c57 bd9b      		out litbuf1,tosh
003c58 939a
003c59 938a      		duptos
003c5a 2f98      		mov tosh,tosl
003c5b e810      		ldi t1,regtosl			; 'ldi regl,<lit.0>'
003c5c d002      		rcall LITERAL_1
003c5d 2f89      		mov tosl,tosh
003c5e e910      		ldi t1,regtosh			; '... regh,..'
                 LITERAL_1:
003c5f 9592      		swap tosh
003c60 708f      		andi tosl,0x0f
003c61 709f      		andi tosh,0x0f
003c62 2b81      		or tosl,t1
003c63 6e90      		ori tosh,0xe0			; 'ldi ..,..'
003c64 c014      		rjmp ICOMMA
                 
                 #if 0
                 #endif
                 
                 
                 ;*****************************************************************
                 .if optimizingCOMPILER == 1
                 	FETCHC_:
003c65 d007      			 rcall FETCHC_helper	; compile 'lds tosl,<addr>'
003c66 9601      			 adiw TOP,1				; <addr+1>
003c67 e9a0      			 ldi t4,0x90			; register 0x19 -> tosh
003c68 c829      			 rjmp comp_lds_			; compile 'lds tosh,<addr+1>'
                 
                 	CFETCHC_:
003c69 d003      			 rcall FETCHC_helper
                 	ldi_tosh_0_C_:
003c6a e980
003c6b ee90      			 ldi16 tos,0xe090		; replace <addr> by 'ldi tosh,0x00'
003c6c c00c      			 rjmp ICOMMA
                 	
                 	FETCHC_helper:
003c6d e004      			 ldi t0,4
003c6e dbd3      			 rcall IDPMINUS
003c6f 9180 02c7 			 lds tosl,litbuf0		; lit in TOP
003c71 b59b      			 in tosh,litbuf1
                 	FETCHC_help0:
003c72 939a
003c73 938a      			 duptos					; dup <addr>
003c74 e8a0      			 ldi t4,0x80			; register 0x18 -> tosl
003c75 c81c      			 rjmp comp_lds_
                 .endif	
                 
                 
003c76 f0a6      		fdw		IF_L
                 ICOMMA_L:
003c77 6982
003c78 ff2c      		.db		NFA|2, "i,",0xff
                 ICOMMA:
003c79 9468      		set
003c7a e002      		ldi t0,2
                 ICOMMA_0:
003c7b ebac
003c7c e0b2      		ldi16 X,dpFLASH
003c7d 91ed      		ld ZL,X+
003c7e 91fd      		ld ZH,X+
003c7f 0fe0      		add ZL,t0
003c80 1df7      		adc ZH,r_zero
003c81 93fe      		st -X,ZH
003c82 93ee      		st -X,ZL
003c83 1be0      		sub ZL,t0
003c84 09f7      		sbc ZH,r_zero
003c85 c06f      		rjmp STORE1
                 
                 
003c86 f1f8      		fdw		INLINEC_L
                 ; ic,  ( c -- )					write char at ihere
                 ;   IHERE c! 1 CHARS IALLOT ;
                 ICCOMMA_L:
003c87 6983
003c88 2c63      		.db		NFA|3,"ic,"
                 ICCOMMA:
003c89 94e8      		 clt
003c8a e001      		 ldi t0,1
003c8b cfef      		 rjmp ICOMMA_0
                 
                 
003c8c de7e      		fdw		SPACES_L
                 ; SOURCE  ( -- addr n )			current input buffer
                 ;	'SOURCE 2@ ;				length is at higher adrs
                 SOURCE_L:
003c8d 7386
003c8e 756f
003c8f 6372
003c90 ff65      		.db		NFA|6,"source",0xff
                 ;SOURCE:
003c91 939a
003c92 938a      		 pushtos
003c93 01f1      		 movw Z,UP
003c94 9738      		 sbiw Z,(-usource)
003c95 9181      		 ld tosl,Z+
003c96 9191      		 ld tosh,Z+
003c97 939a
003c98 938a      		 pushtos
003c99 9181      		 ld tosl,Z+
003c9a 9191      		 ld tosh,Z+				; 10 / 19
003c9b 9508      		 ret
                 
                 
003c9c ed38      		fdw		 NONAME_L
                 ; /STRING ( a u n -- a+n u-n )	trim string
                 ;	swap over - >r + r> ;
                 SLASHSTRING_L:
003c9d 2f87
003c9e 7473
003c9f 6972
003ca0 676e      		.db		NFA|7,"/string"
                 ;SLASHSTRING:
003ca1 01dc      		 movw t5t4,TOP			; n
003ca2 9189
003ca3 9199      		 poptos					; u
003ca4 9109
003ca5 9119      		 pop_t1t0				; a
003ca6 1b8a      		 sub tosl,t4			; u-n
003ca7 0b9b      		 sbc tosh,t5
003ca8 0f0a      		 add t0,t4				; a+n
003ca9 1f1b      		 adc t1,t5
003caa 931a
003cab 930a      		 push_t1t0				; 11 / 17
003cac 9508      		 ret
                 
                 
003cad f3c4      		fdw		DINVERT_L
                 ; DECIMAL ( -- )				set number base to decimal
                 ;	#10 BASE ! ;
                 DECIMAL_L:
003cae 6487
003caf 6365
003cb0 6d69
003cb1 6c61      		.db		NFA|7,"decimal"
                 ;DECIMAL: 
003cb2 e00a      		 ldi t0,0x0a
                 BASE_STORE:
003cb3 01f1      		 movw Z,UP
003cb4 9772      		 sbiw Z,(-ubase)
003cb5 9301      		 st Z+,t0
003cb6 9271      		 st Z+,r_zero			; 5 / 8
003cb7 9508      		 ret
                 
003cb8 f90e      		fdw		ICCOMMA_L
                 ; HEX ( -- )					set number base to hex
                 ;	#16 BASE ! ;
                 HEX_L:
003cb9 6883
003cba 7865      		.db		NFA|3,"hex"
                 ;HEX:
003cbb e100      		 ldi t0,0x10
003cbc cff6      		 rjmp BASE_STORE
                 
003cbd ea8c      		fdw		CTON_L
                 ; BIN ( -- )					set number base to binary
                 ;	#2 BASE ! ;
                 BIN_L:
003cbe 6283
003cbf 6e69      		.db		NFA|3,"bin"
                 ;BIN:
003cc0 e002      		 ldi t0,2
003cc1 cff1      		 rjmp BASE_STORE
                 
                 
                 IFETCH:
003cc2 58f0      		sub_pflash_z
                 
                 	.ifdef RAMPZ
                 	.endif
                 
003cc3 11fd      		cpse ZH,ibaseH
003cc4 c00e      		  rjmp IIFETCH
003cc5 2f0e      		mov t0,ZL
003cc6 7800      		andi t0,~(PAGESIZEB-1)
003cc7 150c      		cp t0,ibaseL
003cc8 f451      		  brne IIFETCH
003cc9 2fae      		mov XL,ZL
003cca 77af      		andi XL,(PAGESIZEB-1)
                 		;add XL, LOW(ibuf)		; ibuf on page boundary !!!
003ccb e0b2      		ldi XH,HIGH(ibuf)
003ccc 918d      		ld tosl,X+
003ccd f416      		brtc IFETCH_1
003cce 919d      		  ld tosh,X+
003ccf 9631      		  adiw Z,1
                 IFETCH_1:
003cd0 9631      		adiw Z,1				; for 'FETCH_Zplus'
003cd1 58f0      		add_pflash_z
003cd2 9508      		ret
                 
                 IIFETCH:
003cd3 9185      		lpm_ tosl,Z+	     	; fetch from FLASH directly
003cd4 f40e      		brtc IIFETCH_1
003cd5 9195      		  lpm_ tosh,Z+
                 IIFETCH_1:
003cd6 58f0      		add_pflash_z
003cd7 9508      		ret
                 
                 ISTORE_Z:
003cd8 d1bb      		rcall IUPDATEBUF
003cd9 e0f2      		ldi ZH,high(ibuf)
003cda 91e0 02c4 		lds ZL,iaddrl
003cdc 77ef      		andi ZL,(PAGESIZEB-1)
003cdd 9381      		st Z+,tosl
003cde f40e      		brtc ISTO_xxx
003cdf 9391      		  st Z+,tosh			; T-flag -> 'store word'
                 ISTO_xxx:
003ce0 9af1      		sbi FLAGS3,idirty
003ce1 c04b      		rjmp DROP_A
                 
                 FETCH1:
003ce2 9468      		set
                 CFETCH1:
003ce3 38f0      		cpi ZH,HIGH(OFLASH)
003ce4 f6e8      		  brcc IFETCH
                 
003ce5 99f9
003ce6 cffe      EFETCH:   sbic EECR,EEWE	rjmp EFETCH	; EEPROM ready?
                 
003ce7 50f9      		subi ZH,high(PEEPROM)
003ce8 bdf2      		out EEARH,ZH
003ce9 bde1      		out EEARL,ZL
003cea ba6f      		out EECR,r_one			; (1<<EERE)
003ceb b580      		in tosl,EEDR
003cec f42e      		  brtc EFETCH_leave
003ced 9631      		adiw Z,1
003cee bdf2      		out EEARH,ZH				
003cef bde1      		out EEARL,ZL
003cf0 ba6f      		out EECR,r_one			; (1<<EERE)
003cf1 b590      		in tosh,EEDR
                 		;rjmp EFETCH_leave
                 EFETCH_leave:
003cf2 9631      		adiw Z,1				; for 'FETCH_Zplus'
003cf3 5ff7      		subi ZH,HIGH(-PEEPROM)
003cf4 9508      		ret
                 
                 
                 STORE1:
003cf5 99f2      		sbic FLAGS3,fLOCK
003cf6 c196      		  rjmp ISTORERR			; EEPROM + FLASH write protected
003cf7 38f0      		cpi ZH,high(OFLASH)
003cf8 f6f8      		  brcc ISTORE_Z
                 ;ESTORE_Z:
003cf9 50f9      		subi ZH,HIGH(PEEPROM)
                 
003cfa 99f9
003cfb cffe      ECS_wait: sbic EECR,EEWE	rjmp ECS_wait	; wait EEPROM ready
                 
003cfc bdf2      		  out EEARH,ZH
003cfd bde1      		  out EEARL,ZL
003cfe bd80      		  out EEDR,tosl
003cff b70f      		  in_ t0,SREG
003d00 94f8      		  cli
003d01 e084      		  ldi tosl,(EEMPE<<1)
003d02 bb8f      		  out EECR,tosl
003d03 9af9      		  sbi EECR,EEWE
003d04 bf0f      		  out_ SREG,t0
                 ;	sei
003d05 f53e      		    brtc DROP_A
003d06 9631      		  adiw Z,1
003d07 2f89      		  mov tosl,tosh
003d08 94e8      		  clt
003d09 cff0      		rjmp ECS_wait
                 
                 
                 .if FLASHEND > 0x3fff
                 .else
003d0a f2e0      		fdw		innerINDEX_L
                 .endif
                 FETCH_L:
003d0b 4081      		.db		NFA|1, "@"
                 FETCH:
003d0c 01fc      		movw Z,TOP
                 FETCH_Zplus:
003d0d 30f9      		cpi ZH,HIGH(PEEPROM)
003d0e f698      		  brcc FETCH1
003d0f 9181      		ld tosl,Z+
003d10 9191      		ld tosh,Z+
003d11 9508      		ret
                 
                 
003d12 fa6c      		fdw		L_PCFETCH
                 ; pc!  ( c -- )					store char to address in pointer
                 PCSTORE_L:
003d13 7083
003d14 2163      		.db		NFA|3,"pc!"
                 PCSTORE:
003d15 94e8      		clt
003d16 01fa      		movw Z,P
003d17 c010      		rjmp STORE_Z
                 
                 
003d18 ece2      		fdw		CR_L
                 ; c@  ( adr -- c )				fetch char from adr
                 CFETCH_L:
003d19 6382
003d1a ff40      		.db		NFA|2, "c@",0xff
                 CFETCH:
003d1b 01fc      		movw Z,TOP
                 CFETCH_Zplus:
003d1c 2799      		clr tosh
003d1d 94e8      		clt
003d1e 30f9      		cpi ZH,HIGH(PEEPROM)
003d1f f618      		  brcc CFETCH1
003d20 9181      		ld tosl,Z+
003d21 9508      		ret
                 
                 
003d22 dba4      		fdw		NUM_L
                 ; !  ( n adr -- )				store n to adr
                 STORE_L:
                 kernellink_short:
003d23 2181      		.db		NFA|1, "!"
                 STORE:
003d24 9468      		set						; 'store word' flag
                 STORE_0:
003d25 01fc      		movw Z,TOP
003d26 9189
003d27 9199      		poptos
                 STORE_Z:
003d28 30f9      		cpi ZH,high(PEEPROM)
003d29 f658      		  brcc STORE1
                 STORE_RAM_Z:
003d2a f40e      		brtc SRZ_b
                 SRZ_w:
003d2b 8391      		  std Z+1,tosh
                 SRZ_b:
003d2c 8380      		std Z+0,tosl
                 DROP_A:
003d2d 9189
003d2e 9199      		poptos
003d2f 9508      		ret
                 
                 
003d30 ea64      		fdw		CCOMMA_L
                 ; c!  ( c adr -- )				store char to adr
                 CSTORE_L:
003d31 6382
003d32 ff21      		.db		NFA|2, "c!",0xff
                 CSTORE:
003d33 94e8      		clt						; 'store char' flag
003d34 cff0      		rjmp STORE_0
                 
                 
003d35 da0e      		fdw		PFL_L
                 ; pc@ ( -- c )					fetch char from address in pointer
                 L_PCFETCH:
003d36 7083
003d37 4063      		.db		NFA|3,"pc@"
                 ;PCFETCH:
003d38 939a
003d39 938a      		pushtos
003d3a 01fa      		movw Z,P
003d3b cfe0      		rjmp CFETCH_Zplus
                 
                 
003d3c edee      		fdw		R0_L
                 ; p@  ( -- n )					fetch word from address in pointer
                 PFETCH_L:
003d3d 7082
003d3e ff40      		.db		NFA|2,"p@",0xff
                 PFETCH:
003d3f 939a
003d40 938a      		pushtos
003d41 01fa      		movw Z,P
003d42 cfca      		rjmp FETCH_Zplus
                 
                 
003d43 daba      		fdw		PPLUS_L
                 ; p!  ( n -- )					store word to address in pointer
                 PSTORE_L:
003d44 7082
003d45 ff21      		.db		NFA|2,"p!",0xff
                 PSTORE:
003d46 9468      		set
003d47 01fa      		movw Z,P
003d48 cfdf      		rjmp STORE_Z
                 
                 
003d49 e86a      		fdw		NEQUAL_L
                 ; ms  ( u -- )					pause for u milliseconds
                 ;	ticks +
                 ;	begin pause dup ticks = until drop ;
                 ;
                 MS_L:
003d4a 6d82
003d4b ff73      		.db		NFA|2,"ms",0xff
                 MS:
003d4c 0187      		movw t1t0,MS_COUNT
003d4d 0f80      		add tosl,t0
003d4e 1f91      		adc tosh,t1
                 MS1:
                 		.if IDLE_MODE == 0
                 		.endif
003d4f d009      		  rcall PAUSE
003d50 0187      		  movw t1t0,MS_COUNT
003d51 1708      		  cp  t0,tosl
003d52 0719      		  cpc t1,tosh
003d53 f7d9      		brne MS1
003d54 cfd8      		rjmp DROP_A
                 
                 
003d55 eaca      		fdw		PLACE_L
                 ; PAUSE ( -- )					switch task
                 PAUSE_L:
003d56 7085
003d57 7561
003d58 6573      		.db		NFA|5,"pause"
                 PAUSE:
                 	  .if IDLE_MODE == 0
                 	  .elif IDLE_MODE == 1
003d59 fd71      		sbrc FLAGS2,fIDLE
003d5a dd10      		  rcall IDLE_LOAD		; 'idle' -> check for sleep
                 	  .endif
                 
003d5b 95a8      		wdr						; watchdog reset
003d5c 01f1      		movw Z,UP
003d5d 973c      		sbiw Z,(-ulink)
003d5e 91a1      		ld XL,Z+				; get task link
003d5f 91b1      		ld XH,Z+
003d60 15a2      		cp  XL,upL				; up = ulink?
003d61 05b3      		cpc XH,upH
003d62 f0c9      		  breq PAUSE_exit		; ..yes -> single task, no switching
                 
                 	  .if IDLE_MODE == 0
                 	  .endif
                 							; switch task
003d63 b71f      		in_ t1,SREG
003d64 94f8      		cli
003d65 93df      		push YH					; SP
003d66 93cf      		push YL
003d67 939f      		push tosh      			; TOS
003d68 938f      		push tosl
003d69 935f      		push ph					; P
003d6a 934f      		push pl
003d6b 01f1      		movw Z,UP
003d6c b70e      		in t0,SPH				; write rsp to 'ursave'
003d6d 9302      		st -Z,t0
003d6e b70d      		in t0,SPL
003d6f 9302      		st -Z,t0
003d70 011d      		movw UP,X
003d71 910e      		ld t0,-X
003d72 bf0e      		out SPH,t0
003d73 910e      		ld t0,-X
003d74 bf0d      		out SPL,t0
003d75 914f      		pop pl
003d76 915f      		pop ph
003d77 918f      		pop tosl
003d78 919f      		pop tosh
003d79 91cf      		pop YL
003d7a 91df      		pop YH
003d7b bf1f      		out_ SREG,t1
                 ;	sei
                 PAUSE_exit:
003d7c 9508      		ret						; 36 / 14..55+4
                 
                 
003d7d eb82      		fdw		QABORT_L
                 SCALE_L:
003d7e 3186
003d7f 3230
003d80 2a34
003d81 ff2f      		.db		NFA|6,"1024*/",0xff
                 SCALE:
003d82 9109
003d83 9119      		pop_t1t0
                 SCALE_0:
003d84 dd02      		rcall umstar0_0			;	product.l in TOP, product.h in t7:t6
003d85 95f6
003d86 95e7
003d87 9597      		lsr t7	ror t6	ror tosh	; '1.024 /' by shifting right 
003d88 95f6
003d89 95e7
003d8a 9597      		lsr t7	ror t6	ror tosh		
003d8b 2f89      		mov tosl,tosh				; .. and dropping lower 8 bits
003d8c 2f9e      		mov tosh,t6
003d8d 1d87      		adc tosl,r_zero			; rounding
003d8e 1d97      		adc tosh,r_zero
003d8f 9508      		ret						; 14 / 38+4
                 
                 
003d90 e226      		fdw		UDDOT_L
                 ; UD* ( ud u -- ud' )			unsigned 32 x 16 bit multiply to 32 bit
                 UDSTAR_L:
003d91 7583
003d92 2a64      		.db		NFA|3,"ud*"
                 ;UDSTAR:
003d93 018c      		movw t1t0,TOP			; u    in t1t0 
003d94 9189
003d95 9199      		poptos					; ud.h in TOP
003d96 dcf0      		rcall umstar0_0			; ud.h * u -> t7:t6:TOP, t1t0 unchanged
003d97 015c      		movw A,TOP				; save low part, drop high part (t7:t6)
003d98 9189
003d99 9199      		poptos					; ud.l in TOP
003d9a dcec      		rcall umstar0_0			; ud.l * u -> t7:t6:TOP
003d9b 939a
003d9c 938a      		pushtos					; push low part
003d9d 01cf      		movw TOP,t7t6			; get high part
003d9e 0d8a      		add tosl,al				; accumulate high part to ud'.h
003d9f 1d9b      		adc tosh,ah				; 13 / 65
003da0 9508      		ret
                 
                 
003da1 f82c      		fdw		VER_L
                 UMSTAR_L:
003da2 7583
003da3 2a6d      		.db		NFA|3,"um*"
                 UMSTAR:
003da4 dce0      		 rcall umstar0			; product.l in tos, product.h in t7:t6
003da5 939a
003da6 938a      		 pushtos
003da7 01cf      		 movw TOP,t7t6
003da8 9508      		 ret
                 
                 
003da9 d82e      		fdw		ULINK_L
                 USLASHMOD_L:
003daa 7585
003dab 6d2f
003dac 646f      		.db		NFA|5,"u/mod"
                 USLASHMOD:
003dad d01a      		rcall USLASH			; (tosh:tosl) / (t5:t4) -> (tosh:tosl) (t3:t2[rem])
003dae 921a
003daf 920a      		push_t3t2
003db0 9508      		ret
                 
003db1 ea76      		fdw		NTOC_L
                 MOD_L:
003db2 6d83
003db3 646f      		.db		NFA|3,"mod"
                 MOD:						; unsigned values only
003db4 d013      		 rcall USLASH			; remainder returned in t3:t2
003db5 01c0      		 movw TOP,t3t2
003db6 9508      		 ret
                 
                 
                 usm0_err:
003db7 9468      		set
003db8 cdde      		rjmp WARM_
                 
                 
003db9 f972      		fdw		HEX_L
                 ; gcd (u1 u2 -- gcd )		greatest common divider
                 GCD_L:
003dba 6783
003dbb 6463      		.db		NFA|3,"gcd"
                 GCD:
003dbc 01dc      		movw t5t4,TOP
003dbd 9189
003dbe 9199      		poptos
                 GCD_0:
003dbf d00b      		  rcall uslashmod0
003dc0 01cd      		  movw TOP,t5t4
003dc1 01d0      		  movw t5t4,t3t2
003dc2 2810      		or t3,t2
003dc3 f7d9      		brne GCD_0
003dc4 9508      		ret
                 
                 
003dc5 e07c      		fdw		ULESS_L
                 USLASH_L:
003dc6 7582
003dc7 ff2f      		.db		NFA|2,"u/",0xff
                 USLASH:
003dc8 01dc      		movw t5t4,TOP
003dc9 9189
003dca 9199      		poptos
                 		;rjmp uslashmod0
                 							; unsigned 16 16 -- 16 16 division
                 uslashmod0:						; (tosh:tosl) / (t5:t4) -> (tosh:tosl) (t3:t2[rem])
003dcb 2400      		clr t2
003dcc 2411      		clr t3
003dcd 94e8      		clt
                 udsm0_second:					; for t3t2 < t5t4 ONLY
003dce e008      		ldi t0,16/2
                 
                 .if optimizeNUM == 0
                 .elif optimizeNUM == 1
003dcf 23bb      		tst t5
003dd0 f569      		  brne usm0_x_16
003dd1 23aa      		tst t4
003dd2 f321      		  breq usm0_err
                 
                   usm0_x_8:						; divisorH = 0
003dd3 f09e      		brts usm0_full_8
                 							; t3t2 == 0
003dd4 2399      		tst tosh
003dd5 f489      		  brne usm0_full_8
                 
003dd6 178a      		cp tosl,t4
003dd7 f110      		  brcs usm0_below		; -> (divident < divisor)
003dd8 f421      		  brne usm0_8_8
                   ;		  breq usm0_equal		; -> (divident = divisor)
                   usm0_equal:
003dd9 01c3      		movw TOP,r_one
003dda 9508      		ret						; (uslashmod0: 15+4 for divident = divisor, both < 0x0100)
                 								; (            14+4 for divident = divisor, both > 0x0100)
                 	usm0_8_8_zero:
003ddb 950a      		dec t0
003ddc f049      		breq usm0_8_8_done
                   usm0_8_8:						; (divident > divisor)
                 	usm0_8_8_loop:
003ddd 0f88      		  lsl tosl
003dde 1c00      		  rol t2
003ddf f010      		    brcs usm0_8_8_one
003de0 160a      		  cp t2,t4
003de1 f3c8      		  brcs usm0_8_8_zero
                 	usm0_8_8_one:
003de2 1a0a      		    sub t2,t4
003de3 9583      			inc tosl
                 	usm0_8_8_next:
003de4 950a      		dec t0
003de5 f7b9      		brne usm0_8_8_loop
                 	usm0_8_8_done:
                 		;push_t3t2				; remainder in t3t2
003de6 9508      		ret						; (uslashmod0: 79..95+4 for divident + divisor < 0x0100)
                 
                   usm0_full_8:
                   ;		ldi t0,16/2				; 2-bit loop (save 10..24 ticks using 8 words)
                 	usm0_full_8_loop:
003de7 0f88      		  lsl tosl
003de8 1f99      		  rol tosh
003de9 1c00      		  rol t2
003dea f010      		    brcs usm0_full_8_one1
003deb 160a      		  cp t2,t4
003dec f010      		  brcs usm0_full_8_bit2
                 	usm0_full_8_one1:
003ded 1a0a      			sub t2,t4
003dee 9583      			inc tosl
                 	
                 	usm0_full_8_bit2:
003def 0f88      		  lsl tosl
003df0 1f99      		  rol tosh
003df1 1c00      		  rol t2
003df2 f010      		    brcs usm0_full_8_one2
003df3 160a      		  cp t2,t4
003df4 f010      		  brcs usm0_full_8_next
                 	usm0_full_8_one2:
003df5 1a0a      			sub t2,t4
003df6 9583      			inc tosl
                 	usm0_full_8_next:
003df7 950a      		dec t0
003df8 f771      		brne usm0_full_8_loop
                 
                 		;push_t3t2				; remainder in t3t2
003df9 9508      		ret						; (uslashmod0: 146..164+4 for divisor < 0x0100)
                 
                   usm0_below:
003dfa 010c      		movw t3t2,TOP			
003dfb 2788      		clr tosl
003dfc 2799      		clr tosh
003dfd 9508      		ret						; (uslashmod0: 17+4 for divident < divisor, both < 0x0100)
                 								; (            15+4 for divident < divisor, both > 0x0100)
                   usm0_x_16:					; divisorH > 0
003dfe f09e      		brts usm0_full_16
                 								
003dff 178a      		cp  tosl,t4
003e00 079b      		cpc tosh,t5
003e01 f3c0      		  brcs usm0_below		; -> (divident < divisor)
003e02 f2b1      		  breq usm0_equal		; -> (divident = divisor)
                 								; (divident > divisor)
                   usm0_16_16:		
003e03 2e09      		mov t2,tosh			; .. (t3t2==0) -> 8<< (fast shift first 8)
003e04 2799      		clr tosh
                 	;	ldi t0,16-8
                 	usm0_16_16_loop:
003e05 0f88      		  lsl tosl
003e06 1c00      		  rol t2
003e07 1c11      		  rol t3
003e08 f018      		    brcs usm0_16_16_one
003e09 160a      		  cp  t2,t4
003e0a 061b      		  cpc t3,t5
003e0b f018      		  brcs usm0_16_16_next
                 	usm0_16_16_one:
003e0c 1a0a      		    sub t2,t4
003e0d 0a1b      			sbc t3,t5
003e0e 9583      			inc tosl
                 	usm0_16_16_next:
003e0f 950a      		dec t0
003e10 f7a1      		brne usm0_16_16_loop
                 		; push_t3t2				; remainder in t3t2
003e11 9508      		ret						; (uslashmod0: 100..116+4 for divisor > 0x00ff)
                 .endif ;(optimizeNUM == 1)
                 
                 usm0_full_16:
                 	usm0_full_16_loop:			; 2-bit loop (save 10..24 ticks using 11 words)
003e12 0f88      		  lsl tosl
003e13 1f99      		  rol tosh
003e14 1c00      		  rol t2
003e15 1c11      		  rol t3
003e16 f018      			brcs usm0_full_16_one1
003e17 160a      		  cp t2,t4
003e18 061b      		  cpc t3,t5
003e19 f018      		  brcs usm0_full_16_bit2
                 	usm0_full_16_one1:
003e1a 1a0a      			sub t2,t4
003e1b 0a1b      			sbc t3,t5
003e1c 9583      			inc tosl
                 
                 	usm0_full_16_bit2:
003e1d 0f88      		  lsl tosl
003e1e 1f99      		  rol tosh
003e1f 1c00      		  rol t2
003e20 1c11      		  rol t3
003e21 f018      			brcs usm0_full_16_one2
003e22 160a      		  cp t2,t4
003e23 061b      		  cpc t3,t5
003e24 f018      		  brcs usm0_full_16_next
                 	usm0_full_16_one2:
003e25 1a0a      			sub t2,t4
003e26 0a1b      			sbc t3,t5
003e27 9583      			inc tosl
                 	usm0_full_16_next:
003e28 950a      		dec t0
003e29 f741      		brne usm0_full_16_loop
                 	usm0_full_16_done:
                 		; push_t3t2				; remainder in t3t2
003e2a 9508      		ret						; (uslashmod0: 177..209+4 for divisor > 0x00ff)
                 
                 
003e2b ed30      		fdw		COLON_L
                 SLASH_L:
003e2c 2f81      		.db		NFA|1,"/"
                 ;SLASH:
003e2d 01dc      		movw t5t4,TOP			; divisor
003e2e 9189
003e2f 9199      		poptos					; divident
003e30 2f0b      		mov t0,t5
003e31 2709      		eor t0,tosh
003e32 930f      		push t0					; save 'sign xor sign'
003e33 fd97      		sbrc tosh,7
003e34 dc6f      		  rcall NEGATE
003e35 23bb      		tst t5
003e36 f41a      		brpl SLASH_1
003e37 95a0      		  com t4
003e38 95b0      		  com t5
003e39 9611      		  adiw t5t4,1
                 SLASH_1:
003e3a df90      		rcall uslashmod0
                 
003e3b 910f      		pop t0					; resulting sign
003e3c fd07      		sbrc t0,7
003e3d cc66      		  rjmp NEGATE
003e3e 9508      		ret
                 
                 
003e3f dfe0      		fdw		CQUOTE_L
                 PLUSSTORE_L:
003e40 2b82
003e41 ff21      		.db		NFA|2,"+!",0xff
                 ;PLUSSTORE:
                 /*	movw Z,TOP
                 	cpi ZH,HIGH(PEEPROM)
                 	  brcc PLUSSTORE_1
                 	pop_t1t0
                 	ld tosl,Z+
                 	ld tosh,Z+
                 	add tosl,t0
                 	adc tosh,t1
                 	st -Z,tosh
                 	st -Z,tosl
                 	poptos
                 	ret
                 PLUSSTORE_1:
                 		 rcall FETCH1			; leaves valid Z+2
003e42 dec9      */		rcall FETCH
003e43 9732      		sbiw Z,2
003e44 9109
003e45 9119      		pop_t1t0
003e46 0f80      		add tosl,t0
003e47 1f91      		adc tosh,t1
003e48 9468      		set						; write word
003e49 cede      		rjmp STORE_Z
                 
                 
003e4a d9a0      		fdw		MCFETCH_L
                 MAX_L:
003e4b 6d83
003e4c 7861      		.db		NFA|3,"max"
                 MAX:
003e4d 9109
003e4e 9119      		 pop_t1t0				; NEXT
                 ;MAX_0:
003e4f 01f8      		 movw t7t6,t1t0
003e50 27f9      		 eor t7,tosh
003e51 01f8      		 movw t7t6,t1t0
003e52 f012      		   brmi MAX_1
003e53 1be8      		 sub t6,tosl			; NEXT-TOP
003e54 0bf9      		 sbc t7,tosh
                 MAX_1:
003e55 fff7      		 sbrs t7,7				; -> max = TOP
003e56 01c8      		   movw TOP,t1t0		; max = NEXT
003e57 9508      		 ret
                 
                 
003e58 fb64      		fdw		MOD_L
                 MIN_L:
003e59 6d83
003e5a 6e69      		.db		NFA|3,"min"
                 MIN:
003e5b 9109
003e5c 9119      		 pop_t1t0				; NEXT
                 ;MIN_0:
003e5d 01fc      		 movw t7t6,TOP
003e5e 27f1      		 eor t7,t1				; check signs
003e5f 01fc      		 movw t7t6,TOP
003e60 f012      		   brmi MIN_1			; -> different signs
003e61 1be0      		 sub t6,t0				; TOP-NEXT
003e62 0bf1      		 sbc t7,t1
                 MIN_1:
003e63 fff7      		 sbrs t7,7				; -> min = TOP
003e64 01c8      		   movw TOP,t1t0		; min = NEXT
003e65 9508      		 ret
                 
                 
003e66 dffa      		fdw		EXIT_L
                 ; EMIT ( c -- )					output character to the UEMIT vector
                 EMIT_L:
003e67 6584
003e68 696d
003e69 ff74      		.db		NFA|4,"emit",0xff
                 EMIT:
003e6a e108      		ldi t0,(-uemit)
                 UEXECUTE:
003e6b 01d1      		movw X,UP
003e6c 1ba0      		sub XL,t0
003e6d 09b7      		sbc XH,r_zero
003e6e 91ed      		ld ZL,X+
003e6f 91fd      		ld ZH,X+
003e70 c013      		rjmp EXECUTE_0			; 7 / 15
                 
                 
003e71 ebda      		fdw		DOLIT_L
                 ; KEY  ( -- c )					get char from UKEY vector
                 KEY_L:
003e72 6b83
003e73 7965      		.db		NFA|3,"key"
                 KEY:
003e74 e106      		ldi t0,(-ukey)
003e75 cff5      		rjmp UEXECUTE			; 2 / 17
                 
                 
                 .if CPU_LOAD == 0
                 .elif CPU_LOAD == 1
003e76 f4c4      		fdw		LOAD_L
                 .else .error "illegal value: CPU_LOAD"
                 .endif
                 ; KEY  ( -- c )					check for char from UKEYQ vector
                 KEYQ_L:
003e77 6b84
003e78 7965
003e79 ff3f      		.db		NFA|4,"key?",0xff
                 KEYQ:
003e7a e104      		ldi t0,(-ukeyq)
003e7b cfef      		rjmp UEXECUTE			; 2 / 17
                 
                 
003e7c eea4      		fdw		INLINED_L
                 EXECUTE_L:
003e7d 6587
003e7e 6578
003e7f 7563
003e80 6574      		.db		NFA|7,"execute"
                 EXECUTE:
003e81 01fc      		movw Z,TOP
003e82 9189
003e83 9199      		poptos
                 EXECUTE_0:
003e84 58f0      		sub_pflash_z
003e85 95f6      		lsr ZH
003e86 95e7      		ror ZL
003e87 9409      		mijmp					; 7 / 10
                 
                 
003e88 f598      		fdw		BRACTICK_L
                 FEXECUTE_L:
003e89 4083
003e8a 7865      		.db		NFA|3,"@ex"
                 FEXECUTE:
003e8b de80      		rcall FETCH
003e8c cff4      		rjmp EXECUTE
                 
                 
                 ;*************************************************************
                 ISTORERR:				; write access to kernel
003e8d d94a      		rcall DOTS
003e8e d900      		rcall XSQUOTE
003e8f 4103
003e90 3f44      		.db 3,"AD?"
003e91 d95b      		rcall TYPE
003e92 940c 35ae 		jmp ABORT
                 		
                 ; Coded for max 256 byte pagesize !
                 ; if ((ibaselo != (iaddrlo & ~(PAGESIZEB-1))) | (ibaseH != iaddrh) | (ibaseu != iaddru))
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo & ~(PAGESIZEB-1)
                 ;   ibasehi = iaddrhi
                 ;endif
                 IUPDATEBUF:
003e94 58f0      		sub_pflash_Z
                 	.ifdef  RAMPZ
                 	.endif
                 ;XUPDATEBUF:
003e95 93e0 02c4 		sts iaddrl,ZL
003e97 93f0 02c5 		sts iaddrh,ZH
                 	.ifdef RAMPZ
                 	.endif
003e99 32ea      		cpi ZL, LOW(FLASH_HI-PFLASH+1) ; don't allow kernel writes
003e9a e517      		ldi t1,HIGH(FLASH_HI-PFLASH+1)
003e9b 07f1      		cpc ZH,t1
003e9c f780      		  brcc ISTORERR
                 XUPDATEBUF2:	
003e9d 78e0      		andi ZL,~(PAGESIZEB-1)
003e9e 15ec      		cp  ZL,ibaseL
003e9f 05fd      		cpc ZH,ibaseH
003ea0 f409      		  brne IFILL_BUFFER
                 	.ifdef RAMPZ
                 	.endif
003ea1 9508      		ret
                 
                 IFILL_BUFFER:
003ea2 99f1      		sbic FLAGS3, idirty
003ea3 d014      		  rcall IWRITE_BUFFER
003ea4 9100 02c4 		lds t0,iaddrl
003ea6 7800      		andi t0,~(PAGESIZEB-1)
003ea7 2ec0      		mov ibaseL,t0
003ea8 90d0 02c5 		lds ibaseH,iaddrh
                 	.ifdef RAMPZ
                 	.endif
                 IFILL_BUFFER_1:					; fill buffer from FLASH
003eaa ef0f      		ldi t0,0xff
003eab 01f6      		movw Z,IBASE
003eac e0a0
003ead e0b2      		ldi16 X,ibuf				; ibuf on page boundary !!
                 IFILL_BUFFER_2:
003eae 9115      		  lpm_ t1,Z+
003eaf 931d      		  st X+,t1
003eb0 2301      		  and t0,t1					; check for programmed bytes
003eb1 38a0      		  cpi XL, LOW(ibuf+PAGESIZEB)	; ibuf on page boundary !!
003eb2 f7d9      		brne IFILL_BUFFER_2
                 		
003eb3 98f0      		cbi FLAGS3,fFLASH_PAGE_CLEAR
003eb4 3f0f      		cpi t0,0xff
003eb5 f409      		brne PC+2
003eb6 9af0      		  sbi FLAGS3,fFLASH_PAGE_CLEAR	; all bytes in page = 0xff -> don't need to erase page
                 
                 	.ifdef RAMPZ
                 	.endif
003eb7 9508      		ret
                 
                 IWRITE_BUFFER:
                 	.if OPERATOR_UART == 0
                 	  .if U0FC_TYPE == 1
                 	  .elif U0FC_TYPE == 2
                 	  .endif
                 	.else  ;; UART1
                 	  .if U1FC_TYPE == 1
                 	  .elif U1FC_TYPE == 2
                 	  .endif
                 	.endif
                 
                 	.ifdef RAMPZ
                 	.endif
                 
003eb8 99f9
003eb9 cffe      IWR_BUF_waitEE:	 sbic EECR,EEPE		rjmp IWR_BUF_waitEE	; EEPROM write in progress?
                 
                 	.if DEBUG_FLASH == 1
                 	.endif
                 		
                 ;		push R0
                 ;		push R1
003eba 934f      		push R20				; pl (boot loader compatibility)
003ebb e0a0
003ebc e0b2      		ldi16 X,ibuf
003ebd d132      		rcall WRITE_FLASH_PAGE	; leaves Z = ibase
003ebe 914f      		pop R20
                 ;		pop R1
                 ;		pop R0
                 		
003ebf e0a0
003ec0 e0b2      		ldi16 X,ibuf			; read back and check
                 IWRITE_BUFFER2:
003ec1 9005      		  lpm_ R0,Z+
003ec2 901d      		  ld R1,X+
003ec3 1001      		  cpse R0,R1
003ec4 ccd2      		    rjmp WARM_     		; reset if write error
003ec5 38a0      		  cpi XL,LOW(ibuf+PAGESIZEB)
003ec6 f7d1      		brne IWRITE_BUFFER2
                 
003ec7 98f1      		cbi FLAGS3,idirty
003ec8 24dd
003ec9 94da      		clr ibaseH	dec ibaseH	; 'ibuf empty'-marker
                 
                 	.ifdef RAMPZ
                 	.endif
                 
                 	.if OPERATOR_UART == 0
                 	  .if U0FC_TYPE == 1
                 	  .elif U0FC_TYPE == 2
                 	  .endif
                 	.else
                 	  .if U1FC_TYPE == 1
                 	  .elif U1FC_TYPE == 2
                 	  .endif
                 	.endif
                 
                 	.if DEBUG_FLASH == 1
                 		.if   OPERATOR_UART == 0
                 		.elif OPERATOR_UART == 1
                 		.else 
                 		.endif
                 	.else	; (DEBUG_FLASH <> 1)
003eca 9508      			 ret
                 	.endif
                 
                 
                 OF_ISR_EXIT:
                 ;	 pop t3						; uncomment when programming interrupt-words
                 ;	 pop t2							; ------------------------------------------
003ecb 911f      		 pop t1
003ecc 910f      		 pop t0
003ecd 91ff      		 pop ZH					; t7	
003ece 91ef      		 pop ZL					; t6
003ecf bf3f      		 out_ SREG,SREG_intSafe
003ed0 01d2        		 movw X,X_intSafe		; t5:t4
003ed1 9518      		 reti
                 
                 
                 .if CPU_LOAD == 1
                 	MS_TIMER_LOAD:
003ed2 94e3      		inc ms_countL
003ed3 f013      		brvs MTL_0				; 128 ms load measurement intervall
003ed4 f449      		brne MTL_xxx
003ed5 94f3      		  inc ms_countH
                 	MTL_0:
003ed6 9320 02c6 		  sts load_res,loadreg
003ed8 e228      		  ldi loadreg,HIGH(CPU_LOAD_VAL / 2)	; rounding
003ed9 9320 0085 		  out_ TCNT1H,loadreg
003edb 9270 0084 		  out_ TCNT1L,r_zero
003edd 2722      		  clr loadreg			; reset load-counter
                 	MTL_xxx:
003ede bf3f      		out_ SREG,SREG_intSafe
003edf 9518      		reti
                 .elif CPU_LOAD > 1
                 .endif
                 
                 .org BOOT_START - 0x20			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 MS_TIMER_ISR:
                   .if CPU_LOAD == 0
                   .elif CPU_LOAD == 1			
003ee0 e039      		ldi INTvector,9
003ee1 9330 0081 		out_ TCCR1B,INTvector	; restart load-timer (CTC, /1)
                 
003ee3 b73f      		in_ SREG_intSafe,SREG	; (SREG_intSafe = INTvector = R19)
003ee4 cfed      		rjmp MS_TIMER_LOAD
                   .else .error "illegal value: CPU_LOAD"
                   .endif
                 
                 
                 .org BOOT_START - 0x1b			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 OF_ISR:
003ee5 012d      		movw X_intSafe,X		; t5:t4
                 	.if CPU_LOAD == 1
003ee6 e0a9      		  ldi XL,9
003ee7 93a0 0081 		  out_ TCCR1B,XL		; restart load-timer (CTC, /1)
                 	.endif
                 
003ee9 2fa3      		mov XL,INTvector
003eea b73f      		in_ SREG_intSafe,SREG	; (INTvector = SREG_intSafe = R19)
003eeb 93ef      		push ZL					; t6
003eec 93ff      		push ZH					; t7
003eed 930f      		push t0
003eee 931f      		push t1
                 ;	push t2						; uncomment when programming interrupt-words
                 ;	push t3						; ------------------------------------------
003eef e0b2      		ldi XH,HIGH(ivec)
003ef0 91ed      		ld ZL,X+
003ef1 91fd      		ld ZH,X+
003ef2 9409      		mijmp
003ef3 ffff
003ef4 ffff      	.dw 0xffff,0xffff			; ... and comment out this line
                 								; -----------------------------
                 	.if CPU_LOAD == 0
                 	.elif CPU_LOAD == 1
                 	.else .error "illegal value: CPU_LOAD"
                 	.endif
                 
                 .org BOOT_START - 0x0b			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 INTx16_VECTOR:
                   .if CPU_LOAD == 0
                   .elif CPU_LOAD == 1			; -> load-timer interrupt
                 			;in_ SREG_intSafe,SREG	; (bootloader does)
003ef5 9523      			inc loadreg			; inc load-counter
003ef6 bf3f      			out_ SREG,SREG_intSafe
003ef7 9518      			reti
                   .else .error "illegal value: CPU_LOAD"
                   .endif 
                 
                 .org BOOT_START - 0x08			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 UDRE_VECTOR:
                   .if IDLE_MODE == 0
                   .elif IDLE_MODE == 1
                 	.if CPU_LOAD == 0
                 	.elif CPU_LOAD == 1
                 	  UDRE_ISR:
003ef8 e039      			ldi INTvector,9
003ef9 9330 0081 		  	out_ TCCR1B,INTvector	; restart load-timer (CTC, /1)
003efb e938      			ldi INTvector,(1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
003efc 9330 00c1 			out_ UCSR0B,INTvector	; disable UDRE0-interrupt
003efe 9518      			reti
                 	.else .error "illegal value: CPU_LOAD" 
                 	.endif  ; (CPU_LOAD)
                   .else .error "illegal value: IDLE_MODE"
                   .endif	; (IDLE_MODE)
                 
                 .org BOOT_START - 0x01			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 WARM_VECTOR:
003eff cc9a      			rjmp WARM_0
                 
                 ; ################################################################################ ;
                 ;                                                                                  ;
                 ; OptiForth bootloader                                                             ; 
                 ;                                                                                  ;
                 ; based on Optiboot (https://githib.com/Optiboot/optiboot)                         ;
                 ;  "Although it has evolved considerably, Optiboot builds on the original work     ;
                 ;   of Jason P. Kyle (stk500boot.c), Arduino group (bootloader),                   ;
                 ;   Spiff (1K bootloader), AVR-Libc group and Ladyada (Adaboot).                   ;
                 ;                                                                                  ;
                 ;   Optiboot is the work of Peter Knight (aka Cathedrow). Despite some             ;
                 ;   misattributions, it is not sponsored or supported by any organisation          ;
                 ;   or company including Tinker London, Tinker.it! and Arduino.                    ;
                 ;   Maintenance of optiboot was taken over by Bill Westfield (aka WestfW) in 2011.";
                 ;                                                                                  ;
                 ; fits into 256 words of FLASH                                                     ; 
                 ;                                                                                  ;
                 ; extended functions:                                                              ;
                 ;   - save MCUSR reset status in R0                                                ;
                 ;   - increased USART speed   (250.000 baud standard)                              ;
                 ;   - read/write EEPROM                                                            ;
                 ;   - read FUSE                                                                    ;
                 ;   - read/write LOCK bits                                                         ;
                 ;   - read SIGNATURE from MCU (if enabled)                                         ;
                 ;   - read OSCCAL             (if enabled)                                         ;
                 ;                                                                                  ;
                 ; MIT License                                                                      ;
                 ;                                                                                  ;
                 ; Copyright (c) 2020 bitflipser                                                    ;
                 ;                                                                                  ;
                 ; Permission is hereby granted, free of charge, to any person obtaining a copy     ;
                 ; of this software and associated documentation files (the "Software"), to deal    ;
                 ; in the Software without restriction, including without limitation the rights     ;
                 ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell        ;
                 ; copies of the Software, and to permit persons to whom the Software is            ;
                 ; furnished to do so, subject to the following conditions:                         ;
                 ;                                                                                  ;
                 ; The above copyright notice and this permission notice shall be included in all   ;
                 ; copies or substantial portions of the Software.                                  ;
                 ;                                                                                  ;
                 ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR       ;
                 ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,         ;
                 ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE      ;
                 ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER           ;
                 ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,    ;
                 ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    ;
                 ; SOFTWARE.                                                                        ;
                 ;                                                                                  ;
                 ; ################################################################################ ;
                 
                 ; 1 - ###############
                 ;     select MCU type
                 
                 ; ######### tested for ATmega328/P ONLY ###########
                 .equ ATmega =328
                 ; #################################################
                 
                 ; 2 - ###################
                 ;     select MCU sub type
                 
                 ;.equ subType=0			; no letter
                 ;.equ subType=1			; A
                 ;.equ subType=2			; L
                 .equ subType=3			; P
                 ;.equ subType=4			; PA
                 ;.equ subType=5			; V
                 
                 ; 3 - ################
                 ;     select frequency
                 
                 ;.equ F_CPU=20			; 20 MHz
                 .equ F_CPU=16			; 16 MHz
                 ;.equ F_CPU=10			; 10 MHz
                 ;.equ F_CPU= 8			;  8 MHz
                 ;.equ F_CPU= 1			;  1 MHz
                 
                 ; 4 - ##############
                 ;     select Vtarget
                 
                 .equ Vtarget =50		; 5,0 V
                 ;.equ Vtarget =33		; 3,3 V
                 ;.equ Vtarget =xy		; x,y V - set value
                 
                 ; 5 - ##############################################
                 ;     select standard or high-speed USART connection
                 
                 ;.equ USARTspeed=0			; standard baud rates 
                 .equ USARTspeed=1			; increased USART speed, better timing accuracy
                 
                 ; 6 - ########################
                 ;     select Watchdog Time Out
                 
                 ;.equ WDtimeOut = 0x0c		; 250 ms
                 ;.equ WDtimeOut = 0x0d		; 500 ms
                 .equ WDtimeOut = 0x0e		;   1 s
                 ;.equ WDtimeOut = 0x0f		;   2 s
                 ;.equ WDtimeOut = 0x28		;   4 s
                 ;.equ WDtimeOut = 0x29		;   8 s
                 
                 ; 7 - ######################
                 ;     memory saving specials
                 
                 .equ noADDRpreset		 =1	; uncomment to save  2 words: (it's not needed with avrdude)
                 .equ noLED_START_FLASH	 =1	; uncomment to save 14 words: LED will NOT blink at start
                 .equ noVtarget			 =1	; uncomment to save  4 words: Vtarget-reply will be 2.0 V
                 .equ noOSCCAL			 =1	; uncomment to save  5 words: STK_READ_OSCCAL will return 0
                 .equ noSIGfromMCU		 =1	; uncomment to save 10 words: SIGNATURE taken from bootloader code instead of MCU
                 ;   includes noOSCCAL=1
                 
                 ; 8 - ###################
                 ;     set LED port values
                 
                 .equ LED_DDR=DDRB
                 .equ LED_PORT=PORTB
                 .equ LED_PIN=PINB
                 .equ LEDpin=5
                 
                 
                 .equ SIG_1=0x1e
                 
                 .if ATmega == 328
                 	.set SIG_2=0x95
                 	.if subType==0
                 	.elif subType==3
                 		.equ SIG_3=0x0f
                 		.LIST
                 	.else
                 	.endif
                 .endif
                 
                 .if F_CPU == 20
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 	.endif
                 .endif
                 
                 .if F_CPU == 16
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 		; high-speed baud rates
                 		.set Baud = 0x0003				;  250.000 baud:  0,0%
                 		;.set Baud = 0x0001				;  500.000 baud:  0,0%
                 		;.set Baud = 0x0000				;1.000.000 baud:  0,0%
                 		.set doubleSpeed = 0
                 	.endif
                 .endif
                 
                 .if F_CPU == 10
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 	.endif
                 .endif
                 
                 .if F_CPU == 8
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 	.endif
                 .endif
                 
                 .if F_CPU == 1
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 	.endif
                 .endif
                 
                 .equ USARTbase	= UCSR0A
                 .equ oUCSR0A	= UCSR0A-USARTbase		; register offsets to be accessed with ldd/std and Y+d
                 .equ oUCSR0B	= UCSR0B-USARTbase
                 .equ oUCSR0C	= UCSR0C-USARTbase
                 .equ oUBRR0L	= UBRR0L-USARTbase
                 .equ oUBRR0H	= UBRR0H-USARTbase
                 .equ oUDR0		= UDR0  -USARTbase
                 
                 .equ buff = 0x200						; bootloader buffer addr in SRAM - DO NOT CHANGE!!!
                 
                 .if withBOOTLOADER == 0				; w/o bootloader
                 	.equ RESET_				= BOOT_START
                 	.equ DO_PAGE_ERASE		= BOOT_START + 0x34
                 	.equ DO_SPM				= BOOT_START + 0x35
                 	.equ WRITE_FLASH_PAGE	= BOOT_START + 0xf0
                 .else 								;with bootloader
                 	.if MS_TIMER_ADDR == 0x08
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x0e
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x12
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x14
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x16
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x18
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x1a
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x1c
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x1e
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x20
                 	.else
                 	.endif
                 	.if MS_TIMER_ADDR == 0x22
                 	.else
                 	.endif
                 	.if 0x26 < INT_VECTORS_SIZE
                 	  .if UDREaddr == 0x26
                 	  .else
                 	  .endif
                 	.endif
                 	.if 0x28 < INT_VECTORS_SIZE
                 	.endif
                 	.if 0x2a < INT_VECTORS_SIZE
                 	  .if MS_TIMER_ADDR == 0x2a
                 	  .else
                 	  .endif
                 	.endif
                 	.if 0x2c < INT_VECTORS_SIZE
                 	.endif
                 	.if 0x2e < INT_VECTORS_SIZE
                 	.endif
                 	.if 0x30 < INT_VECTORS_SIZE
                 	.endif
                 	.if 0x32 < INT_VECTORS_SIZE
                 	.endif
                 	.ifndef noADDRpreset
                 	.endif
                 	.if doubleSpeed == 1
                 	.endif
                 	.if Baud == 0
                 	.else
                 	.endif
                 	.ifndef noLED_START_FLASH
                 	 .if F_CPU == 16 || F_CPU == 20
                 	 .else
                 	 .endif
                 	 .if F_CPU > 1					; start TC1
                 	 .else
                 	 .endif
                 	.else
                 	.endif
                 	  .ifndef noVtarget
                 	  .else						; noVtarget == 1
                 	  .endif
                 	  .ifndef noVtarget
                 	  .else
                 	  .endif
                 	.ifndef noSIGfromMCU
                 	.else
                 	.endif
                 	.ifndef noOSCCAL
                 	 .ifndef noSIGfromMCU		
                 	  .endif
                 	.endif
                 .endif ; (appendBOOTLOADER == 1)
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328P register use summary:
r0 :  74 r1 :  52 r2 :  45 r3 :   2 r4 :   2 r5 :   0 r6 :  17 r7 :  55 
r8 :  21 r9 :   6 r10:   7 r11:   9 r12:   4 r13:   6 r14:   6 r15:   1 
r16: 387 r17: 221 r18:   5 r19:  12 r20:  20 r21:  11 r22:  52 r23:  41 
r24: 798 r25: 549 r26: 154 r27: 103 r28:   6 r29:   9 r30: 132 r31: 133 
x  :  71 y  : 575 z  : 252 
Registers used: 34 out of 35 (97.1%)

ATmega328P instruction use summary:
.lds  :   0 .sts  :   0 adc   :  50 add   :  42 adiw  :  64 and   :   7 
andi  :  32 asr   :   5 bclr  :   0 bld   :   2 brbc  :   0 brbs  :   0 
brcc  :  28 brcs  :  43 break :   0 breq  :  50 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   1 brmi  :   4 
brne  :  60 brpl  :   7 brsh  :   0 brtc  :   6 brts  :   2 brvc  :   4 
brvs  :   2 bset  :   0 bst   :   0 call  :   6 cbi   :   8 cbr   :  45 
clc   :   0 clh   :   0 cli   :  11 cln   :   0 clr   :  40 cls   :   0 
clt   :   9 clv   :   0 clz   :   0 com   :  22 cp    :  38 cpc   :  30 
cpi   :  61 cpse  :   6 dec   :  16 eor   :   9 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   1 ijmp  :   5 in    :  40 inc   :  18 jmp   :   2 
ld    : 318 ldd   :  41 ldi   : 276 lds   :  42 lpm   :  21 lsl   :  27 
lsr   :  16 mov   :  47 movw  : 154 mul   :  28 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :  25 ori   :  17 out   :  53 pop   :  70 
push  :  46 rcall : 353 ret   : 220 reti  :   4 rjmp  : 237 rol   :  24 
ror   :  36 sbc   :  59 sbci  :   8 sbi   :   9 sbic  :   9 sbis  :   1 
sbiw  :  93 sbr   :  26 sbrc  :  35 sbrs  :  22 sec   :   1 seh   :   0 
sei   :   4 sen   :   0 ser   :   2 ses   :   0 set   :  12 sev   :   0 
sez   :   0 sleep :   1 spm   :   0 st    : 357 std   :  27 sts   :  37 
sub   :  34 subi  :  50 swap  :   3 tst   :  14 wdr   :   4 
Instructions used: 79 out of 113 (69.9%)

ATmega328P memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x00572a 0x007e00   7452   2490   9942   32768  30.3%
[.dseg] 0x000100 0x0003c2      0    706    706    2048  34.5%
[.eseg] 0x000000 0x000002      0      2      2    1024   0.2%

Assembly complete, 0 errors, 23 warnings
