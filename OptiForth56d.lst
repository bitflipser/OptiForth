
AVRASM ver. 2.1.42  C:\of5.6d\avr\OptiForth56d.asm Mon Jan 10 07:19:17 2022

C:\of5.6d\avr\OptiForth56d.asm(53): Including file 'C:\of5.6d\avr\of56d_config.inc'
C:\of5.6d\avr\of56d_config.inc(24): Including file 'C:\Program Files\Atmel\AVR Tools\AvrAssembler2\Appnotes\m328pdef.inc'
C:\of5.6d\avr\OptiForth56d.asm(56): Including file 'C:\of5.6d\avr\of_macros.inc'
C:\of5.6d\avr\OptiForth56d.asm(61): warning: Register r2 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(66): warning: Register r8 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(79): warning: Register r19 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(82): warning: Register r12 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(85): warning: Register r14 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(92): warning: Register r26 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(93): warning: Register r27 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(94): warning: Register r30 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(95): warning: Register r31 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(97): warning: Register r16 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(98): warning: Register r0 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(99): warning: Register r26 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(100): warning: Register r30 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(103): warning: Register r10 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(106): warning: Register r20 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(110): warning: Register r24 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(161): warning: Use of undefined or forward referenced symbol 'TX0_' in .equ/.set
C:\of5.6d\avr\OptiForth56d.asm(162): warning: Use of undefined or forward referenced symbol 'RX0_' in .equ/.set
C:\of5.6d\avr\OptiForth56d.asm(163): warning: Use of undefined or forward referenced symbol 'RX0Q' in .equ/.set
C:\of5.6d\avr\OptiForth56d.asm(1725): warning: Register r16 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(1726): warning: Register r16 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(1727): warning: Register r16 already defined by the .DEF directive
C:\of5.6d\avr\OptiForth56d.asm(1728): warning: Register r26 already defined by the .DEF directive
                 
                 
                 ;                                                                                  *
                 ;    Filename:      OptiForth56d.asm                                               *
                 ;    Date:          10.01.2022                                                     *
                 ;    File Version:  5.6d                                                           *
                 ;    MCU:           Atmega328/P                                                    *
                 ;    Copyright:     bitflipser                                                     *
                 ;    Author:        bitflipser                                                     *
                 ;                                                                                  * 
                 ;***********************************************************************************
                 ; MIT License                                                                      *
                 ;                                                                                  *
                 ; Copyright (c) 2021 bitflipser                                                    *
                 ;                                                                                  *
                 ; Permission is hereby granted, free of charge, to any person obtaining a copy     *
                 ; of this software and associated documentation files (the "Software"), to deal    *
                 ; in the Software without restriction, including without limitation the rights     *
                 ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell        *
                 ; copies of the Software, and to permit persons to whom the Software is            *
                 ; furnished to do so, subject to the following conditions:                         *
                 ;                                                                                  *
                 ; The above copyright notice and this permission notice shall be included in all   *
                 ; copies or substantial portions of the Software.                                  *
                 ;                                                                                  *
                 ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR       *
                 ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,         *
                 ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE      *
                 ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER           *
                 ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,    *
                 ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    *
                 ; SOFTWARE.                                                                        *
                 ;                                                                                  *
                 ;***********************************************************************************
                 ;                                                                                  *
                 ; OptiForth is a standalone Forth system for AVR ATmega microcontrollers that can  *
                 ; flash their own flash memory.                                                    *
                 ;                                                                                  *
                 ; It is based on Mikael Nordman's FlashForth 5.0 (https://flashforth.com)          *
                 ;                                                                                  *
                 ; OptiForth includes a bootloader, that is fully Optiboot-compatible and therefore *
                 ; capable of loading Arduino sketches as well.                                     *
                 ;                                                                                  * 
                 ; Optimized and tested for the ATmega328P/Arduino UNO R3 ONLY !!                   *
                 ;                                                                                  *
                 ; Modified versions of OptiForth must be clearly marked as such, in the name of    *
                 ; this file, and in the identification displayed when OptiForth starts.            *
                 ;***********************************************************************************
                 
                 ; define the OF version date string
                 #define DATE       "10.01.2022"
                 
                 ; include the OptiForth configuration file
                 .include "of56d_config.inc"
                 
                 ;                                                                     *
                 ;    Filename:      of56d_config.inc                                  *
                 ;    Date:          10.01.2022                                        *
                 ;    MCU:           ATmega328P                                        *
                 ;    Copyright:     bitflipser                                        *
                 ;    Author:        bitflipser                                        *
                 ;                                                                     *
                 ; *********************************************************************
                 ; OptiForth is MIT licensed                                           *
                 ; *********************************************************************
                 
                 ; OptiForth device configuration for Atmega devices
                 ;
                 .LIST
                 
                 ;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                 .equ optimizeNUM		= 1 	; optimized math and numeric conversion
                 .equ optimizingCOMPILER	= 1 	; speed optimizing compiler (may increase code size)
                 ;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                 
                 ; set to 1 when the terminal program requires LF to be send with CR
                 ; (use 'Setup - Terminal... - New Line - Receive: CR' with TeraTerm)
                 .equ CR_with_LF = 0
                 
                 ; debug flash and eeprom writes
                 ; prints time [ms] for every FLASH block write, or '+' for every EEPROM byte write
                 .equ DEBUG_FLASH = 0;1
                 
                 ; set to 1 for power save when CPU is idle
                 .set IDLE_MODE = 1
                 
                 ; enable the cpu load measurement (for MS_TIMER <> 1 only, sets IDLE_MODE = 1)
                 ; ################ NO load measurement when MS_TIMER == 1 ####################
                 .set CPU_LOAD = 0;1
                 			
                 ; CPU load indicator led definitions (sets IDLE_MODE = 1)
                 .equ CPU_LOAD_LED = 0;1
                 
                 ; UART buffer sizes
                 .equ RX0_BUF_SIZE = 0x100				; !!! DO NOT CHANGE !!!
                 ;.equ RX0_OFF_FILL = RX0_BUF_SIZE - 50	; fill level for XOFF - not in use, no handshaking!!
                 
                 ; default number base
                 .equ BASE_DEFAULT = 10					; 16 = hexadecimal, 10 = decimal
                 
                 ; define the startup delay [ms] for the turnkey word
                 .equ TURNKEY_DELAY = 2000				; milliseconds
                 
                 .equ CPU_LOAD_DDR = DDRB
                 .equ CPU_LOAD_PORT= PORTB				; avr-p28: portc	arduinomega: portb	arduinouno: PORTB
                 .equ CPU_LOAD_BIT = 5					; avr-p28: pin5  	arduinomega: pin7 	arduinouno: PB5
                 .equ CPU_LOAD_LED_POLARITY = 1			; avr-p28:  0 (= low) on port turns on led 
                 										; arduino:  1 (=high) on port turns on led 
                 ; oscillator frequency in herz
                 .equ FREQ_OSC = 16000000
                 
                 ;;; UART0 configuration
                 ;;; Note: With Arduino Uno R3 and MEGA R3 the USB to serial bridge latency and queues 
                 ;;; disturb the XON/XOFF flow control. 
                 ;;; The workaround is NOT to use flow control, increase buffer size to 256 (0x100) bytes
                 ;;; and use a Terminal program capable of inserting waiting times between sending lines.
                 ;;; e.g. TeraTerm
                 ;;; In most cases 20 ms/line a sufficient.
                 .equ BAUDRATE0 = 115200             ; serial baudrate UART0
                 .equ U0FC_TYPE = 0                  ; 0 = no handshaking, (1 = XON/XOFF, 2=CTS/RTS - not in use!!)
                 
                 ;;; USER AREA sizes for the OPERATOR task
                 .equ RETURN_STACK_SIZE    = 64       ; 32 cells return stack
                 .equ PARAMETER_STACK_SIZE = 64       ; 32 cells parameter stack
                 .equ TIB_SIZE = 90                   ; 80 chars tib size + 10 chars hold area
                 
                 ; =============================================================================
                 ; =============================================================================
                 ; =============================================================================
                 ; ############## options requiring reburning of bootloader part ###############
                 ; =============================================================================
                 ; =============================================================================
                 ; =============================================================================
                 
                 .equ withBOOTLOADER	= 0;1 			; append bootloader part (needs programmer)
                 
                 ; define the UART used for the operator
                 .equ OPERATOR_UART	= 0 			; 0 or 1 (requires reburning of bootloader)
                 
                 ;;; UART1 configuration			(NOT on ATmega328/P)
                 ;.equ BAUDRATE1 = 38400              ; Serial baudrate UART1
                 ;.equ U1FC_TYPE = 1                  ; 1 = XON/XOFF, 2=CTS/RTS
                 ;.equ U1RTS_PORT= PORTD
                 ;.equ U1RTS_DDR = DDRD
                 ;.equ U1RTS_BIT = 4
                 
                 ;.equ RX1_BUF_SIZE = 32  ; 8,16,32,64
                 ;.equ RX1_OFF_FILL = 4   ; Fill level for XOFF
                 
                 ; select the timer to use for the system millisecond ticks (0, 1, 2)
                 .equ MS_TIMER = 0					; 0, 1, 2 (requires reburning of bootloader)
                 
                 ; ############### NO load measurement when MS_TIMER = 1 #####################
                 	.if MS_TIMER == 1
                 	.endif
                 ; ############################################################################
                 
                 .if (CPU_LOAD == 1) || (CPU_LOAD_LED == 1)
                 .endif
                 
                 #if defined(__ATmega2560__)
                 #elif defined(__ATmega328P__)
                 #define partstring "ATmega328P"
                 #elif defined(__ATmega328__)
                 #elif defined(__ATmega128__)
                 #elif defined(__ATmega2561__)
                 #elif defined(__ATmega644__)
                 #else
                 #endif
                 
                 .if MS_TIMER == 0
                   .ifdef OC0Aaddr
                 	.equ MS_TIMER_ADDR = OC0Aaddr
                   .else
                   .endif
                 .endif
                 
                 .if MS_TIMER == 1
                   .ifdef OC1Aaddr
                   .else
                   .endif
                 .endif
                 
                 .if MS_TIMER == 2
                   .ifdef OC2Aaddr
                   .else
                   .endif
                 .endif
                 
                 .LIST
                 
                 ; Register definitions
                   .def UP		= R2		; not in interrupt
                    .def upL		= R2		; not in interrupt
                    .def upH		= R3		; not in interrupt
                   .def r_one	= R6		; read only one
                   .def r_zero	= R7		; read only zero
                   .def #hold	= R8		; not in interrupt (used by <# # #s #>)
                   .def t8		= R8		; not in interrupt
                   .def wflags	= R9		; not in interrupt
                 
                 .if CPU_LOAD == 1
                 .else
                 	  .def t9		  = R18	; free for use
                 .endif
                 
                   .def intSafe16	=  R4 	; 16 bit, interrupt only !
                 ;   .def intSafe16L	=   R4	; interrupt only !
                 ;   .def intSafe16H	=   R5	; interrupt only !
                   .def INTvector	= R19	; interrupt only !
                   .def SREG_intSafe = R19 	; interrupt only !
                 
                   .def IBASE		= R12	; not in interrupt
                    .def ibaseL		= R12	; not in interrupt
                    .def ibaseH		= R13	; not in interrupt
                   .def MS_COUNT		= R14	; not in interrupt
                    .def ms_countL	= R14	; not in interrupt
                    .def ms_countH	= R15	; not in interrupt
                 
                   .def t0 = R16		.equ regt0   = 0x00
                   .def t1 = R17		.equ regt1   = 0x10
                   .def t2 = R0          	; not in interrupt (see 'OF_ISR' and 'OF_ISR_EXIT')
                   .def t3 = R1          	; not in interrupt (------------------------------)
                   .def t4 = R26				; XL
                   .def t5 = R27				; XH
                   .def t6 = R30				; ZL
                   .def t7 = R31				; ZH
                 
                   .def t1t0 = R16	.equ regt1t0 = 0x00		; 16-bit
                   .def t3t2 = R0							; 16-bit
                   .def t5t4 = R26	.equ regt5t4 = 0xa0		; 16-bit (=X)
                   .def t7t6 = R30	.equ regt7t6 = 0xe0		; 16-bit (=Z)
                 
                   .def A  = R10				; A register
                    .def al = R10
                    .def ah = R11
                   .def P  = R20				; P register and FOR..LOOP INDEX variable
                    .def pl = R20
                    .def ph = R21	.equ regP	= 0x40
                 
                   .def TOP  = R24	.equ regTOP = 0x80
                    .def tosl = R24	  .equ regtosl= 0x80
                    .def tosh = R25	  .equ regtosh= 0x90
                 					.equ regX	= 0xa0
                 					.equ regZ	= 0xe0
                 
                   .def FLAGS1 = R22     	; not in interrupt
                   .def FLAGS2 = R23     	; not in interrupt - used in COMPILE state only
                   .equ FLAGS3 = GPIOR0
                 
                 
                 ; symbol naming compatibility
                 ; UART0 symbols for Atmega32
                 .ifndef UCSR0A
                 .else
                 	.equ UDR0_=UDR0
                 	.equ URSEL_=0
                 .endif
                 
                 .ifndef SPMCSR
                 .endif
                 
                 .ifndef SPMEN
                 	.equ SPMEN=SELFPRGEN
                 .endif
                 
                 .ifndef EEWE
                 	.equ EEWE=EEPE
                 .endif
                 
                 .ifndef EEMWE
                 	.equ EEMWE=EEMPE
                 .endif
                 
                 .if OPERATOR_UART == 1
                 .elif OPERATOR_UART == 0
                 	.equ OP_TX_=TX0_
                 	.equ OP_RX_=RX0_
                 	.equ OP_RXQ=RX0Q
                 .endif
                 
                 #define ubrr0val (FREQ_OSC/ 8/BAUDRATE0) - 1		; double speed mode
                 #define ubrr1val (FREQ_OSC/16/BAUDRATE1) - 1
                 
                 .if FREQ_OSC < 16384000 ; Hz
                 	.equ ms_value_tmr0 = ((FREQ_OSC/1000/64) - 1)
                 	.equ ms_value_tmr1 = ((FREQ_OSC/1000) - 1)
                 	.equ ms_value_tmr2 = ((FREQ_OSC/1000/64) - 1)
                  .ifdef TCCR0B
                 	.equ ms_pre_tmr0   = 3
                  .endif
                  .ifdef TCCR0
                  .endif
                  .ifdef TCCR2B
                 	.equ ms_pre_tmr2   = 4
                  .endif
                  .ifdef TCCR2
                  .endif
                 .else 					; FREQ_OSC >= 16384000 Hz
                  .ifdef TCCR0B
                  .endif
                  .ifdef TCCR0
                  .endif
                  .ifdef TCCR2B
                  .endif
                  .ifdef TCCR2
                  .endif
                 .endif
                 
                 .equ CPU_LOAD_VAL  = (FREQ_OSC*128/100000)
                 
                 ;..............................................................................
                 ;program specific constants (literals used in code)
                 ;..............................................................................
                 ; flash page size
                 .equ PAGESIZEB = PAGESIZE*2		; page size in bytes 
                 
                 ; forth word header flags
                 .equ NFA		= 0x80			; name field mask
                 .equ IMMED		= 0x40			; immediate mask
                 .equ INLINE		= 0x20			; inline mask for 1, 2 and 3 cell code
                 .equ COMPILE	= 0x10			; compile only mask
                 .equ NFAmask	= 0x0f			; name field length mask
                 
                   .if optimizingCOMPILER == 1
                 	.equ INLINE4	= 0x20			; inline mask for 4 cell code
                 	.equ INLINE5	= 0x20			; inline mask for 5+ cell code
                   .else
                   .endif
                 
                 .equ NFAbit		= 7
                 .equ IMMEDbit	= 6
                 .equ INLINEbit	= 5
                 .equ COMPILEbit	= 4
                 
                 ; FLAGS3 (GPIOR0)
                 ;----------------
                 ;						= 7
                 ;						= 6
                 ;						= 5
                 ;						= 4
                 .equ fLEAVE 			= 3		; LEAVE encountered in DO..LOOP
                 .equ fLOCK				= 2		; write protect EEPROM and FLASH
                 .equ idirty				= 1		; flash write buffer modified
                 .equ fFLASH_PAGE_CLEAR	= 0		; actual flash page in erased state -> no need to erase before flushing buffer
                 
                 
                 ; FLAGS2 (R23)
                 ;-------------
                 .equ fSTATE			= 7		; 0 = interpret, 1 = compile
                 ;+++++++++++++ do not change the following two bit positions ++++++++++++
                 .equ fIMMED			= IMMEDbit	; (6) create an IMMEDIATE-marked word
                 .equ fINLINE		= INLINEbit ; (5) create an INLINE-marked word
                 ;+++++++++++++ do not change the upper two bit positions ++++++++++++++++
                 .equ fDOTsign		= 4		; write '-' sign 
                 .equ fWORDSall		= 3		; list all in WORDS
                 .equ fDUMPxxx		= 3		; DUMP 3-digit numbers (for base < 16)
                 .if IDLE_MODE == 1
                 	.equ fTX0pending= 2		; waiting for UDRE0 (enable UDRIE0 in 'IDLE_LOAD')
                 	.equ fIDLE		= 1		; 0 = busy, 1 = idle
                 .endif
                 .equ fLOADled		= 0		; 0 = no load-LED, 1 = load-LED on
                 
                 
                 ; FLAGS1 (R22)		; used in COMPILE-state only
                 ;-------------
                 .equ fLIT		= 7			; literal compiled
                 ;.equ noclear	= 6			; dont clear optimisation flags (replaced by doclear to save space in 'constant')
                 .equ doclear	= 6			; clear optimization flags
                 .equ idup		= 5			; use dupzeroequal instead of zeroequal
                 .equ izeroeq	= 4			; use brne instead of breq if zeroequal
                 .equ f2LIT		= 3			; 2 subsequent literals (used by '!', 'c!', 'mtst', 'mtst0', 'mset', 'mclr')
                 .equ iLITeq		= 2			; 'LIT =' compiled
                 .equ fTAILC		= 1			; prevent tail jump optimization
                 .equ icarryeq	= 0			; use brcs instead of brne
                 
                 ;;; for flow Control - not in use
                 ;.equ XON	= 0x11
                 ;.equ XOFF	= 0x13
                 
                 .equ CTRL_O	= 0x0f
                 .equ CR_	= 0x0d
                 .equ LF_	= 0x0a
                 .equ BS_	= 0x08
                 .equ TAB_	= 0x09
                 
                 ;;; memory mapping prefixes
                 .equ PRAM    = 0x0000                 ; 2 kBytes of RAM    (ATmega328)
                 .equ PEEPROM = RAMEND+1               ; 1 kBytes of EEPROM (ATmega328)
                 
                 .if (FLASHEND == 0x1ffff)             ; 128 kWords FLASH
                 .elif (FLASHEND == 0xffff)              ; 64 kWords FLASH
                 .elif (FLASHEND == 0x7fff)              ; 32 kWords FLASH
                 .elif (FLASHEND == 0x1fff)              ; 8  kWords FLASH
                 .elif (FLASHEND == 0x3fff)              ; 16 kWords FLASH (ATmega328)
                 	.equ OFLASH = 0x8000                  ; 32 kBytes available for OptiForth
                 	.equ PFLASH = OFLASH
                 	.equ RAMPZV  = 0
                 	.set KERNEL_SIZE = 0x1100
                 ;=================================================================================
                 .endif
                 
                 	.ifdef RAMPZ
                 	.endif
                 	.if CR_with_LF == 1
                 	.endif
                 	.if CPU_LOAD_LED == 1
                 	.endif
                 	.if CPU_LOAD == 1
                 	.endif
                 	.if IDLE_MODE == 1
                 		.set KERNEL_SIZE = KERNEL_SIZE +  0x1f
                 	.endif
                 	.if DEBUG_FLASH == 1
                 	.endif
                 	.if optimizeNUM == 1
                 		.set KERNEL_SIZE = KERNEL_SIZE +  0xd4
                 	.endif
                 	.if optimizingCOMPILER == 1
                 		.set KERNEL_SIZE = KERNEL_SIZE + 0x159
                 	.endif
                 
                 .equ BOOT_SIZE   =0x100
                 .equ BOOT_START  =FLASHEND   - BOOT_SIZE + 1  ; atm128: 0xff00, atm328: 0x3f00 
                 .equ KERNEL_START=BOOT_START - KERNEL_SIZE
                 
                 ;;;  high values for memory areas
                 .equ FLASH_HI  = 0xffff - (BOOT_SIZE*2) - (KERNEL_SIZE*2)
                 .equ EEPROM_HI = PEEPROM + EEPROMEND
                 .equ RAM_HI    = RAMEND
                         
                 ;;; USER AREA for the OPERATOR task
                 .equ ursize=       RETURN_STACK_SIZE
                 .equ ussize=       PARAMETER_STACK_SIZE
                 .equ utibsize=     TIB_SIZE
                 
                 ;;; user variables and area
                 .equ us0=          -28         ; start of parameter stack
                 .equ ur0=          -26         ; start of ret stack
                 .equ uemit=        -24         ; user EMIT vector
                 .equ ukey=         -22         ; user KEY vector
                 .equ ukeyq=        -20         ; user KEY? vector
                 .equ ubase=        -18         ; number Base
                 .equ utib=         -16         ; TIB address
                 .equ utask=        -14         ; task area pointer
                 .equ ulink=        -12         ; task link
                 .equ ustatus=      -10
                 .equ uflg=         -9
                 .equ usource=      -8          ; two cells
                 .equ utoin=        -4          ; input stream
                 .equ ursave=       -2          ; saved ret stack pointer
                 .equ uhp=           0          ; hold pointer
                 
                 
                 ;;; variables in EEPROM
                 .equ eeprom=       PEEPROM
                 .equ dp_start=     eeprom + 0x0000 ; TURNKEY
                 .equ dp_flash=     eeprom + 0x0002 ; FLASH dictionary pointer
                 .equ dp_eeprom=    eeprom + 0x0004 ; EEPROM dictionary pointer
                 .equ dp_ram=       eeprom + 0x0006 ; RAM dictionary pointer
                 .equ latest=       eeprom + 0x0008 ; pointer to latest dictionary word
                 .equ prompt=       eeprom + 0x000a ; deferred prompt
                 .equ ehere=        eeprom + 0x000c
                 
                 ;****************************************************
                 .dseg
                 .org SRAM_START
000100           rbuf0:        .byte RX0_BUF_SIZE		; do not move rbuf0 away from SRAM_START
000200           ibuf:         .byte PAGESIZEB			; must (!!) be placed on page boundary (0x..00)
000280           ivec:         .byte INT_VECTORS_SIZE	; must not (!!) reach into next page
                 
                 ;rx0queue:
0002b4           rbuf0_wr:    .byte 1
0002b5           rbuf0_rd:    .byte 1
0002b6           rbuf0_lv:    .byte 1
                 
                 .ifdef UCSR1A
                 .endif
                 
                 RAMvarBase:
0002b7           dpSTART:    .byte 2		.equ _dpSTART	=dpSTART -RAMvarBase
                 ; DP's and LATEST in RAM
0002b9           dpFLASH:    .byte 2		.equ _dpFLASH	=dpFLASH -RAMvarBase
0002bb           dpEEPROM:   .byte 2		.equ _dpEEPROM	=dpEEPROM-RAMvarBase
0002bd           dpRAM:      .byte 2		.equ _dpRAM		=dpRAM   -RAMvarBase
0002bf           dpLATEST:   .byte 2		.equ _dpLATEST	=dpLATEST-RAMvarBase
                 
0002c1           iaddrl:     .byte 1
0002c2           iaddrh:     .byte 1
                 
                 .ifdef RAMPZ
                 .endif
                 
                 .if CPU_LOAD == 1       
                 .endif
                 
0002c3           litbuf0:    .byte 1				; used in COMPILE-state only
                 .equ litbuf1 = GPIOR2			; used in COMPILE-state only
                 
0002c4           LEAVEadr:	.byte 2				; used in COMPILE-state only
                 .equ _LEAVEadr	=LEAVEadr -RAMvarBase
                 
                 ;cse:    .byte 1 				; current data section: 0 = FLASH, 2 = EEPROM, 4 = RAM
                 .equ cse = GPIOR1
                 ;state:   .byte 1 				; compilation state: 0 = interpret, 1 = compile
                 ;++ moved to fSTATE in FLAGS2
                 
0002c6           uvars:   .byte (-us0)
0002e2           up0:     .byte 2
0002e4           urbuf:   .byte ursize
000324           usbuf:   .byte ussize
000364           utibbuf: .byte utibsize
                 dpdata:
                 
                 .eseg
                 .org 0
000000 ff ff     		.dw 0xffff				; force first cell of EEPROM to 0xffff
                 
                 .cseg
                 .org 0						; entry from bootloader
                 ;		rjmp WARM_VECTOR		; relative jump backwards with addr wrap around 
000000 cefe      		.dw 0xcefe				; .. from 0x0000 to 0x3fff (ATmega328 ONLY)
                 
                 ;*******************************************************************
                 ; Start of kernel
                 ;*******************************************************************
                 .org KERNEL_START
                 
                 FLASHHI:
002bb4 d767      		.dw		FLASH_HI
002bb5 0cff      		.dw		EEPROM_HI
002bb6 08ff      		.dw		RAM_HI
                 
                 MEMQADDR_N:
002bb7 df4a      		fdw		ROM_N
002bb8 df56      		fdw		EROM_N
002bb9 df66      		fdw		FRAM_N
                 
                 ;;; ************************************************
                 ;;; WARM user area data
                 .equ warmlitsize= 20
                 WARMLIT:
002bba 0360      		.dw		utibbuf-4			; S0
002bbb 0323      		.dw		usbuf-1				; R0
002bbc f740      		fdw		OP_TX_
002bbd f76c      		fdw		OP_RX_
002bbe d7a4      		fdw		OP_RXQ
002bbf 000a      		.dw		BASE_DEFAULT		; BASE
002bc0 0364      		.dw		utibbuf				; TIB
002bc1 dce8      		fdw		OPERATOR_AREA		; TASK
002bc2 02e2      		.dw		up0					; Task link
                 ;;; ************************************************
                 ;;; EMPTY dictionary data
                 .equ coldlitsize=12
                 COLDLIT:
002bc3 0000      STARTV: .dw		0
002bc4 8002      DPC:    .dw		OFLASH + 2
002bc5 090c      DPE:    .dw		ehere
002bc6 03be      DPD:    .dw		dpdata
002bc7 f5f8      LW:     fdw		lastword
002bc8 e94c      STAT:   fdw		DOTSTATUS
                 ;*******************************************************************
                 
                 .if (FLASHEND == 0x1ffff)
                 		.ifdef MCUSR
                 		.else
                 		.endif
                 .endif
                 
002bc9 db1a      		fdw 	DZEROLESS_L
                 ; cwd  ( -- )				kick watchdog
                 CWD_L:
002bca 63a3
002bcb 6477      		.db		NFA|INLINE|3,"cwd"
                 ;CWD:
002bcc 95a8      		wdr
002bcd 9508      		ret
                 
                 
002bce def2      		fdw		SCAN_L
                 ; RX0?  ( -- n )				return the number of characters in queue
                 RX0Q_L:
002bcf 72a4
002bd0 3078
002bd1 ff3f      		.db		NFA|INLINE4|4,"rx0?",0xff
                 RX0Q:
002bd2 939a
002bd3 938a      		pushtos
002bd4 9180 02b6 		lds tosl,rbuf0_lv
002bd6 e090      		ldi tosh,0				; 5 / 7
002bd7 9508      		ret
                 
                 
002bd8 ef32      		fdw		 NONAME_L
                 ; /STRING ( a u n -- a+n u-n )	trim string
                 ;	swap over - >r + r> ;
                 SLASHSTRING_L:
002bd9 2f87
002bda 7473
002bdb 6972
002bdc 676e      		.db		NFA|7,"/string"
                 ;SLASHSTRING:
002bdd 01dc      		movw t5t4,TOP			; n
002bde 9189
002bdf 9199      		poptos					; u
002be0 9109
002be1 9119      		pop_t1t0				; a
002be2 1b8a      		sub tosl,t4			; u-n
002be3 0b9b      		sbc tosh,t5
002be4 0f0a      		add t0,t4				; a+n
002be5 1f1b      		adc t1,t5
002be6 931a
002be7 930a      		push_t1t0				; 11 / 17
002be8 9508      		ret
                 
                 
002be9 f566      		fdw		DINVERT_L
                 ; DECIMAL ( -- )				set number base to decimal
                 ;	#10 BASE ! ;
                 DECIMAL_L:
002bea 6487
002beb 6365
002bec 6d69
002bed 6c61      		.db		NFA|7,"decimal"
                 ;DECIMAL: 
002bee e00a      		ldi t0,0x0a
                 BASE_STORE:
002bef 01f1      		movw Z,UP
002bf0 9772      		sbiw Z,(-ubase)
002bf1 9301      		st Z+,t0
002bf2 9271      		st Z+,r_zero			; 5 / 8
002bf3 9508      		ret
                 
002bf4 f9a2      		fdw		ICCOMMA_L
                 ; HEX ( -- )					set number base to hex
                 ;	#16 BASE ! ;
                 HEX_L:
002bf5 6883
002bf6 7865      		.db		NFA|3,"hex"
                 ;HEX:
002bf7 e100      		ldi t0,0x10
002bf8 cff6      		rjmp BASE_STORE
                 
002bf9 ec8c      		fdw		CTON_L
                 ; BIN ( -- )					set number base to binary
                 ;	#2 BASE ! ;
                 BIN_L:
002bfa 6283
002bfb 6e69      		.db		NFA|3,"bin"
                 ;BIN:
002bfc e002      		ldi t0,2
002bfd cff1      		rjmp BASE_STORE
                 
                 
002bfe fbd6      		fdw		USLASHMOD_L
                 ; ticks ( -- u )				system ticks (0-ffff) in milliseconds
                 TICKS_L:
002bff 74a5
002c00 6369
002c01 736b      		.db		NFA|INLINE|5,"ticks"
                 ;TICKS:  
002c02 939a
002c03 938a      		pushtos
                 ;TICKS_0:
002c04 01c7      		movw TOP,MS_COUNT		; 3 / 5
002c05 9508      		ret
                 
                 
002c06 ebf8      		fdw		USSMOD_L
                 ; ticks= ( u -- t )				leave time in ms from u to actual ms_count
                 TICKSCOMPUTE_L:
002c07 74a6
002c08 6369
002c09 736b
002c0a ff3d      		.db		NFA|INLINE4|6,"ticks=",0xff
                 ;TICKSCOMPUTE:
002c0b 018c      		movw t1t0,TOP
002c0c 01c7      		movw TOP,MS_COUNT
002c0d 1b80      		sub tosl,t0
002c0e 0b91      		sbc tosh,t1				; 4 / 4
002c0f 9508      		ret
                 
                 	
002c10 f72c      		fdw		TURNKEY_L
                 ; ticks>n  ( x -- u x )			push system ticks to NEXT
                 TICKStoNEXT_L:
002c11 74a7
002c12 6369
002c13 736b
002c14 6e3e      		.db		NFA|INLINE|7,"ticks>n"
                 ;TICKStoNEXT:
002c15 0187      		movw t1t0,MS_COUNT
002c16 931a
002c17 930a      		push_t1t0				; 3 / 5
002c18 9508      		ret
                 
                 
002c19 0000      		.dw		0
                 ; us ( u -- )					pause for u microseconds, u > 0
                 ;	begin 1- dup while waste9 waste2 repeat drop ;
                 ; for ATmega328/p with 16 MHz
                 MICROS_L:
002c1a 7582
002c1b ff73      		.db		NFA|2,"us",0xff
                 MICROS:							; CPU ticks
002c1c 9701      		  sbiw TOP,1			; 2(2)
                 MICROS_loop:
002c1d f029      			breq MICROS_xxx		; 1(2)
002c1e d131      		  rcall waste9			; 9				(does: 'adiw TOP,1')
002c1f 95a8
002c20 95a8      		  wdr  wdr				; 2
002c21 9702      		  sbiw TOP,2			; 2 
002c22 cffa      		rjmp MICROS_loop		; 2______________16 ticks (= 1 us) per loop
                 MICROS_xxx:
002c23 9189
002c24 9199      		poptos					;  (4)
002c25 9508      		ret						;(4+4) call/ret__16 ticks for entry+exit
                 
                 
002c26 e520      		fdw 	TIBSIZE_L
                 ; SQR  ( u -- u^2 )				16-bit square
                 ; valid results for u < 256 only
                 SQUARE_L:
002c27 73a3
002c28 7271      		.db		NFA|INLINE|3,"sqr"
                 ;SQUARE:
002c29 9f88      		mul tosl,tosl
002c2a 01c0      		movw TOP,R1:R0			; 2 / 3
002c2b 9508      		ret
                 
                 
002c2c e062      		fdw		SWOP_L
                 ; SQRT  ( u -- u' )				16-bit square root
                 ; no rounding, no remainder on stack
                 SQUAREROOT_L:
002c2d 7384
002c2e 7271
002c2f ff74      		.db		NFA|4,"sqrt",0xff
                 ;SQUAREROOT:
002c30 018c      		movw t1t0,TOP
002c31 2788      		clr tosl
002c32 e890      		ldi tosh,0x80
                 SQRT_loop:
002c33 2789      		  eor tosl,tosh
002c34 9f88      		  mul tosl,tosl
002c35 1500      		  cp  t0,R0
002c36 0511      		  cpc t1,R1
002c37 f408      		  brcc PC+2
002c38 2789      			eor tosl,tosh
002c39 9596      		lsr tosh
002c3a f7c1      		brne SQRT_loop
                 
002c3b 9508      		ret
                 
                 
                 .if optimizingCOMPILER == 1
                 	cSTAR_0:						; inline code for 'cLIT *'
002c3c 01fc      			 movw t7t6,TOP
002c3d 9f0e      			 mul t0,t6
002c3e 01c0      			 movw TOP,R1:R0
002c3f 9f0f      			 mul t0,t7
002c40 0d90      			 add tosh,R0			;  5 / 7
002c41 9508      			 ret
                 .endif
                 
002c42 e0e4      		fdw		PLUS_L
                 ; 								16 x 16 bit to 16 bit multiply
                 STAR_L:
002c43 2aa1      		.db		NFA|INLINE5|1,"*"
                 STAR: 
002c44 9109
002c45 9119      		pop_t1t0
                 STAR_0:
002c46 01fc      		movw t7t6,TOP
002c47 9f0e      		mul t0,t6
002c48 01c0      		movw TOP,R1:R0
002c49 9f1e      		mul t1,t6
002c4a 0d90      		add tosh,R0
002c4b 9f0f      		mul t0,t7				;  7 / 10 for  'LIT *'
002c4c 0d90      		add tosh,R0				;  9 / 14
002c4d 9508      		ret		
                 
                 
002c4e d8b0      		fdw		outerINDEX_L
                 ; i	( -- index  R: limit index -- limit index )
                 innerINDEX_L:
002c4f 69a1      		.db		NFA|0x20|1,"i"
                 ;innerINDEX:			; ++++ must be inlined ++++
002c50 939a
002c51 938a      		pushtos
002c52 b7ed      		in ZL,SPL
002c53 b7fe      		in ZH,SPH
002c54 8182      		ldd tosl,Z+2			; index
002c55 8191      		ldd tosh,Z+1			; 6 / 10
002c56 9508      		ret
                 
                 
002c57 d93a      		fdw		LEFTBRACKET_L
                 ; j ( -- index'  R: limit' index' limit index -- limit' index' limit index )
                 outerINDEX_L:
002c58 6aa1      		.db		NFA|0x20|1,"j"
                 ;outerINDEX:			; ++++ must be inlined ++++
002c59 939a
002c5a 938a      		pushtos
002c5b b7ed      		in ZL,SPL
002c5c b7fe      		in ZH,SPH
002c5d 8186      		ldd tosl,Z+6			; index'
002c5e 8195      		ldd tosh,Z+5			; 6 / 10
002c5f 9508      		ret
                 
                 
002c60 e036      		fdw		SPACE_L
                 ; SIGN? ( addr n -- addr' n' f )	get optional sign (n<0x100)
                 ;							+ leaves $0000 flag
                 ;							- leaves $0002 flag
                 SIGNQ_L:
002c61 7385
002c62 6769
002c63 3f6e      		.db		NFA|5,"sign?"
                 ;SIGNQ:
002c64 81e8      		ldd ZL,Y+0				; addr
002c65 81f9      		ldd ZH,Y+1
002c66 2f08      		mov t0,tosl				; n
002c67 939a
002c68 938a      		pushtos					; OVER c@
                 
                 		;call CFETCH_Zplus
002c69 9181      		ld tosl,Z+				; in RAM
                 
002c6a 528b      		subi tosl,'+'
002c6b f021      		  breq SIGNQIS
002c6c 3082      		cpi tosl,2				; '-'
002c6d f011      		  breq SIGNQIS
002c6e 2788      		clr tosl
                 		;ldi tosh,0x00			; (unchanged)
002c6f 9508      		ret
                 SIGNQIS:
002c70 83fb      		std Y+3,ZH				; addr'
002c71 83ea      		std Y+2,ZL
002c72 950a      		dec t0
                 		;std Y+1,r_zero			; (unchanged)
002c73 8308      		std Y+0,t0				; n'
                 		;ldi tosh,0x00			; (unchanged)
002c74 9508      		ret
                 
                 
002c75 e09e      		fdw		TOR_L
                 TO_A_L:
002c76 3ea2
002c77 ff61      		.db		NFA|INLINE|2, ">a",0xff
                 TO_A:
002c78 015c      		movw A,TOP
002c79 9189
002c7a 9199      		poptos					; 3 / 5
002c7b 9508      		ret
                 
                 
002c7c e61e      		fdw		BL_L
                 A_FROM_L:
002c7d 61a2
002c7e ff3e      		.db		NFA|INLINE|2, "a>",0xff
                 ;A_FROM:
002c7f 939a
002c80 938a      		pushtos
                 ;A_FROM_0:
002c81 01c5      		movw TOP,A				; 3 / 5
002c82 9508      		ret
                 
                 
                 ;		.db		NFA|INLINE|3,"?0="
                 ZEROSENSE:
002c83 2b98      		or tosh,tosl
002c84 9189
002c85 9199      		poptos					; 3 / 5
002c86 9508      		ret
                 
                 
                 ; PAD ( -- a-addr )				user pad buffer
002c87 fa9e      		fdw		PCSTORE_L
                 PAD_L:
002c88 7083
002c89 6461      		.db		NFA|3,"pad"
                 ;PAD:
002c8a 939a
002c8b 938a      		pushtos
002c8c d002      		rcall PAD_pushed
002c8d 01c8      		movw TOP,t1t0
002c8e 9508      		ret
                 
                 PAD_pushed:
002c8f 01d1      		movw X,UP				; TIB 
002c90 9750      		sbiw X,(-utib)			;	( TIU @ )
002c91 910d      		ld t0,X+
002c92 911d      		ld t1,X+
002c93 91ed      		ld ZL,X+				; TIBSIZE 
002c94 91fd      		ld ZH,X+				;	( TASK @ 8 + @ )
002c95 9638      		adiw Z,8
002c96 58f0      		sub_pflash_z
002c97 91a5      		lpm t4,Z+
002c98 91b5      		lpm t5,Z+
002c99 0f0a      		add t0,t4				; +
002c9a 1f1b      		adc t1,t5
002c9b 9508      		ret						; 13 / 22+4
                 
                 
002c9c d9a4      		fdw		BSLASH_L
                 ; [ ( -- )						enter interpretive state
                 LEFTBRACKET_L:
002c9d 5bc1      		.db		NFA|IMMED|1,"["
                 ;LEFTBRACKET:
002c9e 777f      		cbr FLAGS2,(1<<fSTATE)
002c9f 9508      		ret
                 
                 
002ca0 f768      		fdw		RX0_L
                 ; RP@							fetch the return stack pointer
                 RPFETCH_L:
002ca1 72b3
002ca2 4070      		.db		NFA|INLINE|COMPILE|3,"rp@"
                 ;RPFETCH:
002ca3 939a
002ca4 938a      		pushtos
002ca5 b78d      		in tosl,spl
002ca6 b79e      		in tosh,sph				; 4 / 6
002ca7 9508      		ret
                 
                 
002ca8 edf2      		fdw		CHAR_L
                 ; CELL ( -- n )					size of one cell
                 CELL_L:
002ca9 63a4
002caa 6c65
002cab ff6c      		.db		NFA|INLINE4|4,"cell",0xff
                 ;CELL:
002cac 939a
002cad 938a      		pushtos
                 ;CELL_0:
002cae e082      		ldi tosl,2
002caf e090      		ldi tosh,0				; 4 / 6
002cb0 9508      		ret
                 
                 
002cb1 d7d4      		fdw		DECIMAL_L
                 ; ALIGNED ( addr -- a-addr )	align given addr
                 ALIGNED_L:
002cb2 61a7
002cb3 696c
002cb4 6e67
002cb5 6465      		.db		NFA|INLINE|7,"aligned"
                 ;ALIGNED:
002cb6 9601      		adiw TOP,1
002cb7 7f8e      		cbr tosl,1				; 2 / 3
002cb8 9508      		ret
                 
                 
002cb9 d980      		fdw		CELLS_L
                 ; CELL+ ( a-addr1 -- a-addr2 )	add cell size
                 ;	2 + ;
                 CELLPLUS_L:
002cba 63a5
002cbb 6c65
002cbc 2b6c      		.db		NFA|INLINE|5,"cell+"
                 ;CELLPLUS:
002cbd 9602      		adiw TOP,2				; 1 / 2
002cbe 9508      		ret
                 
                 
002cbf d98e      		fdw		CHARPLUS_L
                 ; CELLS ( n1 -- n2 )			cells->adrs units
                 CELLS_L:
002cc0 63a5
002cc1 6c65
002cc2 736c      		.db		NFA|INLINE|5,"cells"
                 ;CELLS:
002cc3 0f88      		lsl tosl
002cc4 1f99      		rol tosh				; 2 / 2
002cc5 9508      		ret
                 
                 
002cc6 d99a      		fdw		CHARS_L
                 ; CHAR+ ( c-addr1 -- c-addr2 )	add char size
                 CHARPLUS_L:
002cc7 63a5
002cc8 6168
002cc9 2b72      		.db		NFA|INLINE|5,"char+"
                 ;CHARPLUS:
002cca 9601      		adiw TOP,1				; 1 / 2
002ccb 9508      		ret
                 
                 
002ccc ec0a      		fdw		CMOVE_L
                 ; CHARS ( n1 -- n2 )			chars->adrs units
                 CHARS_L:
002ccd 63a5
002cce 6168
002ccf 7372      		.db		NFA|INLINE|5,"chars"
                 ;CHARS:
002cd0 9508      		ret
                 
                 
002cd1 ef22      		fdw		RIGHTBRACKET_L
                 ; \								skip the rest of the line
                 BSLASH_L:
002cd2 5cc1      		.db		NFA|IMMED|1,0x5c
                 ;BSLASH:
002cd3 01f1      		movw Z,UP
002cd4 9736      		sbiw Z,(-(usource+2))
002cd5 9101      		ld t0,Z+
002cd6 9111      		ld t1,Z+
                 		;adiw Z,<..utoin>		; Z already at utoin
002cd7 9301      		st Z+,t0
002cd8 9311      		st Z+,t1
002cd9 7b6f      		cbr FLAGS1,(1<<doclear)	; don't clear flags in case of \
002cda 9508      		ret
                 
                 
002cdb dc20      		fdw		MEMHI_L
                 ; ei ( -- )						enable interrupts
                 EI_L:
002cdc 65a2
002cdd ff69      		.db		NFA|INLINE|2,"ei",0xff
002cde 9478      		sei						; 1 / 1
002cdf 9508      		ret
                 
                 
002ce0 f40c      		fdw		DO_L
                 ; di  ( -- )					disable interrupts
                 DI_L:
002ce1 64a2
002ce2 ff69      		.db		NFA|INLINE|2,"di",0xff
002ce3 94f8      		cli						; 1 / 1
002ce4 9508      		ret
                 
                 
002ce5 d8c2      		fdw		SIGNQ_L
                 ; RSAVE ( -- a-addr )			saved return stack pointer
                 RSAVE_L:
002ce6 72a5
002ce7 6173
002ce8 6576      		.db		NFA|INLINE4|5,"rsave"
                 ;RSAVE_:
002ce9 939a
002cea 938a
002ceb 01c1
002cec 9702      		inline_DOUSER ursave	; 4 / 7
002ced 9508      		ret
                 
                 
002cee f324      		fdw		UNTIL_L
                 ; ULINK ( -- a-addr )			link to next task
                 ULINK_L:
002cef 75a5
002cf0 696c
002cf1 6b6e      		.db		NFA|INLINE4|5,"ulink"
                 ;ULINK_:
002cf2 939a
002cf3 938a
002cf4 01c1
002cf5 970c      		inline_DOUSER ulink		; 4 / 7
002cf6 9508      		ret
                 
                 
002cf7 f2f0      		fdw		THEN_L
                 ; TASK ( -- a-addr )			TASK pointer
                 TASK_L:
002cf8 74a4
002cf9 7361
002cfa ff6b      		.db		NFA|INLINE4|4,"task",0xff
                 ;TASK:   
002cfb 939a
002cfc 938a
002cfd 01c1
002cfe 970e      		inline_DOUSER utask		; 4 / 7
002cff 9508      		ret
                 
                 
002d00 f97e      		fdw		ICOMMA_L
                 ; HP ( -- a-addr )				HOLD pointer
                 HP_L:
002d01 68a2
002d02 ff70      		.db		NFA|INLINE|2,"hp",0xff
                 ;HP:
002d03 939a
002d04 938a      		pushtos
002d05 01c1      		movw TOP,UP				; 3 / 5
                 		;sbiw TOP,(-uhp)		; uhp = 0
002d06 9508      		ret
                 
                 
002d07 f15a      		fdw		DOTS_L
                 DOTQUOTE_L:
002d08 2ed2
002d09 ff22      		.db		NFA|IMMED|COMPILE|2,".",0x22,0xff
                 ;DOTQUOTE:
002d0a d3bb      		rcall SQUOTE
002d0b d735      		rcall DOCOMMAXT
002d0c f188      		fdw TYPE
002d0d 9508      		ret
                 
                 
                 .if IDLE_MODE == 0
                 .elif IDLE_MODE == 1
002d0e dd64      		fdw		BUSY_L
                 .else .error "illegal value: IDLE_MODE"
                 .endif
                 ; BASE ( -- a-addr )			holds conversion radix
                 BASE_L:
002d0f 62a4
002d10 7361
002d11 ff65      		.db		NFA|INLINE4|4,"base",0xff
                 ;BASE:
002d12 939a
002d13 938a
002d14 01c1
002d15 9742      		inline_DOUSER ubase		; 4 / 7
002d16 9508      		ret
                 
                 
002d17 e44e      		fdw		USER_L
                 ; umin ( u1 u2 -- u )			unsigned minimum
                 ;	2DUP U> IF SWAP THEN DROP ;
                 UMIN_L:
002d18 75a4
002d19 696d
002d1a ff6e      		.db		NFA|INLINE5|4,"umin",0xff
                 UMIN:
002d1b 9109
002d1c 9119      		pop_t1t0
                 UMIN_0:
002d1d 1780      		cp tosl,t0
002d1e 0791      		cpc tosh,t1
002d1f f008      		brcs PC+2
002d20 01c8      		  movw TOP,t1t0			; 6 / 8
002d21 9508      		ret
                 
                 
002d22 da30      		fdw		UMIN_L
                 ; umax ( u1 u2 -- u )			unsigned maximum
                 ;	2DUP U< IF SWAP THEN DROP ;
                 UMAX_L:
002d23 75a4
002d24 616d
002d25 ff78      		.db		NFA|INLINE5|4,"umax",0xff
                 UMAX:
002d26 9109
002d27 9119      		pop_t1t0
                 UMAX_0:
002d28 1708      		cp t0,tosl
002d29 0719      		cpc t1,tosh
002d2a f008      		brcs PC+2
002d2b 01c8      		  movw TOP,t1t0			; 6 / 8
002d2c 9508      		ret
                 
                 
002d2d d7f4      		fdw		BIN_L
                 AND_L:
002d2e 61a3
002d2f 646e      		.db		NFA|INLINE4|3,"and"
                 AND_:
002d30 9109
002d31 9119      		pop_t1t0
                 AND_0:
002d32 2380      		and tosl,t0
002d33 2391      		and tosh,t1				; 4 / 6
002d34 9508      		ret
                 
                 
002d35 faec      		fdw		PSTORE_L
                 OR_L:
002d36 6fa2
002d37 ff72      		.db		NFA|INLINE4|2,"or",0xff
                 OR_:
002d38 9109
002d39 9119      		pop_t1t0
                 OR_0:
002d3a 2b80      		or tosl,t0
002d3b 2b91      		or tosh,t1				; 4 / 6
002d3c 9508      		ret
                 
                 
002d3d e2a0      		fdw    STORE_P_TO_R_L
                 .ifdef RAMPZ
                 .endif
                 XOR_L:
002d3e 78a3
002d3f 726f      		.db		NFA|INLINE4|3, "xor"
                 XOR_:
002d40 9109
002d41 9119      		pop_t1t0
                 XOR_0:
002d42 2780      		eor tosl,t0
002d43 2791      		eor tosh,t1				; 4 / 6
002d44 9508      		ret
                 
                 
002d45 efc4      		fdw		LATEST_L
                 INVERT_L:
002d46 69a6
002d47 766e
002d48 7265
002d49 ff74      		.db		NFA|INLINE|6,"invert",0xff
                 ;INVERT:
002d4a 9580      		com tosl
002d4b 9590      		com tosh				; 2 / 2
002d4c 9508      		ret
                 
                 
002d4d daa6      		fdw		ONEMINUS_L
                 ONEPLUS_L:
002d4e 31a2
002d4f ff2b      		.db		NFA|INLINE|2,"1+",0xff
                 ;ONEPLUS:
                 waste9:
002d50 9601      		adiw TOP,1				; 1 / 2
002d51 9508      		ret
                 
                 
002d52 f0bc      		fdw		TWOSTORE_L
                 ONEMINUS_L:
002d53 31a2
002d54 ff2d      		.db		NFA|INLINE|2,"1-",0xff
                 ;ONEMINUS:
002d55 9701      		sbiw TOP,1				; 1 / 2
002d56 9508      		ret
                 
                 
002d57 e5ca      		fdw		TWOMINUS_L
                 TWOPLUS_L:
002d58 32a2
002d59 ff2b      		.db		NFA|INLINE|2,"2+",0xff
                 ;TWOPLUS:
002d5a 9602      		adiw TOP,2				; 1 / 2
002d5b 9508      		ret
                 
                 
002d5c ed52      		fdw		ABORT_L
                 TOBODY_L:
002d5d 3ea5
002d5e 6f62
002d5f 7964      		.db		NFA|INLINE|5,">body"
                 ;TOBODY:
002d60 9604      		adiw TOP,4				; 1 / 2
002d61 9508      		ret
                 
                 
002d62 dab0      		fdw		TWOPLUS_L
                 TWOSTAR_L:
002d63 32a2
002d64 ff2a      		.db		NFA|INLINE|2,"2*",0xff
                 ;TWOSTAR:
002d65 0f88      		lsl tosl
002d66 1f99      		rol tosh				; 2 / 2
002d67 9508      		ret
                 
                 
                 
002d68 fba4      		fdw		UDSTAR_L
                 UTWOSLASH_L:
002d69 75a3
002d6a 2f32      		.db		NFA|INLINE|3,"u2/"
                 ;UTWOSLASH:
002d6b 9596      		lsr tosh
002d6c 9587      		ror tosl				; 2 / 2
002d6d 9508      		ret
                 
                 
002d6e f016      		fdw		TWOFETCH_L
                 TWOSLASH_L:
002d6f 32a2
002d70 ff2f      		.db		NFA|INLINE|2,"2/",0xff
                 ;TWOSLASH:
002d71 9595      		asr tosh
002d72 9587      		ror tosl				; 2 / 2
002d73 9508      		ret
                 
                 
002d74 db84      		fdw		DUP_L
                 DTWOSLASH_L:
002d75 64a3
002d76 2f32      		.db		NFA|INLINE5|3,"d2/"
002d77 9109
002d78 9119      		pop_t1t0
                 ;DTWOSLASH_0:
002d79 9595      		asr tosh
002d7a 9587      		ror tosl
002d7b 9517      		ror t1
002d7c 9507      		ror t0
002d7d 931a
002d7e 930a      		push_t1t0				; 8 / 12
002d7f 9508      		ret
                 
                 
002d80 daea      		fdw		DTWOSLASH_L
                 DTWOSTAR_L:
002d81 64a3
002d82 2a32      		.db		NFA|INLINE5|3,"d2*"
002d83 9109
002d84 9119      		pop_t1t0
                 ;DTWOSTAR_0:
002d85 0f00      		lsl t0
002d86 1f11      		rol t1
002d87 1f88      		rol tosl
002d88 1f99      		rol tosh
002d89 931a
002d8a 930a      		push_t1t0				; 8 / 12
002d8b 9508      		ret
                 
                 
002d8c f582      		fdw		DZEROEQUAL_L
                 DZEROLESS_L:
002d8d 64a3
002d8e 3c30      		.db		NFA|INLINE4|3,"d0<"
                 ;DZEROLESS:
002d8f 9622      		adiw Y,2				; NIP d.l
002d90 0f99      		lsl tosh
002d91 0b88      		sbc tosl,tosl
002d92 0b99      		sbc tosh,tosh			; 4 / 5
002d93 9508      		ret
                 
                 
002d94 db34      		fdw		FUNLOCK_L
                 ;;; disable writes to FLASH and EEPROM
                 FLOCK_L:
002d95 66a3
002d96 2d6c      		.db		NFA|INLINE|3,"fl-"
002d97 9af2      		sbi FLAGS3,fLOCK		; 1 / 1
002d98 9508      		ret
                 
                 
002d99 f3d6      		fdw		FOR_L
                 ;;; enable writes to FLASH and EEPROM
                 FUNLOCK_L:
002d9a 66a3
002d9b 2b6c      		.db		NFA|INLINE|3,"fl+"
002d9c 98f2      		cbi FLAGS3,fLOCK		; 1 / 1
002d9d 9508      		ret
                 
                 ; #########################################################################
                 ; fast RAM access - do NOT use, if <adr> is a literal, constant or variable
002d9e f514      		fdw		MPLUS_L
                 MSTORE_L:
002d9f 6da2
002da0 ff21      		.db		NFA|INLINE5|2,"m!",0xff
                 MSTORE:
002da1 01fc      		movw Z,TOP
002da2 9189
002da3 9199      		poptos
002da4 8391      		std Z+1,tosh
002da5 8380      		std Z+0,tosl
002da6 9189
002da7 9199      		poptos					; 7 / 13
002da8 9508      		ret
                 
                 
002da9 faf8      		fdw		MS_L
                 MFETCH_L:
002daa 6da2
002dab ff40         	    .db		NFA|INLINE|2,"m@",0xff
                 MFETCH:
002dac 01fc      		movw Z,TOP
002dad 9181      		ld tosl,Z+
002dae 9191      		ld tosh,Z+				; 3 / 5
002daf 9508      		ret
                 
                 
002db0 fd3a      		fdw		MIN_L
                 MCFETCH_L:
002db1 6da3
002db2 4063         	    .db		NFA|INLINE|3,"mc@"
                 MCFETCH:
002db3 01fc      		movw Z,TOP
002db4 9181      		ld tosl,Z+
002db5 e090      		ldi tosh,0x00			; 3 / 4
002db6 9508      		ret
                 
                 
002db7 db62      		fdw		MCFETCH_L
                 MCSTORE_L:
002db8 6da3
002db9 2163      		.db		NFA|INLINE5|3,"mc!"
                 MCSTORE:
002dba 01fc      		movw Z,TOP
002dbb 9189
002dbc 9199      		poptos
002dbd 8380      		st Z,tosl
002dbe 9189
002dbf 9199      		poptos					; 6 / 11
002dc0 9508      		ret
                 ; #########################################################################
                 
002dc1 dd70      		fdw		FCY_L
                 ; DUP must not be reachable from user code with rcall
                 DUP_L:
002dc2 64a3
002dc3 7075      		.db		NFA|INLINE|3, "dup"
                 DUP:
002dc4 939a
002dc5 938a      		duptos					; 2 / 4
002dc6 9508      		ret
                 
                 
002dc7 da9c      		fdw		ONEPLUS_L
                 ZEROEQUAL_L:
002dc8 30a2
002dc9 ff3d      		.db		NFA|INLINE|2, "0=",0xff
                 ZEROEQUAL:
002dca 9701      		sbiw    TOP, 1
002dcb 0b88      		sbc     tosl, tosl
002dcc 0b99      		sbc     tosh, tosh		; 3 / 4
002dcd 9508      		ret
                 
                 
002dce db90      		fdw		ZEROEQUAL_L
                 ZEROLESS_L:
002dcf 30a2
002dd0 ff3c      		.db		NFA|INLINE|2, "0<",0xff
                 ZEROLESS:
002dd1 0f99      		lsl     tosh
002dd2 0b88      		sbc     tosl, tosl
002dd3 0b99      		sbc     tosh, tosh		; 3 / 3
002dd4 9508      		ret
                 
                 
002dd5 dbd6      		fdw		XA_FROM_L
                 ; store the execution vector addr to the return stack
                 ; leave the updated return stack pointer on the data stack
                 ; x>r ( addr rsp -- rsp' )
                 X_TO_R_L:
002dd6 7883
002dd7 723e      		.db		NFA|3,"x>r"
                 ;X_TO_R:
002dd8 01fc      		movw Z,TOP
002dd9 9189
002dda 9199      		poptos
002ddb 5890      		sub_pflash_tos
002ddc 9596      		lsr tosh
002ddd 9587      		ror tosl
002dde 8380      		st  Z,tosl
002ddf 9392      		st -Z,tosh
                 .ifdef EIND
                 .endif
002de0 9272      		st -Z,r_zero
002de1 01cf      		movw TOP,Z
002de2 9508      		ret
                 
                 
002de3 fd9a      		fdw		FEXECUTE_L
                 TO_XA_L:
002de4 3ea3
002de5 6178      		.db NFA|INLINE|3,">xa"
                 ;TO_XA:
002de6 5890      		sub_pflash_tos
                 		;rampv_to_c
                 		;ror tosh
002de7 9596      		lsr tosh
002de8 9587      		ror tosl				; 3 / 3
002de9 9508      		ret
                 
                 
002dea da7c      		fdw		XOR_L
                 XA_FROM_L:
002deb 78a3
002dec 3e61      		.db NFA|INLINE|3,"xa>"
                 ;XA_FROM:
002ded 0f88      		lsl tosl
002dee 1f99      		rol tosh
002def 5890      		add_pflash_tos			; 3 / 3
002df0 9508      		ret
                 
                 
002df1 e2b4      		fdw    R_TO_P_L
                 PFL_L:
002df2 7083
002df3 6c66      		.db		NFA|3,"pfl"
                 ;PFL:
002df4 d641      		rcall DOCREATE
002df5 8000      		.dw OFLASH
                 
                 
002df6 ea3e      		fdw		FALSE_L
                 ; leave clear top of return stack
                 ENDIT_L:
002df7 65b5
002df8 646e
002df9 7469      		.db		NFA|COMPILE|0x20|5,"endit"
                 ;ENDIT:						; ++++ must be inlined ++++
002dfa b7fe      		in ZH,SPH
002dfb b7ed      		in ZL,SPL
002dfc 8271      		std Z+1,r_zero
002dfd 8272      		std Z+2,r_zero			; 4 / 6
002dfe 9508      		ret
                 
                 
002dff d9cc              fdw		 RSAVE_L
                 ; RDROP compile a pop
                 RDROP_L:
002e00 72b5
002e01 7264
002e02 706f              .db		NFA|COMPILE|0x20|5,"rdrop"
                 ;RDROP:						;++++ must be inlined ++++
002e03 910f              pop     t0
002e04 910f              pop     t0				; 2 / 4
002e05 9508              ret
                 
                 
002e06 f024              fdw		SHB_L
                 STOD_L:
002e07 73a3
002e08 643e              .db		NFA|INLINE5|3,"s>d"
                 ;STOD:
002e09 939a
002e0a 938a              duptos
002e0b 0f99              lsl tosh				; mov sign to C
002e0c 0b88              sbc tosl,tosl
002e0d 0b99      		sbc tosh,tosh			; 5 / 7
002e0e 9508      		ret
                 
                 
002e0f da02              fdw		 HP_L
                 MEMHI_L:
002e10 6882
002e11 ff69              .db		NFA|2,"hi",0xff
                 ;MEMHI:
002e12 939a
002e13 938a      		pushtos
                 ;MEMHI_0:
002e14 b5ea      		in ZL,cse
002e15 27ff      		clr ZH
002e16 59e8      		subi ZL, LOW(-(FLASHHI<<1))
002e17 4af8      		sbci ZH,HIGH(-(FLASHHI<<1))
002e18 9185      		lpm tosl,Z+
002e19 9195      		lpm tosh,Z+
002e1a 9508      		ret
                 
                 
002e1b d8fa              fdw		 A_FROM_L
                 L_FETCH_P:
002e1c 40a2
002e1d 0070              .db      NFA|INLINE|2,"@p", 0
                 ;FETCH_P:
002e1e 939a
002e1f 938a              pushtos
                 ;FETCH_P_0:
002e20 01ca              movw TOP,P				; 3 / 5
002e21 9508              ret
                 
                 
002e22 d910              fdw		 PAD_L
                 ; P2+  ( n -- )					add 2 to P
                 L_PTWOPLUS:
002e23 70a3
002e24 2b32              .db		NFA|INLINE|3,"p2+"
                 ;PTWOPLUS:
002e25 5f4e      		subi pl,-2
002e26 4f5f      		sbci ph,-1				; 2 / 2
002e27 9508              ret
                 
                 
002e28 f73c              fdw		TX0_L
                 ; TIU  ( -- a-addr )			Terminal Input Buffer user variable 
                 TIU_L:
002e29 74a3
002e2a 7569              .db		NFA|INLINE4|3,"tiu"
                 ;TIU:
002e2b 939a
002e2c 938a
002e2d 01c1
002e2e 9740      		inline_DOUSER utib		; 4 / 7
002e2f 9508      		ret
                 
                 
002e30 e2c0              fdw		TO_PRINTABLE_L
                 ; >IN  ( -- a-addr )			holds offset into TIB
                 ; in RAM
                 TOIN_L:
002e31 3ea3
002e32 6e69              .db		NFA|INLINE4|3,">in"
                 TOIN:
002e33 939a
002e34 938a
002e35 01c1
002e36 9704      		inline_DOUSER utoin		; 4 / 7
002e37 9508      		ret
                 
                 
002e38 d7b2              fdw		SLASHSTRING_L
                 ; 'SOURCE ( -- a-addr )			two cells: len, adrs
                 ; in RAM
                 TICKSOURCE_L:
002e39 27a7
002e3a 6f73
002e3b 7275
002e3c 6563              .db		NFA|INLINE4|7,"'source"
                 ;TICKSOURCE: 				; two cells !!!!!!
002e3d 939a
002e3e 938a
002e3f 01c1
002e40 9708      		inline_DOUSER usource	; 4 / 7
002e41 9508      		ret
                 
                 
002e42 fade              fdw		PFETCH_L
                 PPLUS_L:
002e43 70a2
002e44 ff2b              .db		NFA|INLINE|2,"p+",0xff
                 ;PPLUS:
002e45 0d46              add pl,r_one
002e46 1d57              adc ph,r_zero			; 2 / 2
002e47 9508              ret   
                 
                 
002e48 dc46              fdw		L_PTWOPLUS
                 PNPLUS_L:
002e49 70a3
002e4a 2b2b              .db		NFA|INLINE4|3,"p++"
                 ;PNPLUS:
002e4b 0f48              add pl,tosl
002e4c 1f59              adc ph,tosh
002e4d 9189
002e4e 9199              poptos					; 4 / 6
002e4f 9508              ret
                 
                 
002e50 dcc6              fdw		UKEYQ_L
                 UEMIT_L:
                 kernellink_long:
002e51 27a5
002e52 6d65
002e53 7469              .db		NFA|INLINE4|5,"'emit"
                 ;UEMIT_:
002e54 939a
002e55 938a      		pushtos
                 UEMIT_0:
002e56 01c1      		movw TOP,UP
002e57 9748      		sbiw TOP,(-uemit)		; 4 / 7
002e58 9508      		ret
                 
                         
002e59 dffc              fdw		TWODUP_L
                 UKEY_L:
002e5a 27a4
002e5b 656b
002e5c ff79              .db		NFA|INLINE4|4,"'key",0xff
                 ;UKEY_:
002e5d 939a
002e5e 938a      		pushtos
                 UKEY_0:
002e5f 01c1      		movw TOP,UP
002e60 9746      		sbiw TOP,(-ukey)		; 4 / 7
002e61 9508      		ret
                 
                 
002e62 dfec              fdw		TWODROP_L
                 UKEYQ_L:
002e63 27a5
002e64 656b
002e65 3f79              .db		NFA|INLINE4|5,"'key?"
                 ;UKEYQ_:
002e66 939a
002e67 938a      		pushtos
                 UKEYQ_0:
002e68 01c1      		movw TOP,UP
002e69 9744      		sbiw TOP,(-ukeyq)		; 4 / 7
002e6a 9508      		ret
                 
                 
002e6b eeba              fdw		POSTPONE_L
                 OPERATOR_L:
002e6c 6f88
002e6d 6570
002e6e 6172
002e6f 6f74
002e70 ff72              .db		NFA|8,"operator",0xff
                 OPERATOR:
002e71 940e 3436 		call DOCREATE			; ### 'call..' for 'tasks' to work ###
002e73 dce8      		fdw   OPERATOR_AREA
                 OPERATOR_AREA:					; description of operator task:
002e74 02e2      		.dw  up0				; location of the user area
002e75 0000
002e76 0040      		.dw  0		,ursize		; size of:  user variable area	, return stack	
002e77 0040
002e78 005a      		.dw  ussize	,utibsize	;			data stack			, tib
                 
                 
002e79 dd42              fdw		MTST_L
                 ; mset  ( mask addr -- )
                 ;   dup >r c@ or r> c! ;
                 MSET_L:
002e7a 6da4
002e7b 6573
002e7c ff74              .db		NFA|INLINE5|4,"mset",0xff
                 MSET:
002e7d 9109
002e7e 9119      		pop_t1t0				; mask
                 MSET_0:
002e7f 01fc      		movw Z,TOP
002e80 8180      		ld tosl,Z
002e81 2b80      		or tosl,t0
002e82 8380      		st Z,tosl
002e83 9189
002e84 9199      		poptos					; 8 / 14
002e85 9508      		ret
                         
                 
002e86 dcf4              fdw		MSET_L
                 ; mclr  ( mask addr -- )
                 ;   dup >r c@ swap invert and r> c! ;
                 MCLR_L:
002e87 6da4
002e88 6c63
002e89 ff72              .db		NFA|INLINE5|4,"mclr",0xff
                 MCLR:
002e8a 9109
002e8b 9119      		pop_t1t0				; mask
                 MCLR_0:
002e8c 01fc      		movw Z,TOP
002e8d 8180      		ld tosl,Z
002e8e 9500      		com t0
002e8f 2380      		and tosl,t0
002e90 8380      		st Z,tosl
002e91 9189
002e92 9199      		poptos					;  9 / 15
002e93 9508      		ret
                 
                 
002e94 e470      		fdw		PARSE_L
                 ; mtst0 ( mask addr -- )		(NO flag on stack - to be used with '0until' and '0if')
                 ;   c@ and drop ;
                 MTSTZ_L:
002e95 6da5
002e96 7374
002e97 3074      		.db		NFA|INLINE5|5,"mtst0"
                 MTSTZ:
002e98 9109
002e99 9119      		pop_t1t0				; mask
                 MTSTZ_0:
002e9a 01fc      		movw Z,TOP
002e9b 9189
002e9c 9199      		poptos
002e9d 8110      		ld t1,Z
002e9e 2310      		and t1,t0				; 7 / 12
002e9f 9508      		ret						; leave valid Z-flag
                 
                 
002ea0 f4a6      		fdw		NEXT_L
                 ; mtst ( mask addr -- f )
                 ;   c@ and ;
                 MTST_L:
002ea1 6da4
002ea2 7374
002ea3 ff74      		.db		NFA|INLINE5|4,"mtst",0xff
                 MTST:
002ea4 9109
002ea5 9119      		pop_t1t0				; mask
                 MTST_0:
002ea6 01fc      		movw Z,TOP
002ea7 8180      		ld tosl,Z
002ea8 2380      		and tosl,t0
002ea9 e090      		ldi tosh,0x00			; 6 / 9
002eaa 9508      		ret						; leave valid Z-flag
                 
                 
                 .if IDLE_MODE == 1
002eab f902      			fdw		IRQ_V_L
                 	IDLE_L:
002eac 69a4
002ead 6c64
002eae ff65      			.db		NFA|INLINE|4,"idle",0xff
                 	;IDLE:
002eaf 6072      			sbr FLAGS2,(1<<fIDLE)	; 1 / 1
002eb0 9508      			ret
                 
002eb1 d952      			fdw		CELL_L
                 	BUSY_L:
002eb2 62a4
002eb3 7375
002eb4 ff79      			.db		NFA|INLINE|4,"busy",0xff
                 	;BUSY:
002eb5 7f7d      			cbr FLAGS2,(1<<fIDLE)	; 1 / 1
                   .if CPU_LOAD_LED == 1
                        .if CPU_LOAD_LED_POLARITY == 1
                        .else
                        .endif
                   .endif
002eb6 9508      			ret
                 .endif
                 
                 
002eb7 db2a      		fdw		FLOCK_L
                 FCY_L:
002eb8 4683
002eb9 7963      		.db		NFA|3,"Fcy"
002eba d57b      		rcall DOCREATE
002ebb 3e80      		.dw FREQ_OSC/1000
                 
                 
002ebc e438      		fdw		TWOCONSTANT_L
                 VARIABLE_L:
002ebd 7688
002ebe 7261
002ebf 6169
002ec0 6c62
002ec1 ff65      		.db		NFA|8,"variable",0xff
                 VARIABLE_:
002ec2 e012      		ldi t1,2
                 VARIABLE_1:
002ec3 d102      		rcall HERE				; (uses t0)
002ec4 2700      		clr t0
002ec5 0f18      		add t1,tosl				; t0:t1 (++ high<>low swapped ++) 
002ec6 1f09      		adc t0,tosh
002ec7 9302      		st -Z,t0				; (Z-pointer valid from HERE)
002ec8 9312      		st -Z,t1
002ec9 c344      		rjmp CONSTANT_
                 
                 
002eca ede8              fdw		TICK_L
                 ; #   ( ud1 -- ud2 )			convert 1 digit of output and put into PAD
                 ;   base @ ud/mod rot >digit hold ;
                 NUM_L:
002ecb 2381              .db		NFA|1,"#"
                 NUM:
                 .if optimizeNUM == 0
                 .elif optimizeNUM == 1
                 								; unsignd division 32 base8 -- 32	, t0: rem8
002ecc 01f1      			movw Z,UP
002ecd 9772      			sbiw Z,(-ubase)
002ece 81a0      			ld t4,Z					; base in t4
002ecf 81e8      			ldd t6,Y+0
002ed0 81f9      			ldd t7,Y+1				; ud.l: t7t6
                 									; ud.h: TOP
002ed1 2f0e      			mov t0,t6				; save LSB for digit
002ed2 30a2       			cpi t4,2
002ed3 f0f9      			  breq UDbinSLASHMOD
002ed4 31a0      			cpi t4,16
002ed5 f089      			  breq UDhexSLASHMOD
                 			;cpi t4,8
                 			;  breq UDoctSLASHMOD	; (activate when needed)
                 			;cpi t4,4
                 			;  breq UDquadSLASHMOD	; (activate when needed)
                 
002ed6 27bb      			clr t5					; divisor.h (divisor.l = base)
002ed7 2700      			clr t0
002ed8 2be8      			or t6,tosl
002ed9 2bf9      			or t7,tosh
002eda 2bef      			or t6,t7
002edb f0f9      			  breq UDbaseSM_00		; skip division for ud = 0x0000.0000. (for leading zeros in UDOTR)
                 				
                 	UDbaseSM_32:					; ( ud.l  ud.h )					u  : t5t4
002edc d7f7      			rcall udslashmod0		; ( ud'.l	   )	ud'h in t7:t6	rem: t3t2
                 
002edd 2d00      			mov t0,t2				; rem/digit
002ede 010c      			movw t3t2,TOP			; save ud'.l for zero check in NUMS
002edf 939a
002ee0 938a      			pushtos
002ee1 01cf      			movw TOP,t7t6			; ( ud'.l ud'.h  )
                 			;rjmp NUM_TODIGIT
                 	NUM_TODIGIT:
002ee2 300a      			cpi t0,0x0a
002ee3 f008      			brcs PC+2
002ee4 5d09      			  subi t0,-0x27
002ee5 5d00      			subi t0,-0x30
002ee6 c2a8      			rjmp NUM_HOLD
                 
                 	UDhexSLASHMOD:					; 42+4
002ee7 9596      			lsr tosh
002ee8 9587      			ror tosl
002ee9 95f7      			ror t7
002eea 95e7      			ror t6
                 	UDoctSLASHMOD:					; 40+4
002eeb 9596      			lsr tosh
002eec 9587      			ror tosl
002eed 95f7      			ror t7
002eee 95e7      			ror t6
                 	UDquadSLASHMOD: 				; 38+4
002eef 9596      			lsr tosh
002ef0 9587      			ror tosl
002ef1 95f7      			ror t7
002ef2 95e7      			ror t6
                 	UDbinSLASHMOD:					; 28+4	
002ef3 9596      			lsr tosh
002ef4 9587      			ror tosl
002ef5 95f7      			ror t7
002ef6 95e7      			ror t6
                 	
002ef7 95aa      			dec t4					; base - 1
002ef8 230a      			and t0,t4				; separate digit
002ef9 83f9      			std Y+1,t7
002efa 83e8      			std Y+0,t6
                 	UDbaseSM_00:
002efb 010f      			movw t3t2,t7t6			; save ud'.l for zero check in NUMS
002efc cfe5      			rjmp NUM_TODIGIT
                 .else .error "illegal value: optimizeNUM"
                 .endif
                 
                 	
002efd fd08              fdw		PLUSSTORE_L
                 ; #S  ( ud1 -- 0. )				convert remaining digits
                 ;   begin # 2dup or 0= until ;
                 NUMS_L:
002efe 2382
002eff ff73              .db		NFA|2,"#s",0xff
                 NUMS:
                 .if optimizeNUM == 0
                 .elif optimizeNUM == 1
002f00 01f1      			movw Z,UP
002f01 9772      			sbiw Z,(-ubase)
002f02 81a0      			ld t4,Z
                 
002f03 30aa      			cpi t4,10
002f04 f039      			breq NUMS10
                 	NUMS_0:
002f05 dfc6      			  rcall NUM				; saves ud'.l in t3t2
002f06 2a08      			  or t2,tosl			; ud' = 0 ?
002f07 2a19      			  or t3,tosh
002f08 2801      			  or t2,t3
002f09 f7d9      			brne NUMS_0
002f0a 9508      			ret
                 
                 	NUMS10_loop:
002f0b dfc0      			  rcall NUM
                 	NUMS10:
002f0c 9700      			  sbiw TOP,0
002f0d f7e9      			brne NUMS10_loop		; ud.h <> 0 -> get a digit
                 									; ud.h =  0 -> ...
                 	NUMS_ten:					; 16-bit base10 conversion for u in NEXT
002f0e 8188      			ldd tosl,Y+0			; (keep stack space)
002f0f 8199      			ldd tosh,Y+1
                 	WordToDec5:						; (t1:t0:tosh:tosl:t3) = WordToDec5(TOP)
                 
                 		.def x6     = R16			; t0
                 		.def x5536L = R16
                 		.def x5536H = R16
                 		.def x10    = R26			; t4
                 
002f10 e310      			ldi t1,'0'						; 10.000
002f11 e006      			ldi x6,6						; multiply by 6,5536 to shift out the first digit
002f12 9f80      			mul tosl,x6											; * 6,5536 as:
002f13 01f0      						movw t7t6,R1:R0
002f14 9f90      			mul tosh,x6											; * 6
002f15 0df0
002f16 1d11      									add t7,R0		adc t1,R1
                 		
002f17 eb09      			ldi x5536L,0xb9										; .. + *0,553604126 (0x8db9)
002f18 e8b0      			ldi t5,0x80											; enough for correct rounding
002f19 9f90      			mul tosh,x5536L
002f1a 0db0
002f1b 1de1
002f1c 1df7
002f1d 1d17      			add t5,R0	adc t6,R1	adc t7,r_zero	adc t1,r_zero
                 	
002f1e e80d      			ldi x5536H,0x8d
002f1f 9f90      			mul tosh,x5536H
002f20 9408
002f21 1de0
002f22 1df1
002f23 1d17      			sec			adc t6,R0	adc t7,R1		adc t1,r_zero
002f24 9f80      			mul tosl,x5536H
002f25 0db0
002f26 1de1
002f27 1df7
002f28 1d17      			add t5,R0	adc t6,R1	adc t7,r_zero	adc t1,r_zero	; 30
                 	
002f29 e300      			ldi t0,'0'						;  1.000
002f2a e0aa      			ldi x10,10						; multiply by 10 to shift out the second digit
002f2b 9fea      			mul t6,x10
002f2c 01c0      						movw TOP,R1:R0
002f2d 9ffa      			mul t7,x10
002f2e 0d90
002f2f 1d01      									add tosh,R0		adc t0,R1
002f30 9fba      			mul t5,x10
002f31 0d81
002f32 1d97
002f33 1d07      						add tosl,R1	adc tosh,r_zero	adc t0,r_zero	; 44
                 
                 											; ......... third digit
002f34 9f8a      			mul tosl,x10					;    100
002f35 01f0      						movw t7t6,R1:R0
002f36 9f9a      			mul tosh,x10
002f37 e390
002f38 0df0
002f39 1d91      			ldi tosh,'0'			add t7,R0	adc tosh,R1			; 52
                 
                 											; ........ fourth digit
002f3a e380      			ldi tosl,'0'					;     10
002f3b 9fea      			mul t6,x10
002f3c 2db1      									mov t5,R1
002f3d 9ffa      			mul t7,x10
002f3e 0db0
002f3f 1d81      									add t5,R0	adc tosl,R1			; 60
                 											; ......... fifth digit
002f40 e3f0      			ldi t7,'0'						;      1
002f41 9fba      			mul t5,x10
002f42 0e1f      												add R1,t7	; t3	; 64 
                 
                 								; HOLD
002f43 01f1      			movw Z,UP				; t7:t6
                 			;sbiw Z,(-uhp)			; uhp = 0
002f44 91a1      			ld XL,Z+				; t4
002f45 91b1      			ld XH,Z+				; t5
002f46 921e      			st -X,t3				; ....x HOLD
002f47 9483      			inc #hold
                 
002f48 3310      			cpi t1,'0'										;
002f49 f481      			  brne Nt_all									;	 	91		leading digit non-zero -> write all 5 digits
                 			  					; skip leading zeros
002f4a 1710      			cp  t1,t0				; at this point: t1 = '0'
002f4b 0719      			cpc t1,tosh
002f4c 0718      			cpc t1,tosl	
002f4d f091      			  breq Nt_xxx									;		    95			
002f4e 938e      			st -X,tosl				; ...x. HOLD
002f4f 9483      			inc #hold
                 
002f50 1710      			cp  t1,t0
002f51 0719      			cpc t1,tosh	
002f52 f069      			  breq Nt_xxx									;			   101
002f53 939e      			st -X,tosh				; ..x.. HOLD
002f54 9483      			inc #hold
                 
002f55 1710      			cp  t1,t0	
002f56 f049      			  breq Nt_xxx									;				   106
002f57 930e      			st -X,t0				; .x... HOLD
002f58 9483      			inc #hold
                 
002f59 c006      			rjmp Nt_xxx										;					   110
                 
                 	Nt_all:
002f5a 938e      			st -X,tosl				; ...x. HOLD
002f5b 939e      			st -X,tosh				; ..x.. HOLD
002f5c 930e      			st -X,t0				; .x... HOLD
002f5d 931e      			st -X,t1				; x.... HOLD
002f5e e004      			ldi t0,4
002f5f 0e80      			add #hold,t0									;       99
                 	Nt_xxx:
002f60 93b2      			st -Z,XH
002f61 93a2      			st -Z,XL
                 			;;clr tosl 										; put 0x0000.0000. on stack
                 			;;clr tosh
                 			;;pushtos
                 			;sbiw Y,2										; let it be any double (will be 2drop-ed in '#>' anyway)
                 															; .. no need (stack space kept)
                 															;   	 5	 1	 2	 3	 4 #digits 
002f62 9508      			ret												;      104  99 105 110 114
                 															;   	+4	+4	+4	+4	+4
                 .else .error "illegal value: optimizeNUM"
                 .endif
                 
                 
002f63 d85a              fdw		SQUAREROOT_L
                 ; SKIP  ( c-addr u c -- c-addr' u' )	skip matching chars
                 ; c-addr must point to RAM
                 ; u (count) must be smaller than 256
                 SKIP_L:
002f64 7384
002f65 696b
002f66 ff70              .db		NFA|4,"skip",0xff
                 SKIP:
002f67 2f08      		mov t0,tosL				; c in t0
002f68 9189
002f69 9199      		poptos					; u in tosl
                 SKIP_0:
002f6a 91e9
002f6b 91f9      		pop_Z					; c-addr in Z
                 SKIP_loop:
002f6c 9701      		  sbiw TOP,1
002f6d f030                  brcs SKIP_leave
002f6e 9111      		  ld t1,Z+				; fetched char
002f6f 3019      		  cpi t1,TAB_
002f70 f3d9      		    breq SKIP_loop
002f71 1710      		  cp t1,t0
002f72 f3c9      		breq SKIP_loop
                 SKIP_mismatch:
                 SCAN_match:
002f73 9731      		sbiw Z,1				; set c-addr back to found match
                 SKIP_leave:
                 SCAN_leave:
002f74 9601      		adiw TOP,1
002f75 93fa
002f76 93ea      		push_Z
002f77 9508      		ret
                 
                 
002f78 e3bc      		fdw		SIGN_L
                 ; SCAN  ( c-addr u c -- c-addr' u' )	find matching chars
                 ; c-addr must point to RAM
                 SCAN_L:
002f79 7384
002f7a 6163
002f7b ff6e      		.db		NFA|4,"scan",0xff
                 SCAN:
002f7c 2f08      		mov t0,tosl				; c in t0
002f7d 9189
002f7e 9199      		poptos					; u in tos
                 SCAN_0:
002f7f 91e9
002f80 91f9      		pop_Z					; c-addr in Z
                 SCAN_loop:
002f81 9701      		  sbiw TOP,1
002f82 f388      		    brcs SCAN_leave
002f83 9111      		  ld t1,Z+
002f84 3019      		  cpi t1,TAB_
002f85 f369      		    breq SCAN_match
002f86 1710      		  cp t1,t0
002f87 f7c9      		brne SCAN_loop
002f88 cfea      		rjmp SCAN_match
                 
                 
002f89 f08e      		fdw		IMMEDIATE_L
                 TWOVARIABLE_L:
002f8a 3289
002f8b 6176
002f8c 6972
002f8d 6261
002f8e 656c      		.db		NFA|9,"2variable"
                 TWOVARIABLE_:
002f8f e014      		ldi t1,4
002f90 cf32      		rjmp VARIABLE_1
                 
                 
002f91 df30      		fdw		EIGHTRSHIFT_L
                 EIGHTLSHIFT_L:
002f92 38a3
002f93 3c3c      		.db		NFA|INLINE|3,"8<<"
                 ;EIGHTLSHIFT:
002f94 2f98      		mov tosh,tosl
002f95 e080      		ldi tosl,0				; 2 / 2
002f96 9508      		ret
                 	
002f97 dc62      		fdw		TOIN_L
                 EIGHTRSHIFT_L:
002f98 38a3
002f99 3e3e      		.db		NFA|INLINE|3,"8>>"
                 ;EIGHTRSHIFT:
002f9a 2f89      		mov tosl,tosh
002f9b e090      		ldi tosh,0				; 2 / 2
002f9c 9508      		ret
                 
002f9d d8ec      		fdw		TO_A_L
                 ; ><							swap bytes
                 SWAPB_L:
002f9e 3ea2
002f9f ff3c      		.db		NFA|INLINE|2,"><",0xff
                 ;SWAPB:
002fa0 2f08      		mov t0,tosl
002fa1 2f89      		mov tosl,tosh
002fa2 2f90      		mov tosh,t0				; 3 / 3
002fa3 9508      		ret
                 
                 
002fa4 ee02      		fdw		IHERE_L
                 ; set the current memory section
                 ; ..FLASH
                 FLASH_L:
                 ROM_N:  
002fa5 66a5
002fa6 616c
002fa7 6873      		.db		NFA|INLINE|5,"flash"
                 ;ROM_:
002fa8 bc7a      		out cse,r_zero			; 1 / 1
002fa9 9508      		ret
                 
002faa e6e6      		fdw		IFLUSH_L
                 ; ..EEPROM
                 EEPROM_L:
                 EROM_N: 
002fab 65a6
002fac 7065
002fad 6f72
002fae ff6d      		.db		NFA|INLINE|6,"eeprom",0xff
                 ;EROM:
002faf e002      		ldi t0,2
002fb0 bd0a      		out cse,t0				; 2 / 2
002fb1 9508      		ret
                 
002fb2 f89e      		fdw		ROT_L
                 ; ..RAM
                 RAM_L:
                 FRAM_N: 
002fb3 72a3
002fb4 6d61      		.db		NFA|INLINE|3,"ram"
                 FRAM:
002fb5 e004      		ldi t0,4
002fb6 bd0a      		out cse,t0				; 2 / 2
002fb7 9508      		ret
                 
                 
002fb8 d9b8      		fdw		EI_L
                 ; DP  ( -- a-addr )				current dictionary pointer (in RAM)
                 DP_L:
002fb9 64a2
002fba ff70      		.db		NFA|INLINE5|2,"dp",0xff
                 DP:
002fbb 939a
002fbc 938a      		pushtos
                 DP_0:
002fbd b58a      		in tosl,cse
002fbe 2799      		clr tosh
002fbf 5487      		subi tosl, LOW(-dpFLASH)
002fc0 4f9d      		sbci tosh,HIGH(-dpFLASH)	; 6 / 8
002fc1 9508      		ret
                 
                 
002fc2 e312      		fdw		HOLD_L
                 ; HERE  ( -- addr )				get current data space ptr
                 ;   DP @ ;
                 HERE_L:
002fc3 6884
002fc4 7265
002fc5 ff65      		.db		NFA|4,"here",0xff
                 HERE:
002fc6 939a
002fc7 938a      		pushtos
                 HERE_0:
002fc8 b5ea      		in ZL,cse
002fc9 27ff      		clr ZH
002fca 54e7      		subi ZL, LOW(-dpFLASH)
002fcb 4ffd      		sbci ZH,HIGH(-dpFLASH)
002fcc 9181      		ld tosl,Z+
002fcd 9191      		ld tosh,Z+				; 8 / 12
002fce 9508      		ret	
                 
                 
002fcf d794      		fdw		CWD_L
                 COMMAXT_L:
002fd0 6383
002fd1 2c66      		.db		NFA|3, "cf,"
                 COMMAXT:
002fd2 01dc      		movw t5t4,TOP
002fd3 9100 02b9 		lds t0,dpFLASH
002fd5 9110 02ba 		lds t1,dpFLASH+1
                 
                   .if FLASHEND == 0x3fff			; for ATmega328 ONLY!!:
002fd7 3fb0      			cpi t5,0xf0
002fd8 f008      			brcs COMMAXT_xxx
002fd9 77bf      			  cbr t5,HIGH(PFLASH)	; 'rcall ...' into kernel (wrap around at 0x0000)
                 	COMMAXT_xxx:
                   .endif
                 
002fda 1ba0      		sub t4,t0
002fdb 0bb1      		sbc t5,t1
002fdc f41a      		brpl COMMAXT_yyy
002fdd 95a0      		  com t4
002fde 95b0      		  com t5
002fdf 9611      		  adiw t5t4,1
                 COMMAXT_yyy:
002fe0 3fac      		cpi t4,0xfc
002fe1 e0af      		ldi t4,0x0f
002fe2 07ba      		cpc t5,t4
002fe3 f048      		  brcs STORECF1
                 
                 STORECFF1: 
002fe4 5890      		sub_pflash_tos			; compile 'call ..'
002fe5 9596      		lsr tosh
002fe6 9587      		ror tosl
                 STORECFF2:
002fe7 939a
002fe8 938a      		pushtos
                   .ifdef EIND
                   .else
                 			;.dw     0x940E
002fe9 e08e      			ldi tosl,0x0e  		; 'call ..'
002fea e994      			ldi tosh,0x94
                   .endif
002feb d7d1      		rcall ICOMMA_
002fec c7d0      		rjmp ICOMMA_
                 
                 STORECF1:
                 		;rcall IHERE			; compile 'rcall ..'
                 		;rcall MINUS			;  2 / 29
002fed 1b80      		sub tosl,t0
002fee 0b91      		sbc tosh,t1
002fef 9702      		sbiw TOP,2
002ff0 9595      		asr tosh
002ff1 9587      		ror tosl
002ff2 709f      		andi tosh,0x0f
002ff3 6d90      		ori tosh,0xd0			; 'rcall ..'
002ff4 c7c8      		rjmp ICOMMA_
                 
                 
002ff5 e012      		fdw		TWOSWAP_L
                 ; 2DROP ( x1 x2 -- )			drop 2 cells
                 ;	DROP DROP ;
                 TWODROP_L:
002ff6 32a5
002ff7 7264
002ff8 706f      		.db		NFA|INLINE|5,"2drop"
                 TWODROP:
002ff9 9622      		adiw Y,2				; NIP
002ffa 9189
002ffb 9199      		poptos					; 3 /  6
002ffc 9508      		ret
                 
                 
002ffd da1e      		fdw		BASE_L
                 ; 2DUP  ( x1 x2 -- x1 x2 x1 x2 )	dup top 2 cells
                 ;   OVER OVER ;
                 TWODUP_L:
002ffe 32a4
002fff 7564
003000 ff70      		.db		NFA|INLINE5|4,"2dup",0xff
                 TWODUP:
003001 8108      		ldd t0,Y+0
003002 8119      		ldd t1,Y+1
003003 939a
003004 938a      		duptos
003005 931a
003006 930a      		push_t1t0				; 6 / 12
003007 9508      		ret
                 
                 
003008 daba      		fdw		TOBODY_L
                 ; 2SWAP  ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
                 TWOSWAP_L:
003009 3285
00300a 7773
00300b 7061      		.db		NFA|5,"2swap"
                 TWOSWAP:
00300c 01fc      		movw t7t6,TOP
00300d 91a9
00300e 91b9      		pop_t5t4
00300f 9189
003010 9199      		poptos
003011 9109
003012 9119      		pop_t1t0
003013 93ba
003014 93aa      		push_t5t4
003015 93fa
003016 93ea      		push_t7t6
003017 931a
003018 930a      		push_t1t0				; 13 / 25
003019 9508      		ret
                 
                 
00301a efb0      		fdw		STATE_L
                 ; SPACE ( -- )					output a space
                 ;	BL EMIT ;
                 SPACE_L:
00301b 7385
00301c 6170
00301d 6563      		.db		NFA|5,"space"
                 SPACE_:  
00301e e200      		ldi t0,' '
00301f c752      		rjmp EMIT_t0
                 
                 
003020 d80e      		fdw		TICKSCOMPUTE_L
                 ; SPACES ( n -- )				output n spaces
                 ;	BEGIN DUP WHILE SPACE 1- REPEAT DROP ;
                 SPACES_L:
003021 7386
003022 6170
003023 6563
003024 ff73      		.db		NFA|6,"spaces",0xff
                 SPACES:
003025 9701      		  sbiw TOP,1
003026 f030      			brcs DROP
003027 dff6      		  rcall SPACE_
003028 cffc      		rjmp SPACES
                 
                 
003029 f19e      		fdw		DUMP_L
                 DROP_L:
00302a 64a4
00302b 6f72
00302c ff70      		.db		NFA|INLINE|4,"drop",0xff
                 DROP:
00302d 9189
00302e 9199      		poptos					; 2 / 4
00302f 9508      		ret
                 
                 
003030 d9f0      		fdw		TASK_L
                 SWOP_L:
003031 73a4
003032 6177
003033 ff70      		.db		NFA|INLINE5|4,"swap",0xff
                 SWOP:
003034 018c      		movw t1t0,TOP
003035 9189
003036 9199      		poptos
003037 931a
003038 930a      		push_t1t0				; 5 / 9
003039 9508      		ret
                 
                 
00303a ecdc      		fdw		QUIT_L
                 ; ( nx .. n1 n0 u -- nx .. n1 n0 nu )
                 PICK_L:
00303b 70a4
00303c 6369
00303d ff6b      		.db		NFA|INLINE5|4,"pick",0xff
                 PICK:
00303e 0f88      		lsl tosl
00303f 01fe      		movw Z,Y
003040 0fe8      		add ZL,tosl
003041 1df7      		adc ZH,r_zero
003042 9181      		ld tosl,Z+
003043 9191      		ld tosh,Z+				; 6 / 8
003044 9508      		ret
                 
                 
                 
003045 e076      		fdw 	PICK_L
                 OVER_L:
003046 6fa4
003047 6576
003048 ff72      		.db		NFA|INLINE4|4,"over",0xff
                 OVER:
003049 939a
00304a 938a      		pushtos
00304b 818a      		ldd tosl,Y+2
00304c 819b      		ldd tosh,Y+3			; 4 / 8
00304d 9508      		ret
                 
                 
00304e f630      		fdw		FETCHPP_L
                 TOR_L:
00304f 3eb2
003050 ff72      		.db		NFA|COMPILE|0x20|2,">r",0xff
                 ;TOR:					;++++ must be inlined ++++
003051 938f      		push tosl
003052 939f      		push tosh
003053 9189
003054 9199      		poptos					; 4 /  8
003055 9508      		ret
                 
003056 e0be      		fdw		RFETCH_L
                 RFROM_L:
003057 72b2
003058 ff3e      		.db		NFA|COMPILE|0x20|2,"r>",0xff
                 ;RFROM:					;++++ must be inlined ++++
003059 939a
00305a 938a      		pushtos
00305b 919f      		pop tosh
00305c 918f      		pop tosl				; 4 /  8
00305d 9508      		ret
                 
                 
00305e e188      		fdw		SQUOTE_L
                 RFETCH_L:
00305f 72b2
003060 ff40      		.db		NFA|COMPILE|0x20|2,"r@",0xff
                 ;RFETCH:				;++++ must be inlined ++++
003061 939a
003062 938a      		pushtos
003063 b7ed      		in ZL,SPL
003064 b7fe      		in ZH,SPH
003065 8182      		ldd tosl,Z+2
003066 8191      		ldd tosh,Z+1			; 6 / 10
003067 9508      		ret				
                 
003068 da5c      		fdw		AND_L
                 ; ABS ( n -- |n| )				absolute value of n
                 ABS_L:
003069 61a3
00306a 7362      		.db		NFA|INLINE5|3,"abs"
                 ABS_:
00306b 2399      		tst tosh
00306c f41a      		brpl ABS_1
00306d 9580      		  com tosl
00306e 9590      		  com tosh
00306f 9601      		  adiw TOP,1
                 ABS_1:							; 5 / 3..6
003070 9508      		ret
                 
                 
003071 ec54      		fdw		COMMA_L
                 PLUS_L:
003072 2ba1      		.db		NFA|INLINE4|1, "+"
                 PLUS:
003073 9109
003074 9119      		pop_t1t0
                 PLUS_0:
003075 0f80      		add tosl,t0
003076 1f91      		adc tosh,t1				; 4 / 6
003077 9508      		ret
                 
                 
003078 eff8      		fdw		ALLOT_L
                 ; ALIGN ( -- )					align DP
                 ALIGN_L:
003079 6185
00307a 696c
00307b 6e67      		.db		NFA|5,"align"
                 ;ALIGN:
00307c df49      		rcall HERE
00307d 9601      		adiw TOP,1
00307e 7f8e      		cbr tosl,1
00307f c787      		rjmp ALLOT_1			; Z-pointer valid from HERE
                 
                 
003080 d7fe      		fdw 	TICKS_L
                 SWOPMINUS_L:
003081 73a5
003082 6177
003083 2d70      		.db		NFA|INLINE4|5,"swap-"
                 SWOPMINUS:
003084 9109
003085 9119      		pop_t1t0
003086 1b80      		sub tosl,t0
003087 0b91      		sbc tosh,t1				; 4 / 6
003088 9508      		ret
                 
                 
003089 ee98      		fdw		CREATE_L
                 ; ACCEPT  ( c-addr u -- u' )	get line or max u char from terminal and put into TIB
                 ACCEPT_L:
00308a 6186
00308b 6363
00308c 7065
00308d ff74      		.db		NFA|6,"accept",0xff
                 ACCEPT:
00308e 010c      		movw t3t2,TOP
00308f 8188      		ldd tosl,Y+0
003090 8199      		ldd tosh,Y+1
003091 0e08      		add t2,tosl				; ( c-addr c-addr ) end-addr in t3:t2
003092 1e19      		adc t3,tosh
                 ACC1:
003093 940e 3eb8 		  call KEY				; ( c-addr c-addr' c )
                 
003095 01d1      		  movw X,UP
003096 9719      		  sbiw X,(-uflg)
                 
003097 308d      		  cpi tosl, CR_
003098 f0a9      			breq ACC_CR
003099 308a      		  cpi tosl, LF_
00309a f0b9      			breq ACC_LF
00309b 378f      		  cpi tosl, 127
00309c f011      			breq ACC_BS_DEL
00309d 3088      		  cpi tosl, BS_
00309e f4d1      			brne ACC3
                 
                 ACC_BS_DEL:
00309f 927c      		  st X,r_zero			; uflg = 0x00
0030a0 9189
0030a1 9199      		  poptos
0030a2 8108      		  ldd t0,Y+0
0030a3 8119      		  ldd t1,Y+1
0030a4 1b08      		  sub t0,tosl
0030a5 0b19      		  sbc t1,tosh
0030a6 f361      		breq ACC1
0030a7 9701      		  sbiw TOP,1
0030a8 d7bd      		  rcall XSQUOTE
0030a9 0803
0030aa 0820      		  .db   3,8,0x20,8
0030ab 940e 38c4 		  call TYPE
0030ad cfe5      		rjmp ACC1
                 
                 ACC_CR:
0030ae 938c      		  st X,tosl				; uflg = 0x0d
0030af 9189
0030b0 9199      		  poptos
0030b1 cfd2      		  rjmp SWOPMINUS
                 
                 ACC_LF:
0030b2 9189
0030b3 9199      		  poptos
0030b4 910c      		  ld t0,X
0030b5 2300      		  tst t0				; uflg == 0x00 ?
0030b6 f269      			breq SWOPMINUS		; ..yes -> line end -> ready
0030b7 927c      		  st X,r_zero			; ..no  -> set uflg = 0x00 
0030b8 cfda      		rjmp ACC1				; ..and get next char
                 
                 ACC3:
0030b9 2f08      		  mov t0,tosl			; ( c-addr c-addr' c )
0030ba d6b7      		  rcall EMIT_t0
0030bb 91a9
0030bc 91b9      		  pop_X					; ( c-addr c		X: c-addr' )
0030bd 938d      		  st X+,tosl
0030be 01cd      		  movw TOP,X			; ( c-addr c-addr" )
                 
0030bf 1608      		  cp  t2,tosl
0030c0 0619      		  cpc t3,tosh
0030c1 f689      		brne ACC1
0030c2 cfc1      		rjmp SWOPMINUS
                 
                 
                 
0030c3 efd8      		fdw		S0_L
                 SQUOTE_L:
0030c4 73d2
0030c5 ff22      		.db      NFA|IMMED|COMPILE|2,"s",0x22,0xff
                 SQUOTE:
0030c6 d37a      		rcall DOCOMMAXT
0030c7 f0cc      		fdw  XSQUOTE
0030c8 bc7a      		out cse,r_zero			; 'flash'
0030c9 d004      		rcall CQUOTE
0030ca ceea      		rjmp  FRAM
                 
                 
0030cb efa2      		fdw		MINUS_FETCH_L
                 CQUOTE_L:
0030cc 2c82
0030cd ff22      		.db		NFA|2,",",0x22,0xff
                 CQUOTE: 
0030ce 939a
0030cf 938a      		pushtos
0030d0 e282      		ldi tosl,'"'
                 		;ldi tosh,0
0030d1 d169      		rcall PARSE
0030d2 def3      		rcall HERE
0030d3 df75      		rcall OVER
0030d4 9602      		adiw TOP,2
0030d5 7f8e      		cbr tosl,1
0030d6 d728      		rcall ALLOT
0030d7 c590      		rjmp  PLACE
                 
                 
0030d8 d84e      		fdw		SQUARE_L
                 ; SP@ ( -- addr )				get parameter stack pointer
                 SPFETCH_L:
0030d9 73a3
0030da 4070      		.db		NFA|INLINE|3,"sp@"
                 SPFETCH:
0030db 018e      		movw t1t0,Y
0030dc 939a
0030dd 938a      		pushtos
0030de 01c8      		movw TOP,t1t0			; 4 / 6
0030df 9508      		ret
                 
                 
0030e0 e4ee      		fdw     FIND_L
                 ; EXIT							compile a return
                 ;		variable link
                 EXIT_L:
0030e1 65d4
0030e2 6978
0030e3 ff74      		.db		NFA|COMPILE|IMMED|4,"exit",0xff
                 EXIT:
0030e4 c6bd      		rjmp SEMICOLON_0
                 
                 
0030e5 dc72      		fdw		TICKSOURCE_L
                 ; within ( x min max -- f )		min <= x < max ?
                 WITHIN_L:
0030e6 7786
0030e7 7469
0030e8 6968
0030e9 ff6e      		.db		NFA|6,"within",0xff
                 ;WITHIN:
0030ea 9109
0030eb 9119      		pop_t1t0				; min
0030ec 91a9
0030ed 91b9      		pop_t5t4				; x
                 								; max in TOP
0030ee 170a      		cp  t0,t4
0030ef 071b      		cpc t1,t5
0030f0 f009      		breq PC+2
0030f1 f410      		  brcc WITHIN_flag		; C=0 -> x < min -> put FALSE
0030f2 17a8      		cp  t4,tosl
0030f3 07b9      		cpc t5,tosh				; C=0 -> max <= x -> put FALSE
                 WITHIN_flag:					; C=1 -> min <= x < max -> put TRUE
0030f4 0b88      		sbc tosl,tosl			; .. make it a stack-flag
0030f5 0b99      		sbc tosh,tosh
0030f6 9508      		ret						; 13 / 15..16+4
                 
                 
0030f7 df3c      		fdw		SWAPB_L
                 NOTEQUAL_L:
0030f8 3ca2
0030f9 ff3e      		.db		NFA|INLINE4|2,"<>",0xff
                 NOTEQUAL:
0030fa 9109
0030fb 9119      		 pop_t1t0
                 NOTEQUAL_0:
0030fc 1b80      		 sub tosl,t0
0030fd 0b91      		 sbc tosh,t1			; 4 / 6
0030fe 9508      		 ret
                 
                 
0030ff e22c      		fdw		GREATER_L
                 EQUAL_L:
003100 3da1      		.db		NFA|INLINE5|1, "="
                 EQUAL:
003101 9109
003102 9119      		 pop_t1t0
                 EQUAL_0:
003103 1b80      		 sub tosl,t0
003104 0b91      		 sbc tosh,t1
003105 9701      		 sbiw TOP,1
003106 0b88      		 sbc tosl,tosl
003107 0b99      		 sbc tosh,tosh			; 7 / 10
003108 9508      		 ret
                 
                 
003109 e200      		fdw		EQUAL_L
                 LESS_L:
00310a 3c81      		.db		NFA|1,"<"
                 LESS:
00310b 9109
00310c 9119      		pop_t1t0
                 ;LESS_0:						; #### check LESSC_ when changing ####
00310d 1b08      		sub t0,tosl
00310e 0b19      		sbc t1,tosh
                 LESS_1:
00310f f40b      		brvc PC+2
003110 9510      		  com t1
003111 0f11      		lsl t1
003112 0b88      		sbc tosl,tosl
003113 0b99      		sbc tosh,tosh			; 9 / 11
003114 9508      		ret
                 
                 
003115 fa7a      		fdw		FETCH_L
                 GREATER_L:
003116 3e81      		.db		NFA|1,">"
                 GREATER:						; #### check GREATERC_ when changing ####
003117 9109
003118 9119      		pop_t1t0
                 ;GREATER_0:
003119 1b80      		sub tosl,t0
00311a 0b91      		sbc tosh,t1
                 ;GREATER_1:
00311b f40b      		brvc PC+2
00311c 9590      		  com tosh
00311d 0f99      		lsl tosh
00311e 0b88      		sbc tosl,tosl
00311f 0b99      		sbc tosh,tosh			; 9 / 11
003120 9508      		ret
                 
                 
003121 e258      		fdw		UGREATER_L
                 ULESS_L:
003122 75a2
003123 ff3c      		.db		NFA|INLINE5|2,"u<",0xff
                 ULESS:							; #### check ULESSC_ when changing ####
003124 9109
003125 9119      		pop_t1t0
                 ;ULESS_0:
003126 1708      		cp  t0,tosl
003127 0719      		cpc t1,tosh
003128 0b88      		sbc tosl,tosl
003129 0b99      		sbc tosh,tosh			; 6 / 8
00312a 9508      		ret
                 
                 
00312b e302      		fdw		UPTR_L
                 UGREATER_L:
00312c 75a2
00312d ff3e      		.db		NFA|INLINE5|2, "u>",0xff
                 UGREATER:						; #### check UGREATERC_ when changing ####
00312e 9109
00312f 9119      		 pop_t1t0
                 ;UGREATER_0:
003130 1780      		 cp  tosl,t0
003131 0791      		 cpc tosh,t1
003132 0b88      		 sbc tosl,tosl
003133 0b99      		 sbc tosh,tosh			; 6 / 8
003134 9508      		 ret
                 
                 
003135 e354      		fdw		NUMGREATER_L
                 STORE_P_L:
003136 21a2
003137 ff70      		.db		NFA|INLINE|2,"!p",0xff
                 STORE_P:
003138 01ac      		movw P,TOP
003139 9189
00313a 9199      		poptos
00313b 9508      		ret
                 
                 .if optimizingCOMPILER == 1
                 	TO_A_C_:						; fdw TO_A in TOP
00313c d681      			rcall ldi16_t1t0_C_
00313d e588
00313e e091      			ldi16 tos,0x0158		; 'movw A,t1t0'
00313f c67d      			rjmp ICOMMA_
                 
                 	STORE_P_TO_R_C_:				; fdw STORE_P_TO_R in TOP
003140 d7da      			rcall IDP8MINUS
003141 e48f
003142 e993      			ldi16 tos,0x934f		; 'push pl'
003143 d679      			rcall ICOMMA_
003144 939a
003145 938a      			pushtos
003146 e58f
003147 e993      			ldi16 tos,0x935f		; 'push ph'
003148 d674      			rcall ICOMMA_
003149 e002      			ldi t0,2				; point to 'ldi tosh,<lit.1>'
00314a e410      			ldi t1,regP
00314b c676      			rjmp ldi16_thtl_C_0
                 
                 	STORE_P_C_:						; (fdw STORE_P) | (fdw STORE_P_TO_R) in TOP
00314c e410      			ldi t1,regP				; -> P
00314d d671      			rcall ldi16_thtl_C_
00314e cede      			rjmp DROP
                 
                 .endif
                 		
00314f dcb4      		fdw		UKEY_L
                 STORE_P_TO_R_L:
003150 21b4
003151 3e70
003152 ff72      		.db		NFA|COMPILE|0x20|4,"!p>r",0xff
                 STORE_P_TO_R:				;++++ must be inlined ++++
003153 934f      		push pl
003154 935f      		push ph
003155 01ac      		movw P,TOP
003156 9189
003157 9199      		poptos					; 5 / 9
003158 9508      		ret
                 
                 
003159 df66      		fdw		RAM_L
                 R_TO_P_L:
00315a 72b3
00315b 703e      		.db		NFA|COMPILE|0x20|3,"r>p"
                 ;R_TO_P:					;++++ must be inlined ++++
00315c 915f      		pop ph
00315d 914f      		pop pl
00315e 9508      		ret						; 2 / 4
                 
                 
00315f dbc8      		fdw		TO_XA_L
                 ; >pr  ( c -- c )				filter a character to printable 7-bit ASCII
                 TO_PRINTABLE_L:
003160 3ea3
003161 7270      		.db		NFA|INLINE5|3,">pr"
                 TO_PRINTABLE:
003162 2799      		clr tosh
003163 3280      		cpi tosl,0x20
003164 f008      		  brcs nonPRINT
003165 fd87      		sbrc tosl,7
003166 e28e      nonPRINT: ldi tosl,'.'			; 5 / 5
003167 9508      		ret
                 
                 
003168 e3ee      		fdw		DOT_L
                 MINUS_L:
003169 2da1      		.db		NFA|INLINE5|1, "-"
                 MINUS:
00316a 9109
00316b 9119      		pop_t1t0
                 ;MINUS_0:
00316c 1b08      		sub t0,tosl
00316d 0b19      		sbc t1,tosh
00316e 01c8      		movw TOP,t1t0			; 5 / 7
00316f 9508      		ret
                 
                 
003170 dc92      		fdw 	PNPLUS_L
                 NIP_L:
003171 6ea3
003172 7069      		.db		NFA|INLINE|3,"nip"
                 NIP:
003173 9622      		adiw Y,2				; 1 / 2
003174 9508      		ret
                     
                 
003175 f182      		fdw		TYPE_L
                 ; TUCK
                 ;   swap over ;
                 TUCK_L:
003176 74a4
003177 6375
003178 ff6b      		.db		NFA|INLINE5|4,"tuck",0xff
                 TUCK:
003179 9109
00317a 9119      		pop_t1t0
00317b 939a
00317c 938a      		duptos
                 t1t0_to_NEXT:
00317d 931a
00317e 930a      		push_t1t0				; 6 / 12
00317f 9508      		ret
                 
                 
003180 d834      		fdw		MICROS_L
                 UPTR_L:
003181 75a2
003182 ff70      		.db		NFA|INLINE4|2,"up",0xff
                 UPTR:
003183 939a
003184 938a      		pushtos 				; up in R3:R2 -> addr = 0x0002
                 UPTR_0:
003185 e082      		ldi tosl,2
003186 e090      		ldi tosh,0				; 4 / 6
003187 9508      		ret
                 
                 .if IDLE_MODE == 0
                 .elif IDLE_MODE == 1
003188 dd58      		fdw		IDLE_L
                 .else .error "illegal value: IDLE_MODE"
                 .endif
                 HOLD_L:
003189 6884
00318a 6c6f
00318b ff64      		.db		NFA|4,"hold",0xff
                 HOLD:
00318c 2f08      		mov t0,tosl
00318d 9189
00318e 9199      		poptos
                 NUM_HOLD:
00318f 01f1      		movw Z,UP
                 		;sbiw Z,(-uhp)			; uhp = 0 !!
003190 91a1      		ld XL,Z+
003191 91b1      		ld XH,Z+
003192 930e      		st -X,t0
003193 9483      		inc #hold
003194 93b2      		st -Z,XH
003195 93a2      		st -Z,XL				;  7 / 12
003196 9508      		ret						; 11 / 17+4
                 
                 
003197 e1f0      		fdw		NOTEQUAL_L
                 ; <# ( -- )						begin numeric conversion
                 ;	PAD HP ! ;					(initialize hold pointer)
                 LESSNUM_L:
003198 3c82
003199 ff23      		.db		NFA|2,"<#",0xff
                 LESSNUM:
00319a daf4      		rcall PAD_pushed		; 1 / 29
00319b 01f1      		movw Z,UP
00319c 8311      		std Z+1,t1
00319d 8300      		std Z+0,t0
00319e 2488      		clr #hold
00319f 9508      		ret						; 6 / 35+4
                 
                 
0031a0 ef10      		fdw		DOES_L
                 ; digit ( n -- c )				convert to 0..9 a..z
                 TODIGIT_L:
0031a1 64a5
0031a2 6769
0031a3 7469      		.db		NFA|INLINE4|5,"digit"
                 TODIGIT:
0031a4 308a      		cpi tosl,0x0a
0031a5 f008      		brcs PC+2
0031a6 5d89      		  subi tosl,-0x27
0031a7 5d80      		subi tosl,-0x30			; 4 / 4
0031a8 9508      		ret
                 
                 
0031a9 ddfc      		fdw		NUMS_L
                 ; #>  ( ud1 -- c-addr u )		end conversion, get string
                 ;   2drop hp @ pad over - ;
                 NUMGREATER_L:
0031aa 2382
0031ab 003e      		.db		NFA|2,"#>", 0
                 NUMGREATER:
0031ac 9622      		adiw Y,2				; "2drop"
                 		;poptos
                 		;pushtos				; HP @
0031ad 01f1      		movw Z,UP
                 		;sbiw Z,(-uhp)			; (uhp = 0)
0031ae 9181      		ld tosl,Z+
0031af 9191      		ld tosh,Z+
0031b0 939a
0031b1 938a      		pushtos
0031b2 2d88      		mov tosl,#hold			;  7 / 12
0031b3 9508      		ret			
                 
                 
                 .if optimizeNUM == 1
                 	UDOTR_ten:
0031b4 93af      			push XL					; print count
0031b5 93bf      			push XH					; leading char when <> 0 (optional)
0031b6 dd57      			rcall NUMS_ten			; Z points to uhp, X points to leading digit in PAD
0031b7 919f      			pop tosh				; leading char
0031b8 e310      			ldi t1,'0'
0031b9 1197      			cpse tosh,r_zero
0031ba 2f19      			  mov t1,tosh
0031bb 918f      			pop tosl				; print count
0031bc 1988      			sub tosl,#hold			; sub # of converted digits
0031bd f189      			  breq allDOT_finish
0031be f420      			  brcc UDOTR_ten_more
                 
                 	UDOTR_ten_less:
0031bf 1ba8      			sub XL,tosl				; mov X back skipping unused leading digits
0031c0 4fbf      			sbci XH,-1
0031c1 0e88      			add #hold,tosl
0031c2 c004      			rjmp UDOTR_ten_xxx
                 
                 	UDOTR_ten_more:
0031c3 931e      			  st -X,t1				; append leading char to PAD
0031c4 9483      			  inc #hold
0031c5 958a      			dec tosl
0031c6 f7e1      			brne UDOTR_ten_more
                 
                 	UDOTR_ten_xxx:
0031c7 93a1      			st Z+,XL
0031c8 93b1      			st Z+,XH
                 	UDOTR_ten_done:
0031c9 c025      			rjmp allDOT_finish
                 .endif
                 
0031ca dad2      		fdw		UTWOSLASH_L
                 ; U.R  ( u +n -- )				display u unsigned in field of n. 1<n<=255 
                 ;    0 swap <# 1- for # next #s #> type space ;
                 UDOTR_L:
0031cb 7583
0031cc 722e      		.db		NFA|3,"u.r"
                 UDOTR:
0031cd 010c      		movw t3t2,TOP
                 		;poptos					; (dirty: t3t2 unchanged by LESSNUM)
                 		;pushtos				; ZERO 
0031ce 2788      		clr tosl
0031cf 2799      		clr tosh
0031d0 dfc9      		rcall LESSNUM			; (leaves Z = UP)
0031d1 01d0      		movw X,t3t2				; n <= 255 -> byte loop count in XL
                 	  .if optimizeNUM == 1
                 			;movw Z,UP
0031d2 9772      			sbiw Z,(-ubase)
0031d3 8100      			ld t0,Z
0031d4 300a      			cpi t0,10
0031d5 f2f1      			  breq UDOTR_ten
                 	  .endif
0031d6 c003      		rjmp UDOTR_2
                 UDOTR_loop:
0031d7 93af      		  push XL
0031d8 dcf3      		  rcall NUM
0031d9 91af      		  pop XL				; byte loop count
                 UDOTR_2: 
0031da 50a1      		  subi XL,1
0031db f7d8      		brcc UDOTR_loop
                 
0031dc c012      		rjmp allDOT_finish
                 
                 
0031dd dec8      		fdw		SKIP_L
                 ; SIGN ( n -- )					add minus sign if n<0
                 ;	0< IF 2D HOLD THEN ;
                 SIGN_L:
0031de 7384
0031df 6769
0031e0 ff6e      		.db		NFA|4,"sign",0xff
                 SIGN:
0031e1 ff97      		sbrs tosh,7
0031e2 ce4a      		  rjmp DROP
0031e3 e28d      		ldi tosl,'-'
0031e4 cfa7      		rjmp HOLD
                 
                 
0031e5 fc14      		fdw		USLASH_L
                 ; U.  ( u -- )					display u unsigned
                 ;   <# 0 #S #> TYPE SPACE ;
                 UDOT_L:
0031e6 7582
0031e7 ff2e      		.db		NFA|2,"u.",0xff
                 UDOT:
0031e8 d339      		rcall ZERO
                 		;pushtos				; (speed vs. size)
                 		;clr tosl
                 		;clr tosh				; +3 / -7
                 UDOT_0:
0031e9 dfb0      		rcall LESSNUM			;   1 /  42
                 		;rcall PAD_pushed		; (speed vs. size)
                 		;movw Z,UP
                 		;std Z+1,t1
                 		;std Z+0,t0
                 		;clr #hold				;  +4 /  -7
                 
                 
0031ea dd15      		rcall NUMS
                 
0031eb e20d      		ldi t0,'-'
0031ec fd74      		sbrc FLAGS2,fDOTsign
0031ed dfa1      		  rcall NUM_HOLD		; append '-' sign
0031ee 7e7f      		cbr FLAGS2,(1<<fDOTsign)
                 
                 allDOT_finish:
0031ef dfbc      		rcall NUMGREATER
0031f0 d6d3      		rcall TYPE
                 SPACE_A:
0031f1 ce2c      		rjmp SPACE_
                 
                 
0031f2 fbc6      		fdw		UMSTAR_L
                 UDDOT_L:
0031f3 7583
0031f4 2e64      		.db		NFA|3,"ud."
                 ;UDDOT:
0031f5 cff3      		rjmp UDOT_0
                 
                 
0031f6 fce0      		fdw		SLASH_L
                 ; . ( n -- )					display n signed
                 ;	<# DUP ABS #S SWAP SIGN #> TYPE SPACE ;
                 DOT_L:
0031f7 2e81      		.db		NFA|1,"."
                 DOT:
0031f8 2399      		tst tosh
0031f9 f772      		brpl UDOT
0031fa 6170      		  sbr FLAGS2,(1<<fDOTsign)
0031fb 9580      		  com tosl
0031fc 9590      		  com tosh
0031fd 9601      		  adiw TOP,1
0031fe cfe9      		  rjmp UDOT
                 
                 
0031ff f5a6      		fdw		DLESS_L
                 DDOT_L:
003200 6482
003201 002e      		.db		NFA|2,"d.",0
                 ;DDOT:
003202 2399      		tst tosh
003203 f72a      		brpl UDOT_0
003204 6170      		  sbr FLAGS2,(1<<fDOTsign)
003205 940e 3a70 		  call DNEGATE
003207 cfe1      		  rjmp UDOT_0
                 	  
                 
003208 dcd8      		fdw		OPERATOR_L
                 CONSTANT_L:
003209 6388
00320a 6e6f
00320b 7473
00320c 6e61
00320d ff74      		.db		NFA|8,"constant",0xff
                 CONSTANT_:
                 .if optimizingCOMPILER == 0
                 .elif optimizingCOMPILER == 1
00320e 6470      		 	sbr FLAGS2,(1<<fIMMED)	; compile an 'immediate' word
                 			;rcall COLON
00320f d502      			rcall CREATE0
003210 d500      		 	rcall LITERAL_A			; compile 'pushtos   ldi tosl,..   ldi tosh,..'
003211 939a
003212 938a      			pushtos
003213 e28e
003214 ee94      			ldi16 tos,((CONST_yyy<<1)+PFLASH)
003215 d7cb      			rcall INLINE0			; compile CONST_yyy-sequence
                 			;cbr FLAGS2,(1<<fSTATE)	; SEMICOLON
003216 c5a2      		 	rjmp ADD_RETURN_1
                 
                 	CONST_yyy:
003217 fd77      			sbrc FLAGS2,fSTATE
                 			;---------------------------------------------------------------------------
003218 940c 3c95 			  jmp LITERAL			; 'compile' -> compile 'lit' (### must be 'jmp' ###)
                 			;---------------------------------------------------------------------------
00321a 9508      			ret						; 'interpret' - > ready
                 .else .error "illegal value: optimizingCOMPILER"
                 .endif
                 
00321b df14      		fdw		TWOVARIABLE_L
                 TWOCONSTANT_L:
00321c 3289
00321d 6f63
00321e 736e
00321f 6174
003220 746e      		.db		NFA|9,"2constant"
                 TWOCONSTANT_:
003221 de12      		rcall SWOP
003222 d4ef      		rcall CREATE0
003223 d4ed      		rcall LITERAL_A
003224 d4ec      		rcall LITERAL_A
003225 c593      		rjmp ADD_RETURN_1
                 
                 
003226 f7b2      		fdw		WARM_L
                 ; USER  ( n -- )				create user variable
                 USER_L:
003227 7584
003228 6573
003229 ff72      		.db		NFA|4,"user",0xff
                 ;USER:
                 	  .if optimizingCOMPILER == 1
00322a 6270      		sbr FLAGS2,(1<<fINLINE)	; compile 'INLINE'-marked user variable
                 	  .endif
00322b d4e6      		 rcall CREATE0
00322c d4e4      		 rcall LITERAL_A
00322d 7767      		 cbr FLAGS1,(1<<fLIT)|(1<<f2LIT)
00322e 939a
00322f 938a      		 pushtos
003230 e688
003231 ee94      		 ldi16 tos,((XDOUSER<<1)+PFLASH)
003232 d7ae      		 rcall INLINE0
003233 c585      		 rjmp ADD_RETURN_1
                 
                 XDOUSER:
003234 0d82      		 add tosl,upL
003235 1d93      		 adc tosh,upH
003236 9508      		 ret
                 
                 
003237 fb10      		fdw		PAUSE_L
                 ; PARSE  ( char -- c-addr u )								(u < 256)
                 PARSE_L:
003238 7085
003239 7261
00323a 6573      		.db		NFA|5,"parse"
                 PARSE:
00323b 01f1      		movw Z,UP
00323c 9738      		sbiw Z,(-usource)
00323d 91a1      		ld XL,Z+
00323e 91b1      		ld XH,Z+				; a in X
00323f 939a
003240 938a      		pushtos
003241 9181      		ld tosl,Z+
003242 9191      		ld tosh,Z+				; ( c u )
003243 9101      		ld t0,Z+
003244 9111      		ld t1,Z+				; n in t1:t0
003245 0fa0      		add XL,t0
003246 1fb1      		adc XH,t1				; a = a + n in X
003247 01fd      		movw Z,X				; Z: astart
003248 1b80      		sub tosl,t0				; u = u - n (new tib len)
                 		;sbc tosh,t1				; ( c a u )
003249 938f      		push tosl				; 'dup >r'
                 		;push tosh				; ( c a u			R: u )	(u < 256)
00324a 8108      		ldd t0,Y+0				; c in t0
00324b dd20      		rcall SKIP_loop			; ( c astart u' )	Z: astart	t0: c
00324c 010f      		movw t3t2,Z				; ( c astart u'		R: u 	t3t2: astart )
00324d 9624      		adiw Y,4				; ( u' )			Z: astart	t0: c
00324e dd32      		rcall SCAN_loop			; ( aend u" )		Z: aend
                 		;sbiw TOP,0				; valid Z-flag by SCAN
00324f f009      		breq PC+2
003250 9701      		  sbiw TOP,1
003251 19e0      		sub ZL,t2				; astart in t3:t2
003252 09f1      		sbc ZH,t3				; aend-astart (wlen)
003253 8219      		std Y+1,t3
003254 8208      		std Y+0,t2				; ( astart u" )
                 		;pop t1
003255 910f      		pop t0					; 							(u < 256)
003256 1b08      		sub t0,tosl
                 		;sbc t1,tosh			; u = u - u" in t1:t0		(u < 256)
003257 01cf      		movw TOP,Z				; ( astart wlen )
003258 01f1      		movw Z,UP
003259 9734      		sbiw Z,(-utoin)
00325a 91a1      		ld XL,Z+				; u >in +!
00325b 91b1      		ld XH,Z+
00325c 0fa0      		add XL,t0
00325d 1db7      		adc XH,r_zero			;							(u < 256)
00325e 93b2      		st -Z,XH
00325f 93a2      		st -Z,XL
003260 9508      		ret						; ( astart wlen )
                      
                 
003261 0000      	.dw		0
                 ; WORD ( char -- c-addr )		word delimited by char and/or TAB
                 WORD_L:
003262 7784
003263 726f
003264 ff64      		.db		NFA|4,"word",0xff
                 WORD:
003265 dfd5      		rcall PARSE				; c-addr wlen
003266 91e9
003267 91f9      		pop_Z
003268 9382      		st -Z,tosl
003269 2388      		tst tosl				; leave Z-flag for caller
00326a 01cf      		movw TOP,Z
00326b 9508      		ret
                 
                 
00326c f3ae      		fdw		INLINE_L
                 ; IMMED? ( nfa -- f )			fetch immediate flag
                 IMMEDQ_L:
00326d 6986
00326e 6d6d
00326f 6465
003270 ff3f      		.db		NFA|6,"immed?",0xff
                 IMMEDQ: 
003271 940e 3d47 		call CFETCH				; clears tosh
003273 2e98      		mov wflags,tosl  		; COMPILE and INLINE flags for the compiler
003274 7480      		andi tosl,IMMED
                 FINDx: 
003275 9508      		ret
                 
                 
003276 df86      		fdw		HERE_L
                 ; FIND	( c-addr -- c-addr 0 )	if not found
                 ;		(			xt     1 )	if immediate
                 ;		(			xt    -1 )	if normal
                 ; 3 chains of kernel words to speed up search
                 FIND_L:
003277 6684
003278 6e69
003279 ff64      		.db		NFA|4,"find",0xff
                 FIND:   
00327a 939a
00327b 938a      		duptos
                 ;FIND_0:
00327c 01fc      		movw Z,TOP
00327d 9101      		ld t0,Z+
00327e ea8a
00327f ef9a      		ldi16 tos,((kernellink_short<<1)+PFLASH)
003280 3003      		cpi t0,3
003281 f030      		  brcs FIND_1
003282 e388
003283 ee9b      		ldi16 tos,((kernellink_mid<<1)+PFLASH)
003284 3005      		cpi t0,5
003285 f010      		  brcs FIND_1
003286 ea82
003287 ed9c      		ldi16 tos,((kernellink_long<<1)+PFLASH)
                 FIND_1:
003288 d315      		rcall findi
003289 f759      		  brne FINDx
00328a 9180 02bf
00328c 9190 02c0 		lds16 tos,dpLATEST
00328e c30f      		rjmp findi
                 
                 
00328f e536      		fdw		TIB_L
                 ; TI# ( -- n )					size of TIB
                 ;	ti# task @ 8 + @ ;
                 TIBSIZE_L:
003290 7483
003291 2369      		.db		NFA|3,"ti#"
                 TIBSIZE:
003292 939a
003293 938a      		pushtos
                 TIBSIZE_0:
003294 01f1      		movw Z,UP
003295 973e      		sbiw Z,(-utask)
003296 9181      		ld tosl,Z+
003297 9191      		ld tosh,Z+
003298 9608      		adiw TOP,8
003299 c53c      		rjmp FETCH_A
                 
                 
00329a dc52      		fdw		TIU_L
                 ; TIB ( -- a-addr )				Terminal Input Buffer
                 TIB_L:
00329b 74a3
00329c 6269      		.db		NFA|INLINE5|3,"tib"
                 TIB:
00329d 939a
00329e 938a      		pushtos
                 TIB_0:
00329f 01f1      		movw Z,UP
0032a0 9770      		sbiw Z,(-utib)
0032a1 9181      		ld tosl,Z+
0032a2 9191      		ld tosh,Z+				; 6 / 11
0032a3 9508      		ret
                 
                 
0032a4 ed64      		fdw		QABORTQ_L
                 ; >NUMBER ( 0 0 addr u -- ud.l ud.h addr' u' )
                 ;										  0  ) done
                 ;										<>0  ) not a number
                 ;								 convert string in RAM to number (u < 0x100)
                 TONUMBER_L:
0032a5 3e87
0032a6 756e
0032a7 626d
0032a8 7265      		.db		NFA|7,">number"
                 ;TONUMBER:
0032a9 01f1      		movw Z,UP
0032aa 9772      		sbiw Z,(-ubase)
0032ab 80b0      		ld ah,Z					; base in ah
                 
0032ac 91a9
0032ad 91b9      		pop_X					; addr in X
                 TONUMBER_0:
0032ae 2ca6      		mov al,r_one			; init 'not a number'-flag
0032af 2e88      		mov t8,tosl				; u in t8
0032b0 9189
0032b1 9199      		poptos					; ( 0 0 )
0032b2 2088      		tst t8					; ( ud.l ud.h		t8: u )
0032b3 f109      		  breq TONUM_exit
                 TONUM_loop:
0032b4 910d      		  ld t0,X+
0032b5 320e      		  cpi t0,'.'
0032b6 f0d1      			breq TONUM_next
                 ;TONUM_digitQ:				; inline DIGITQ
0032b7 330a      		  cpi t0,0x3a			; ( ud.l ud.h )
0032b8 f018      			brcs TONUM_dQ1
0032b9 3601      		  cpi t0,'a'			; between '9' and 'a'?
0032ba f0c8      		    brcs TONUM_noDIGIT	; ..yes -> no digit
0032bb 5207      		  subi t0,0x27			; close gap
                 TONUM_dQ1:
0032bc 5300      		  subi t0,'0'
0032bd f0b0      			brcs TONUM_noDigit
0032be 150b      		  cp t0,ah				; smaller than base?
0032bf f4a0      		    brcc TONUM_noDigit	; ..no  -> no digit
                 ;			brcs TONUM_digit	; ..yes -> go on with digit
                 
                 TONUM_digit:
                 ;baseStarPlus:				; multiply by base (ah) and add digit (t0)
0032c0 01fc      		  movw t7t6,TOP
0032c1 9deb      		  mul t6,ah
0032c2 01c0      		  movw TOP,R1:R0
0032c3 9dfb      		  mul t7,ah
0032c4 0d90      		  add tosh,R0
0032c5 91e9      		  ld t6,Y+				; ud.l
0032c6 9119      		  ld t1,Y+
0032c7 9deb      		  mul t6,ah
0032c8 01f0      		  movw t7t6,R1:R0
0032c9 9d1b      		  mul t1,ah
0032ca 0fe0      		  add t6,t0				; add digit	
0032cb 1df0      		  adc t7,R0				; ud'.l in t7t6
0032cc 1d81      		  adc tosl,R1			; ud'.h in TOP
0032cd 1d97      		  adc tosh,r_zero
                 		 					; ++++ end baseStarPlus ++++
0032ce 93fa
0032cf 93ea      		  push_t7t6				; ( ud'.l ud'h		t8: u	X: addr )
                 								; 17 / 25
0032d0 2ca7      		  mov al,r_zero			; clear 'not a number'-flag
                 
                 TONUM_next:
0032d1 948a      		dec t8					; ( ud'.l ud'.h 	t8: u-1	X: addr )
0032d2 f709      		brne TONUM_loop
0032d3 f009      		breq TONUM_exit
                 
                 TONUM_noDigit:
0032d4 9711      		  sbiw X,1
                 TONUM_exit:
0032d5 939a
0032d6 938a      		  pushtos
0032d7 93ba
0032d8 93aa      		  push_X
0032d9 2d88      		  mov tosl,t8			; ( ud.l ud.h addr' u' )
0032da 2799      		  clr tosh
0032db 0d8a      		  add tosl,al			; generate 'not a number'-flag, leave valid Z-flag
0032dc 9508      		ret
                 
                 
0032dd d886      		fdw		STAR_L
                 ; ( ( -- )						skip input until ')'
                 PAREN_L:
0032de 28c1      		.db		NFA|IMMED|1,"("
                 ;PAREN:
0032df d40d      		rcall DOLIT
0032e0 0029      		.dw   ')'
0032e1 df59      		rcall PARSE
0032e2 7b6f      		cbr FLAGS1,(1<<doclear)	; don't clear flags in case of '('
0032e3 cd15      		rjmp TWODROP
                 
                 
0032e4 dade      		fdw		TWOSLASH_L
                 TWOMINUS_L:
0032e5 32a2
0032e6 ff2d      		.db		NFA|INLINE|2,"2-",0xff
                 ;TWOMINUS:
0032e7 9702      		sbiw TOP,2				; 1 / 2
0032e8 9508      		ret
                 
                 
                 PLUSC_:
0032e9 9180 02c3 		lds tosl,litbuf0		; optimize 'LIT +'
0032eb b59b      		in  tosh,litbuf1
                 ;PLUSC_0:
0032ec 9580      		com tosl
0032ed 9590      		com tosh
0032ee 9601      		adiw TOP,1
0032ef bd9b      		out litbuf1,tosh
0032f0 d004      		rcall ANDIC1
                 
0032f1 e410      		ldi t1,0x40				; 'sbci ..'
0032f2 c00c      		rjmp ORIC_1
                 
                 ANDIC0:
0032f3 9180 02c3 		lds tosl,litbuf0
                 ANDIC1:
0032f5 d625      		rcall IDP8MINUS
                 ANDIC2:
0032f6 2f98      		mov tosh,tosl
0032f7 9592      		swap tosh
0032f8 708f      		andi tosl,0x0f
0032f9 709f      		andi tosh,0x0f
0032fa 9508      		ret
                 
                 ANDIC_:
0032fb e710      		ldi t1,0x70				; 'andi ..'
0032fc c001      		rjmp ORIC_0
                 
                 ORIC_:							; optimize 'LIT or'
0032fd e610      		ldi t1,0x60				; 'ori ..'
                 ORIC_0:
0032fe dff4      		rcall ANDIC0
                 ORIC_1:
0032ff 6880      		ori tosl,regtosl
003300 2e81      		mov t8,t1
003301 2998      		or tosh,t8				; set op-code
003302 ff95      		sbrs tosh,5
003303 6190      	  	  ori tosh,0x10			; 'subi ..' >< 'sbci ..'
003304 d4b8      		rcall ICOMMA_
                 
003305 939a
003306 938a      		pushtos
003307 b58b      		in tosl,litbuf1
003308 dfed      		rcall ANDIC2
003309 6980      		ori tosl,regtosh
00330a 2998      		or tosh,t8				; set op-code
00330b c4b1      		rjmp ICOMMA_
                 
                 MINUSC_:
00330c e410      		ldi t1,0x40				; 'sbci ..'
00330d cff0      		rjmp ORIC_0
                 
                 
00330e fac6      		fdw		CSTORE_L
                 ; BL ( -- char )				ASCII space
                 BL_L:
00330f 62a2
003310 ff6c      		.db		NFA|INLINE4|2,"bl",0xff
                 BL:
003311 939a
003312 938a      		pushtos
                 ;BL_0:
003313 e280      		ldi tosl,' '
003314 e090      		ldi tosh,0x00			; 4 / 6
003315 9508      		ret
                 
                 BL_WORD:
003316 939a
003317 938a      		pushtos
003318 e280      		ldi tosl,' '
003319 cf4b      		rjmp WORD
                 
                 
                 .if optimizingCOMPILER == 1
                 	SWOP_C_:						; fdw SWOP in TOP
00331a d4a3      			rcall ldi16_t1t0_C_
00331b ef8a
00331c ee92      			ldi16 tos,((t1t0_to_NEXT<<1)+PFLASH)
00331d c6c3      			rjmp INLINE0
                 
                 	STARIC_:						; fdw STAR in TOP
00331e d49f      			rcall ldi16_t1t0_C_
00331f 9604      			adiw TOP,(STAR_0 - STAR)*2
003320 b51b      			in t1,litbuf1
003321 1117      			cpse t1,r_zero
003322 c6be      			  rjmp INLINE0			; -> fdw STAR_0
                 			  					; shorter for LIT < 0x100
003323 e002      			ldi t0,2
003324 d5f7      			rcall IDPMINUS			; drop 'ldi t1,<lit1>'
003325 9744      			sbiw TOP,(STAR_0 - cSTAR_0)*2
003326 c6ba      			rjmp INLINE0			; -> fdw cSTAR_0
                 
                 	ULESSC_:						; fdw ULESS in TOP
003327 9688      			adiw TOP,40				; -> fdw UGREATER_0	(+24) (TOP >< t1:t0 swapped at exec time)
                 
                 	UGREATERC_:						; fdw UGREATER in TOP
003328 9604      			adiw TOP,4				; -> fdw ULESS_0 	(-16) (TOP >< t1:t0 swapped at exec time)
                 
                 	GREATERC_:						; fdw GREATER in TOP
003329 9744      			sbiw TOP,20				; -> fdw LESS_0		(-20) (TOP >< t1:t0 swapped at exec time)
                 			
00332a d015      			rcall checkDUP			; 'dup' preceeding 'LIT'?
00332b 6061      			sbr FLAGS1,(1<<icarryeq)
00332c e008      			ldi t0,8
00332d fd65      			sbrc FLAGS1,idup
00332e e00c      			  ldi t0,12
00332f e010      			ldi t1,regt1t0
003330 d48f      			rcall ldi16_thtl_C_DUP_
003331 c6af      			rjmp INLINE0
                 
                 	LESSC_:							; fdw LESS in TOP
003332 9680      			adiw TOP,32				; -> fdw GREATER_1	(+32) (TOP >< t1:t0 swapped at exec time)
003333 939a
003334 938a      			pushtos
003335 dfd6      			rcall MINUSC_
003336 6061      			sbr FLAGS1,(1<<icarryeq)
003337 c6a9      			rjmp INLINE0
                 
                 	EQUALC_:						; fdw EQUAL in TOP
003338 d007      			rcall checkDUP			; 'dup' preceeding 'LIT'?
003339 dfd2      			rcall MINUSC_
00333a 6164      			sbr FLAGS1,(1<<izeroeq)|(1<<iLITeq)
00333b 939a
00333c 938a
00333d e984
00333e ed9b      			inline_DOLIT ((ZEROEQUAL<<1)+PFLASH)
00333f c6a1      			rjmp INLINE0
                 
                 	checkDUP:						; look for 'dup' preceeding LIT
003340 7d6f      			cbr FLAGS1,(1<<idup)
003341 d3c2      			rcall IHERE
003342 970c      			sbiw TOP,12
003343 d492      			rcall FETCH_A			; (valid addr+2 returned in Z)
003344 598a      			subi tosl, LOW(0x939a)	; 'pushtosH'?
003345 4993      			sbci tosh,HIGH(0x939a)
003346 f409      			  brne checkDUP_non
                 			;rcall FETCH_Zplus		; (skip check to save space)
                 			;subi tosl, LOW(0x938a)	; 'pushtosL'?
                 			;sbci tosh,HIGH(0x938a)
                 			;  brne _noDUP
003347 6260      			sbr FLAGS1,(1<<idup)
                 	checkDUP_non:
003348 cce4      			rjmp DROP
                 
                 	optMEM_helper:
003349 dff6      			rcall checkDUP			; optimize 'dup LIT !' 'dup LIT c!'
00334a 9180 02c3 			lds tosl,litbuf0
00334c b59b      			in  tosh,litbuf1
00334d c5cd      			rjmp IDP8MINUS
                 
                 	STOREC_2LIT:
00334e d46f      			rcall ldi16_t1t0_C_
00334f e1a0      			ldi t4,regt1			; register 0x11 -> t1
003350 d22c      			rcall comp_sts_
003351 c22a      			rjmp comp_sts_t0
                 
                 	STOREC_:
003352 dff6      			rcall optMEM_helper
003353 939a
003354 938a      			duptos
003355 9601      			adiw TOP,1				; high byte <addr+1>
003356 fd63      			sbrc FLAGS1,f2LIT
003357 cff6      			  rjmp STOREC_2LIT
                 	STOREC_1LIT:
003358 fd65      			sbrc FLAGS1,idup
003359 d5bd      			  rcall IDP4MINUS
00335a e9a0      			ldi t4,regtosh			; register 0x19 -> tosh
00335b d221      			rcall comp_sts_
00335c c005      			rjmp STOREC_helper
                 
                 	CSTOREC_:
00335d dfeb      			rcall optMEM_helper
00335e fd63      			sbrc FLAGS1,f2LIT
00335f c00d      			  rjmp CSTOREC_2LIT
                 	CSTOREC_1LIT:
003360 fd65      			sbrc FLAGS1,idup
003361 d5b5      			  rcall IDP4MINUS
                 	STOREC_helper:
003362 e8a0      		 	ldi t4,regtosl			; register 0x18 -> tosl
003363 d219      			rcall comp_sts_
003364 fb65      			bst FLAGS1,idup
003365 f416      			brtc STOREC_help2
003366 7d6f      			  cbr FLAGS1,(1<<idup)
003367 9508      	 		  ret
                 	STOREC_help2:
003368 939a
003369 938a      			pushtos
00336a e58a
00336b ee90      			ldi16 tos,((DROP<<1)+PFLASH)
00336c c674      			rjmp INLINE0
                 
                 	CSTOREC_2LIT:
00336d d450      			rcall ldi16_t1t0_C_
00336e e002      			ldi t0,2
00336f d5ac      			rcall IDPMINUS			; wipe 'ldi t1,<lit.1>'
003370 c20b      			rjmp comp_sts_t0	
                 .endif
                 
                 SWOP_A:
003371 ccc2      		rjmp SWOP
                 
003372 e4da      		 fdw		IMMEDQ_L
                 IFLUSH_L:
003373 6986
003374 6c66
003375 7375
003376 ff68      		.db		NFA|6,"iflush",0xff
                 IFLUSH:
003377 99f1      		sbic FLAGS3,idirty
003378 c4ba      		  rjmp IWRITE_BUFFER
003379 9508      		ret
                 
                 
00337a 0000      		.dw		0
                 ; INTERPRET ( c-addr u -- )		interpret given buffer (in RAM)
                 INTERPRET_L:
00337b 6989
00337c 746e
00337d 7265
00337e 7270
00337f 7465      		.db		NFA|9,"interpret"
                 INTERPRET:
003380 9109
003381 9119      		pop_t1t0
003382 01d1      		movw X,UP
003383 9718      		sbiw X,(-usource)
003384 930d      		st X+,t0
003385 931d      		st X+,t1
003386 938d      		st X+,tosl
003387 939d      		st X+,tosh
003388 9189
003389 9199      		poptos
00338a 927d      		st X+,r_zero			; utoin
00338b 927d      		st X+,r_zero
                 IPARSEWORD:
00338c df89      		rcall BL_WORD
00338d f409      		brne PC+2				; valid Z-flag left by 'WORD'
00338e cc9e      		  rjmp DROP				; no word -> stop interpreting
00338f deea      		rcall FIND 				; sets wflags, leaves valid Z-flag
                 						; 0 = not found, -1 = normal, 1 = immediate
003390 9189
003391 9199      		poptos
003392 f409      		brne PC+2				; valid Z-flag by FIND
003393 c087      		  rjmp INUMBER			; 'not found' -> is it a number?
003394 f412      		brpl IPARSEWORD_3		; 'immediate'
003395 fd77      		sbrc FLAGS2,fSTATE
003396 c012      		  rjmp ICOMPILE_1		; 'normal & compiling' -> go compile
                 IPARSEWORD_3:
                 								; ..'immediate' or 'interpreting'
003397 fc94      		sbrc wflags,COMPILEbit
003398 fd77      		sbrc FLAGS2,fSTATE
003399 c009      		  rjmp IEXECUTE			; (not a compile only word) OR ('compile only' && 'compiling') -> execute
00339a d4cb      		rcall XSQUOTE
00339b 430c
00339c 4d4f
00339d 4950
00339e 454c
00339f 4f20
0033a0 4c4e
0033a1 ff59      		.db 12,"COMPILE ONLY",0xff
0033a2 c324      		rjmp QABORT_1
                 IEXECUTE:
0033a3 6460      		sbr FLAGS1,(1<<doclear)
0033a4 940e 3ec5 		call EXECUTE
0033a6 fd66      		sbrc FLAGS1,doclear		; cleared by '\', '(', 'literal' and 'constant'
0033a7 7462      		  cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)|(1<<iLITeq)|(1<<idup)|(1<<fLIT)|(1<<f2LIT)
0033a8 cfe3      		rjmp IPARSEWORD
                 
                 ICOMPILE_1:
0033a9 7e6e      		cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)
                 								; check for 0=, modifies IF, WHILE and UNTIL to use brne
0033aa ed1b      		ldi t1, HIGH((ZEROEQUAL<<1) + PFLASH)
0033ab 3984      		cpi tosl,LOW((ZEROEQUAL<<1) + PFLASH)
0033ac 0791      		cpc tosh,t1
0033ad f411      		  brne ICOMPILE_2
0033ae 6160      		sbr FLAGS1,(1<<izeroeq)	; mark '0= encountered in compilation'
0033af c061      		rjmp ICOMPILE
                 
                 ICOMPILE_2:
0033b0 ff67      		sbrs FLAGS1,fLIT
0033b1 c059      		  rjmp ICOMPILE_00
                 								; optimize if LIT is preceeding
                 .if optimizingCOMPILER == 0
                 .elif optimizingCOMPILER == 1
                 
0033b2 ed17      			ldi t1,HIGH(FLASH_HI)		; LIT-optimization for kernel words only
0033b3 36e7      			cpi ZL, LOW(FLASH_HI)
0033b4 07f1      			cpc ZH,t1
0033b5 f050      			  brcs no_opt
                 
0033b6 eae6
0033b7 e6f7      			ldi16 Z,(optTAB*2)
0033b8 e2a1      			ldi t4,optTAB_count
                 	optLoop:
0033b9 9105      			  lpm t0,Z+
0033ba 9115      			  lpm t1,Z+
0033bb 1780      			  cp  tosl,t0
0033bc 0791      			  cpc tosh,t1
0033bd f019      			    breq foundOpt
0033be 95aa      			dec t4
0033bf f7c9      			brne optLoop			; 12 ticks per entry -> 375 for optTAB_count=31
0033c0 c04a      	no_opt:	  rjmp ICOMPILE_00		; -> go on with no opt found
                 	
                 	foundOpt:
0033c1 30a7      			cpi t4,WORDIC_check
0033c2 f418      			brcc fO_yyy
                 			  					; WORDIC_ optimization		
0033c3 d3fa      			  rcall ldi16_t1t0_C_	; replace LIT by 'ldi t0,<lit.0> ldi t1,<lit.1>'
0033c4 9604      			  adiw TOP,4			; skip 'pop_t1t0' at beginning of word
0033c5 c04b      			  rjmp ICOMPILE
                 
                 		fO_yyy:
0033c6 30ab      			cpi t4,PEEPROMcheck
0033c7 f420      			brcc fO_xxx
0033c8 b51b      			  in t1,litbuf1			; optimize '@', 'c@', '!', 'c!'
0033c9 3019      			  cpi t1,HIGH(PEEPROM)	; ..for ram access only (lit.1 < PEEPROM)
0033ca f7a8      			    brcc no_opt			; -> go on with no opt
0033cb 9738      			  sbiw Z,8
                 
                 		fO_xxx:
0033cc 5ce0      			subi ZL, LOW(-(optTAB_count*2-2))
0033cd 4fff      			sbci ZH,HIGH(-(optTAB_count*2-2))
0033ce 9105      			lpm t0,Z+				; read address of .... opt routine
0033cf 9115      			lpm t1,Z+
0033d0 01f8      			movw Z,t1t0
0033d1 9509      			icall					; call opt routine
0033d2 c046      			rjmp ICLRFLIT			; clear fLIT and f2LIT, go on parsing
                 
                 	.equ optTAB_count = 33
                 	.equ WORDIC_check =  7
                 	.equ PEEPROMcheck = WORDIC_check + 4
                 
                 	optTAB:
0033d3 da60      		fdw AND_
0033d4 da70      		fdw OR_
0033d5 e0e6      		fdw PLUS
0033d6 e2d4      		fdw MINUS
0033d7 d888      			fdw STAR
0033d8 e1f4      			fdw NOTEQUAL
0033d9 e202      			fdw EQUAL
0033da e248      			fdw ULESS
0033db e25c      			fdw UGREATER
0033dc e216      			fdw LESS
0033dd e22e      			fdw GREATER
0033de e068      			fdw SWOP
0033df d8f0      			fdw TO_A
0033e0 e270      			fdw STORE_P
0033e1 e2a6      			fdw STORE_P_TO_R
0033e2 dcfa      			fdw MSET
0033e3 dd14      			fdw MCLR
0033e4 dd48      			fdw MTST
0033e5 dd30      			fdw MTSTZ
0033e6 db42      			fdw MSTORE
0033e7 db74      			fdw MCSTORE
0033e8 db58      			fdw MFETCH
0033e9 db66      			fdw MCFETCH
                 		;.equ PEEPROMcheck = WORDIC_check + 4
0033ea faac      			fdw STORE				; words requiring an address check 'in RAM?'
0033eb faca      			fdw CSTORE
0033ec fa7c      			fdw FETCH
0033ed fa8e      			fdw CFETCH
                 		;.equ WORDIC_check = 7
0033ee da80      			fdw XOR_				; words not requiring a special routine
0033ef da36      			fdw UMIN				; .. by simply loading LIT to t1:t0
0033f0 da4c      			fdw UMAX
0033f1 fd3e      			fdw MIN
0033f2 fd22      			fdw MAX
0033f3 fb86      			fdw SCALE
                 
0033f4 32fb      		.dw ANDIC_
0033f5 32fd      		.dw ORIC_
0033f6 32e9      		.dw PLUSC_
0033f7 330c      		.dw MINUSC_
0033f8 331e      			.dw STARIC_
0033f9 330c      			.dw MINUSC_
0033fa 3338      			.dw EQUALC_
0033fb 3327      			.dw ULESSC_
0033fc 3328      			.dw UGREATERC_
0033fd 3332      			.dw LESSC_
0033fe 3329      			.dw GREATERC_
0033ff 331a      			.dw SWOP_C_
003400 313c      			.dw TO_A_C_
003401 314c      			.dw STORE_P_C_
003402 3140      			.dw STORE_P_TO_R_C_
003403 3571      			.dw MSETC_
003404 3558      			.dw MCLRC_
003405 353c      			.dw MTSTC_
003406 3527      			.dw MTSTZC_
                 
003407 3352      			.dw STOREC_
003408 335d      			.dw CSTOREC_
003409 3cae      			.dw FETCHC_
00340a 3cb2      			.dw CFETCHC_
                 		; PEEPROMcheck ...
                 			;.dw STOREC_		; same as above
                 			;.dw CSTOREC_
                 			;.dw FETCHC_
                 			;.dw CFETCHC_
                 		; WORDIC_check - no entries needed
                 .else .error "illegal value: optimizingCOMPILER"
                 .endif
                 
                 ICOMPILE_00:
00340b 7d6f      		cbr FLAGS1, (1<<idup)	; clear 'DUP encountered in compilation'
00340c ed1b      		ldi t1, HIGH((DUP<<1) + PFLASH)
00340d 3888      		cpi tosl,LOW((DUP<<1) + PFLASH)
00340e 0791      		cpc tosh,t1				; check for DUP, modies IF and UNTIL to use DUPZEROSENSE
00340f f409      		brne ICOMPILE
003410 6260      		  sbr FLAGS1,(1<<idup)	; mark DUP encountered during compilation
                 ICOMPILE:
003411 fe95      		sbrs wflags,INLINEbit	; inline check
003412 c002      		  rjmp ICOMMAXT
003413 d5cd      		rcall INLINE0
003414 c004      		rjmp ICLRFLIT
                 
                 ICOMMAXT:
003415 dbbc      		rcall COMMAXT
003416 7f6d      		cbr FLAGS1,(1<<fTAILC)	; allow tail jump  optimization
003417 fc94      		sbrc wflags,COMPILEbit	; compile only ?
003418 6062      		  sbr FLAGS1,(1<<fTAILC); ->  prevent tail jump  optimization
                 ICLRFLIT:
003419 7767      		cbr FLAGS1,(1<<fLIT)|(1<<f2LIT)
00341a cf71      		rjmp IPARSEWORD
                 
                 INUMBER: 
00341b 7c62      		cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)|(1<<iLITeq)|(1<<idup)|(1<<f2LIT)
                 ;		poptos
00341c d031      		rcall NUMBERQ
00341d 9700      		sbiw TOP,0
00341e f071      		  breq IUNKNOWN
00341f ff77      		sbrs FLAGS2,fSTATE
003420 c009      		  rjmp INUMBER1			; 'interpret' -> 
003421 2f08      		mov t0,tosl
003422 9189
003423 9199      		poptos
003424 ff01      		sbrs t0,1
003425 c002      		  rjmp ISINGLE
                 IDOUBLE:
003426 dc0d      		rcall SWOP
003427 d2e9      		rcall LITERAL_A
                 ISINGLE:
003428 d2e8      		rcall LITERAL_A
003429 cf62      		rjmp IPARSEWORD
                 
                 INUMBER1:
00342a 9189
00342b 9199      		poptos
00342c cfec      		rjmp ICLRFLIT
                 
                 IUNKNOWN:
00342d 7767      		cbr FLAGS1,(1<<fLIT)|(1<<f2LIT)
00342e 9189
00342f 9199      		poptos
003430 d0b0      		rcall DP_TO_RAM
003431 d6ef      		rcall CFETCHPP
003432 d491      		rcall TYPE
003433 c286      		rjmp QABORTQ_0			; never returns & resets the stacks
                 
                 
                 ; DOCREATE						 code action of CREATE
                 ; fetch the next cell from program memory to the parameter stack
                 DOCREATE_L:
003434 2883
003435 2963      		.db		NFA|3, "(c)"	; just for 'see' to work
                 DOCREATE:
                 		m_pop_zh
003436 91ff      		pop ZH
003437 91ef      		pop ZL
                 		;rjmp FETCHLIT
                 FETCHLIT:
003438 939a
003439 938a      		pushtos
00343a 0fee      		lsl ZL
00343b 1fff      		rol ZH
00343c 9185      		lpm_ tosl,Z+
00343d 9195      		lpm_ tosh,Z+			; 6 / 12 (FETCHLIT), 8 / 16 (DOCREATE)
00343e 9508      		ret
                 
                 
00343f 2883
003440 292c      		.db		NFA|3, "(,)"	; just for 'see' to work
                 DOCOMMAXT:
                 		m_pop_t0
003441 91ff      		pop ZH
003442 91ef      		pop ZL
003443 dff4      		rcall FETCHLIT
003444 95f7      		ror ZH					; C-flag set by FETCHLIT
003445 95e7      		ror ZL
003446 93ef      		push ZL
003447 93ff      		push ZH
                 		m_push_t0
003448 cb89      		rjmp COMMAXT
                 
                 
003449 d822      		fdw		TICKStoNEXT_L
                 ; NUMBER?	( c-addr --     n  1 ) single
                 ;			(		 -- dl dh  2 ) double
                 ;			(		 -- c-addr 0 ) if convert error
                 ;                               string in RAM
                 NUMBERQ_L:
00344a 6e87
00344b 6d75
00344c 6562
00344d 3f72      		.db		NFA|7,"number?"
                 NUMBERQ:
00344e 939a
00344f 938a      		duptos					; ( a a )  (for the 'not a number'-case)
003450 927a      		st -Y,r_zero
003451 927a      		st -Y,r_zero
003452 927a      		st -Y,r_zero
003453 927a      		st -Y,r_zero			; ( a 0 0 a )
003454 01dc      		movw X,TOP
003455 918d      		ld tosl,X+
003456 2799      		clr tosh				; ( a 0 0 u )	X: a+1
003457 910c      		ld t0,X				; inline 'sign?'
003458 520b      		subi t0,'+'
003459 f021      		  breq isSign
00345a 3002      		cpi t0,2				; '-'
00345b f011      		  breq isSign
00345c 2700      		clr t0
00345d c002      		rjmp prefix
                 isSign:
00345e 9701      		  sbiw TOP,1			; ( a 0 0 u-1 )
00345f 9611      		  adiw X,1				;				X: a+1
                 prefix:
003460 930f      		push t0					; save sign
                 
003461 01f1      		movw Z,UP				; get current base
003462 9772      		sbiw Z,(-ubase)
003463 80b0      		ld ah,Z
                 
003464 910c      		ld t0,X					; check for base-prefix
003465 5203      		subi t0,'#'
003466 f021      		  breq baseQ_dec		; '#' (=0)
003467 3002      		cpi t0,2
003468 f019      		  breq baseQ_bin		; '%' (=2)
003469 f428      		  brcc BASEQ1			; no prefix
                 baseQ_hex:						; '$' (=1)
00346a 5f0b      		subi t0,-5
                 baseQ_dec:
00346b 5f06      		subi t0,-10
                 
                 baseQ_bin:
00346c 2eb0      		mov ah,t0				; set temporary base (from prefix)
00346d 9701      		sbiw TOP,1				; ( a 0 0 u-1 )
00346e 9611      		adiw X,1				;				X: a+1
                 BASEQ1:
00346f de3e      		rcall TONUMBER_0		; ( a ud.l ud.h a' 0/u' )	X: a'	valid Z-flag
003470 f4a9      		  brne QNUM_ERR
                 
003471 9622      		adiw Y,2				; ( a ud.l ud.h 0 )			X: a'
003472 918e      		ld tosl,-X				; read last char from buf (in RAM)
                 
003473 328e      		cpi tosl,'.'			; check for 'double'-sign
003474 9189
003475 9199      		poptos					; ( a ud.l ud.h )
003476 910f      		pop t0					;				t0: sign
003477 f431      		  brne QNUM_single
                 ;QNUM_double:
003478 1107      		cpse t0,r_zero
003479 d5f6      		  rcall DNEGATE
00347a d7d6      		rcall ROT				; ( d.l d.h a )
00347b e082      		ldi tosl,2				; ( d.l d.h 2 )	- double precision number
00347c e090      		ldi tosh,0
00347d 9508      		ret
                 
                 QNUM_single:
00347e 9189
00347f 9199      		poptos					; ( a ud.l )	t0: sign
003480 1107      		cpse t0,r_zero
003481 d6c1      		  rcall NEGATE
003482 8399      		std Y+1,tosh			; ( d.l d.l )
003483 8388      		std Y+0,tosl
003484 01c3      		movw TOP,r_one			; ( d.l 1 ) 	- single precision number
003485 9508      		ret
                 
                 QNUM_ERR:					; not a number
003486 910f      		pop t0					; drop sign-flag from R
003487 9626      		adiw Y,6
003488 2788      		clr tosl				; ( a 0 ) 		- not a number
003489 2799      		clr tosh
00348a 9508      		ret
                 
                 
                 ;.equ partlen = strlen(partstring)
                 .equ datelen = strlen(DATE)
                 
00348b f8b8      		fdw		WDON_L
                 VER_L:
00348c 7683
00348d 7265      		.db		NFA|3,"ver"
                 VER:
00348e d3d7      		rcall XSQUOTE
                 		;        123456789012345678901234567890123456    7
                 		;.db 37," OptiForth 5.6d ATmega328 dd.mm.yyyy",0xd
00348f 2025
003490 704f
003491 6974
003492 6f46
003493 7472
003494 2068
003495 2e35
003496 6436
003497 4120
003498 6d54
003499 6765
00349a 3361
00349b 3832
00349c 3120
00349d 2e30
00349e 3130
00349f 322e
0034a0 3230
0034a1 0d32      		.db 27+datelen," OptiForth 5.6d ATmega328 ",DATE,0xd		;partstring
0034a2 c421      		rjmp TYPE
                 
                 
0034a3 f2d6      		fdw		ZEROIF_L
                 ; .st ( -- )					output a string with current data section and current base info
                 ;	base @ dup decimal <#  [char] , hold #s  [char] < hold #> type 
                 ;	<# [char] > hold cse @ #s #> type base ! ;
                 DOTSTATUS_L:
0034a4 2e83
0034a5 7473      		.db		NFA|3,".st"
                 DOTSTATUS:
0034a6 e30c      		ldi t0,'<'
0034a7 d2ca      		rcall EMIT_t0
                 		;rcall DOTBASE
                 ;DOTBASE:					; ++++ begin inline DOTBASE ++++
0034a8 01f1      		movw Z,UP
0034a9 9772      		sbiw Z,(-ubase)
0034aa 8110      		ld t1, Z				; base in t1
0034ab e204      		ldi t0,'$'				; hex
0034ac 3110      		cpi t1,0x10
0034ad f039      		  breq DOTBASE_done
                 ;		ldi t0,'%'				; bin
                 ;		cpi t1,2				; replaced by '2'
                 ;		  breq DOTBASE_done
0034ae e203      		ldi t0,'#'				; decimal
0034af 301a      		cpi t1,10
0034b0 f021      		  breq DOTBASE_done
0034b1 e30f      		ldi t0, '?'
0034b2 f410      		  brcc DOTBASE_done
0034b3 5d10      		subi t1,-'0'			; less than #10 -> display as decimal digit
0034b4 2f01      		mov t0,t1
                 DOTBASE_done:					; ++++ end inline ++++
0034b5 d2bc      		rcall EMIT_t0
0034b6 e20c      		ldi t0,','
0034b7 d2ba      		rcall EMIT_t0
                 		;rcall MEMQ
                 
                 ; M? ( -- caddr count )			current data space string
                 MEMQ:						; +++ begin inline MEMQ +++
0034b8 939a
0034b9 938a      		pushtos
0034ba b5ea      		in ZL,cse
0034bb 27ff      		clr ZH
0034bc 59e2      		subi ZL, LOW(-(MEMQADDR_N<<1))
0034bd 4af8      		sbci ZH,HIGH(-(MEMQADDR_N<<1))
0034be 9185      		lpm tosl,Z+
0034bf 9195      		lpm tosh,Z+
0034c0 d660      		rcall CFETCHPP
0034c1 708f      		andi tosl,NFAmask
                 							; +++ end inline +++
0034c2 d401      		rcall   TYPE
0034c3 e30e      		ldi t0,'>'
0034c4 d2ad      		rcall EMIT_t0
0034c5 c3e9      		rjmp DOTS
                 
                 
                 ; >dp ( -- )					copy (only changed) turnkey, dp's and latest from RAM to EEPROM
0034c6 3e83
0034c7 7064      		.db		NFA|3,">dp"		; just for 'see' to work
                 DP_TO_EEPROM:
0034c8 e0e9
0034c9 e0f0      		ldi16 Z,(dp_start+9-PEEPROM)
0034ca eca1
0034cb e0b2      		ldi16 X,(dpSTART+10)
                 DP_TO_EEPROM_loop:
0034cc 99f9
0034cd cffe      DTE_wait: sbic EECR,EEWE	rjmp DTE_wait	; EEPROM ready?
                 
0034ce bdf2      		  out EEARH,ZH
0034cf bde1      		  out EEARL,ZL
0034d0 ba6f      		  out EECR,r_one		; (1<<EERE)
0034d1 b500      		  in t0,EEDR
0034d2 911e      		  ld t1,-X
0034d3 1701      		  cp t0,t1
0034d4 f039      		  breq DP_TO_EEPROM_0
0034d5 bd10      			out EEDR,t1			; value changed -> write to EEPROM
0034d6 b70f      			in_ t0,SREG
0034d7 94f8      			cli
0034d8 e014      			ldi t1,(EEMPE<<1)
0034d9 bb1f      			out EECR,t1
0034da 9af9      			sbi EECR,EEWE
0034db bf0f      			out_ SREG,t0
                 		  .if DEBUG_FLASH == 1
                 		  .endif
                 DP_TO_EEPROM_0:
0034dc 50e1      		subi ZL,1				; dp_start on page boundary!!
0034dd f770      		brcc DP_TO_EEPROM_loop
0034de 9508      		ret
                 
                 
                 ; dp> ( -- )					copy ini, dps and latest from EEPROM to RAM
0034df 6483
0034e0 3e70      		.db		NFA|3,"dp>"		; just for 'see' to work
                 DP_TO_RAM:
0034e1 e0e9
0034e2 e0f0      		ldi16 Z,(dp_start+9-PEEPROM)
0034e3 eca1
0034e4 e0b2      		ldi16 X,(dpSTART+10)
                 
0034e5 99f9
0034e6 cffe      DTR_wait: sbic EECR,EEWE     rjmp DTR_wait	; EEPROM ready?
                 
0034e7 bdf2      		  out EEARH,ZH
                 DP_TO_RAM_loop:
0034e8 bde1      		  out EEARL,ZL
0034e9 ba6f      		  out EECR,r_one		; (1<<EERE)
0034ea b510      		  in t1,EEDR
0034eb 931e      		  st -X,t1
0034ec 50e1      		subi ZL,1				; dp_start on page boundary!!
0034ed f7d0      		brcc DP_TO_RAM_loop
0034ee 9508      		ret
                 
                 
0034ef f67e      		fdw		NEGATE_L
                 ; LSHIFT ( x1 u -- x2 )			shift left u bit positions
                 LSHIFT_L:
0034f0 6c86
0034f1 6873
0034f2 6669
0034f3 ff74      		.db		NFA|6,"lshift",0xff
                 ;LSHIFT:
0034f4 01fc      		movw Z,TOP
0034f5 9189
0034f6 9199      		poptos
                 LSHIFT1:
0034f7 9731      		  sbiw Z,1
0034f8 f122      			brmi SHIFT_ret
0034f9 0f88      		  lsl tosl
0034fa 1f99      		  rol tosh
0034fb cffb      		rjmp LSHIFT1
                 	
                 
0034fc f9ae      		fdw		SOURCE_L
                 ; RSHIFT ( x1 u -- x2 )			shift right u bit positions
                 RSHIFT_L:
0034fd 7286
0034fe 6873
0034ff 6669
003500 ff74      		.db		NFA|6,"rshift",0xff
                 ;RSHIFT:
003501 01fc      		movw Z,TOP
003502 9189
003503 9199      		poptos
                 RSHIFT1:
003504 9731      		  sbiw Z,1
003505 f0ba      			brmi SHIFT_ret
003506 9596      		  lsr tosh
003507 9587      		  ror tosl
003508 cffb      		rjmp RSHIFT1
                 
                 
003509 df56      		fdw		EEPROM_L
                 ; DIGIT? ( c -- n f )			check char for beeing a valid digit (base < 0xd0)
                 DIGITQ_L:
00350a 6486
00350b 6769
00350c 7469
00350d ff3f      		.db		NFA|6,"digit?",0xff
                 ;DIGITQ:						; '0' = 0x30    'a' = 0x61
00350e 338a      		cpi tosl,0x3a
00350f f018      		  brcs DIGITQ1
003510 3681      		cpi tosl,0x61
003511 f080      		  brcs FALSE_
003512 5287      		subi tosl,0x27
                 DIGITQ1:
003513 5380      		subi tosl,0x30			; '0'
003514 f068      		  brcs FALSE_
003515 939a
003516 938a      		duptos
003517 01f1      		movw Z,UP
003518 9772      		sbiw Z,(-ubase)
003519 8190      		ld tosh,Z				; base in tosh
00351a 1b89      		sub tosl,tosh			; n < base -> C -> TRUE
00351b 0b88      		sbc tosl,tosl
00351c 0b99      		sbc tosh,tosh
                 SHIFT_ret:
00351d 9508      		ret
                 
                 
00351e df4a      		fdw		FLASH_L
                 FALSE_L:
00351f 66a5
003520 6c61
003521 6573      		.db		NFA|INLINE4|5,"false"
                 FALSE_:							; put 0000 (FALSE) on data stack
                 ZERO:
003522 939a
003523 938a      		pushtos
                 ;FALSE_pushed:
003524 2788      		clr tosl
003525 2799      		clr tosh				; 4 / 6
003526 9508      		ret
                 
                 
                 .if optimizingCOMPILER == 1
                 	; bit testing 8 bits (for RAM addresses only)
                 	; ( mask addr -- )   (NO flag on stack - to be used with '0until' and '0if')
                 	MTSTZC_:						; fdw MTSTZ in TOP
003527 d3f3      			rcall IDP8MINUS
003528 ff63      			sbrs FLAGS1,f2LIT
003529 c009      			  rjmp MTSTZC_1LIT
                 	MTSTZC_2LIT:
00352a d3f0      			rcall IDP8MINUS			; leaves dpFLASH in Z
00352b 01cf      			movw TOP,Z
00352c 9604      			adiw TOP,4
00352d d2a8      			rcall FETCH_A			; 'ldi tosl,mask'
00352e 709f      			andi tosh,0x0f
00352f 6790      			ori tosh,HIGH(0x7000)	; 'andi tosl,mask'
003530 708f      			andi tosl,0x0f			; 'andi t0  ,mask'
003531 d01d      			rcall comp_lds_t0
003532 c78e      			rjmp ICOMMA
                 
                 	MTSTZC_1LIT:
003533 d01b      			rcall comp_lds_t0
003534 e880
003535 e293      			ldi16 tos,0x2380		; 'and tosl,t0'
003536 d78a      			rcall ICOMMA
003537 939a
003538 938a      			pushtos
003539 e58a
00353a ee90      			ldi16 tos,((DROP<<1) + PFLASH)
00353b c4a5      			rjmp INLINE0
                 	
                 	; bit testing 8 bits (for RAM addresses only)
                 	; ( mask addr -- f )		
                 
                 	MTSTC_:							; fdw MTST in TOP
00353c d3de      			rcall IDP8MINUS
00353d ff63      			sbrs FLAGS1,f2LIT
00353e c009      			  rjmp MTSTC_1LIT
                 	MTSTC_2LIT:
00353f d1c4      			rcall IHERE
003540 9704      			sbiw TOP,4
003541 d294      			rcall FETCH_A			;   'ldi tosl,<lit1.0>'
003542 709f      			cbr tosh,0xf0
003543 6790      			ori tosh,HIGH(0x7000)	;->'andi tosl,<lit1.0>'
003544 d3d2      			rcall IDP4MINUS			; "wipe" 'ldi tosl,<lit1.0>    ldi tosh,<lit1.1>'
003545 e8a0      			ldi t4,regtosl			; register 0x18 -> tosl
003546 d009      			rcall comp_lds_t4		; 'in/lds  tosl,<addr>'
                 			;rcall ICOMMA			; 'andi tosl,<lit1.0>'
                 			;rjmp ldi_tosh_0_C_		; 'ldi  tosh,0x00'
003547 c005      			rjmp MTSTC_xxx
                 	
                 	MTSTC_1LIT:
003548 d006      			rcall comp_lds_t0		; 'in/lds t0,<addr>
003549 939a
00354a 938a      			pushtos
00354b e880
00354c e293      			ldi16 tos,0x2380		; 'and tosl,t0'
                 	MTSTC_xxx:
00354d d773      			rcall ICOMMA
00354e c764      			rjmp ldi_tosh_0_C_		; 'ldi tosh,0x00'
                 	
                 	comp_lds_t0:
00354f e0a0      			ldi t4,regt0			; register 0x10 -> t0
                 	comp_lds_t4:
003550 7f61      			cbr FLAGS1,(fLIT<<1)|(f2LIT<<1)
003551 939a
003552 938a      			pushtos
003553 9180 02c3 			lds tosl,litbuf0
003555 b59b      			in  tosh,litbuf1
                 	comp_lds_:
003556 94e8      			clt						; 'read'-flag ('in/lds .... ')
003557 c026      			rjmp comp_xts_
                 			 
                 	MCLRC_:							; fdw MCLR in TOP
003558 ddf0      			rcall optMEM_helper
003559 ff63      			sbrs FLAGS1,f2LIT
00355a c00a      			  rjmp MCLRC_1LIT
                 	MCLRC_2LIT:						; ( addr -- )
00355b d1a8      			rcall IHERE
00355c 9704      			sbiw TOP,4
00355d d278      			rcall FETCH_A			;    ldi tosl,<lit1.0>'
00355e 709f      			cbr tosh,0xf0
00355f 6790      			ori tosh,HIGH(0x7000)	;  'andi tosl,<lit1.0>'
003560 708f      			cbr tosl,0xf0			;->'andi t0  ,<lit1.0>'
003561 e00f      			ldi t0,0x0f
003562 2780      			eor tosl,t0
003563 2790      			eor tosh,t0				; "com <lit1.0>"
003564 c014      			rjmp comp_2LIT
                 	
                 	MCLRC_1LIT:
003565 939a
003566 938a      			pushtos
003567 e088
003568 e293      			ldi16 tos,0x2308		; 'and t0,tosl'
003569 939a
00356a 938a      			pushtos
00356b e880
00356c e995      			ldi16 tos,0x9580		; 'com tosl'
00356d dfe1      			rcall comp_lds_t0		; 'in/lds t0,<addr>
00356e d752      			rcall ICOMMA
00356f d00b      			rcall comp_sts			; ICOMMA, 'out/sts <addr>,t0'
003570 cdf7      			rjmp STOREC_help2		; 'drop'
                 	
                 	MSETC_:							; fdw MSET in TOP
003571 ddd7      			rcall optMEM_helper
                 	MSETC_0: 
003572 ff63      			sbrs FLAGS1,f2LIT
003573 c020      			  rjmp MSETC_1LIT
                 	MSETC_2LIT:						; ( addr -- )
003574 d18f      			rcall IHERE
003575 9704      			sbiw TOP,4
003576 d7c7      			rcall FETCH				;   'ldi tosl,<lit1.0>'
003577 779f      			cbr tosh,0x80			; ->'ori tosl,<lit1.0>'
003578 708f      			cbr tosl,0xf0			; ->'ori t0  ,<lit1.0>'
                 	comp_2LIT:
003579 d3a1      			rcall IDP8MINUS			; "wipe" 'lit1'
00357a dfd4      			rcall comp_lds_t0		; 'in/lds t0,<addr>
                 	comp_sts:						; compile command ('andi ..' or 'ori ..')
00357b d745      			rcall ICOMMA
                 	comp_sts_t0:
00357c e0a0      			ldi t4,regt0			; register 0x10 -> t0
                 	comp_sts_:
00357d 9468      			set						; 'write'-flag ('out/sts ... ')
                 	comp_xts_:
00357e 3680      			cpi tosl,0x60			; check addr range
00357f 0597      			cpc tosh,r_zero
003580 f460      			  brcc comp_xts_pure
003581 3280      			cpi tosl,0x20
003582 f050      			  brcs comp_xts_pure
                 								; compile 'in/out <t4>,<addr-0x20>'
003583 5280      			subi tosl,0x20			; make it an io-addr
003584 2f98      			mov tosh,tosl
003585 708f      			andi tosl,0x0f
003586 7f90      			andi tosh,0xf0
003587 9592      			swap tosh
003588 0f99      			lsl tosh
003589 6b91      			ori tosh,0xb1
00358a f993      			bld tosh,3				; insert 'read/write'-flag
00358b 2b8a      			or tosl,t4
00358c c734      			rjmp ICOMMA
                 
                 	comp_xts_pure:				; compile 'lds/sts <t4>,<addr>'
00358d 939a
00358e 938a      			pushtos	
00358f 2f8a      			mov tosl,t4
003590 e991      			ldi tosh,HIGH(0x9100)	; R16..R31
003591 f991      			bld tosh,1				; insert 'read/write'-flag
003592 d72e      			rcall ICOMMA
003593 c72d      			rjmp ICOMMA
                 
                 	MSETC_1LIT:
003594 939a
003595 938a      			pushtos
003596 e088
003597 e29b      			ldi16 tos,0x2b08		; 'or t0,tosl'
003598 dfb6      			rcall comp_lds_t0		; 'lds t0,<addr>
003599 dfe1      			rcall comp_sts			; ICOMMA, 'sts <addr>,t0'
00359a cdcd      			rjmp STOREC_help2		; 'drop'
                 .endif
                 
                 
00359b f0b0      		fdw		DOTID_L
                 ; findi	( c-addr nfa -- c-addr 0 )	if not found
                 ;		(				xt     1 )	if immediate
                 ;		(				xt    -1 )	if normal
                 ; first in RAM, second in FLASH, Z-flag
                 BRACFIND_L:
                 kernellink_mid:
00359c 2883
00359d 2966      		.db		NFA|3,"(f)"
                 findi:
                 findi_loop:
00359e 81a8      		  ldd XL,Y+0			; c-addr -> X
00359f 81b9      		  ldd XH,Y+1
0035a0 010c      		  movw t3t2,TOP			; save NFA
0035a1 d026      		  rcall NEQUAL_0		; leaves valid Z-flag and valid addr+1 in Z
0035a2 f069      			breq findi_match
0035a3 01f0      		  movw Z,t3t2
0035a4 9732      		  sbiw Z,2				; NFA -> LFA
                 		  ;set					; (speed vs. size)
                 		  ;rcall IFETCH			; 2 / 20..23
0035a5 58f0      		  sub_pflash_z
0035a6 11fd      		  cpse ZH,ibaseH
0035a7 c003      		    rjmp F_loop_direct
0035a8 9468      		  set
0035a9 d74b      		  rcall IFETCH_buf		; valid addr+1 in Z
0035aa c002      		  rjmp PC+3
                 F_loop_direct:
0035ab 9185      		    lpm tosl,Z+
0035ac 9195      			lpm tosh,Z+			; 8 / 10..25
0035ad 9700      		sbiw TOP,0				; LFA 0=?
0035ae f779      		brne findi_loop			; no -> valid new NFA -> loop
                 findi_noMatch:
                 		;sez
0035af 9508      		ret						; yes-> end of dict -> return
                 
                 findi_match:					; TOP = 0 
                 						; #### dirty #### use of addr in Z
0035b0 9631      		adiw Z,1				; 'aligned'
0035b1 7fee      		cbr ZL,1
0035b2 58f0      		add_pflash_z
0035b3 83f9      		std Y+1,ZH				; put CFA to NEXT
0035b4 83e8      		std Y+0,ZL
0035b5 2e90      		mov wflags,t0  			; COMPILE and INLINE flags for the compiler (loaded to t0 in NEQUAL)
0035b6 9701      		sbiw TOP,1				; 'normal'		Z clear	N set
0035b7 fc96      		sbrc wflags,IMMEDbit
0035b8 9602      		  adiw TOP,2			; ->'immediate'	Z clear N clear
                 ;;		clz
0035b9 9508      		ret
                 
                 
0035ba e2ec      		fdw		TUCK_L
                 TRUE_L:
0035bb 74a4
0035bc 7572
0035bd ff65      		.db		NFA|INLINE4|4,"true",0xff
                 ;TRUE_:							; put ffff (TRUE) on data stack
0035be 939a
0035bf 938a      		pushtos
                 ;TRUE_pushed:
                 NEQUAL_noMatch:
0035c0 ef8f      		ser tosl
0035c1 ef9f      		ser tosh				; 5 / 7
0035c2 9508      		ret
                 
                 
0035c3 da6c      		fdw		OR_L
                 ; N= ( c-addr nfa -- n )		compare strings
                 ;					 0    ) s1==s2
                 ;                    ffff ) s1!=s2
                 ; N= is specificly used for finding dictionary entries
                 ; it can also be used for comparing strings shorter than 16 characters,
                 ; but the first string must be in RAM and the second in program memory (FLASH).
                 NEQUAL_L:
0035c4 6e82
0035c5 ff3d      		.db		NFA|2,"n=",0xff
                 ;NEQUAL:
0035c6 91a9
0035c7 91b9      		pop_X
                 NEQUAL_0:
0035c8 01fc      		movw Z,TOP
                 		;clt					; (speed vs. size)
                 		;rcall IFETCH			;  2 / 18..21
0035c9 58f0      		sub_pflash_z
0035ca 11fd      		cpse ZH,ibaseH
0035cb c004      		  rjmp N_0_direct
0035cc 94e8      		clt
0035cd d727      		rcall IFETCH_buf		; valid addr+1 in Z
0035ce 58f0      		sub_pflash_z
0035cf c001      		rjmp PC+2
                 N_0_direct:
0035d0 9185      		  lpm tosl,Z+			;  8 / 7..24
0035d1 2f08      		mov t0,tosl				; save length+flags for caller
0035d2 708f      		andi tosl,0x0f			; length
0035d3 919d      		ld tosh,X+
0035d4 1789      		cp tosl,tosh
0035d5 f751      		  brne NEQUAL_noMatch	; Z flag valid
                 
                 NEQUAL_loop:					; length in tosh as loop count
                 		  ;clt					; (speed vs. size)
                 		  ;rcall IFETCH			; 2+1 / 19..22
0035d6 11fd      		  cpse ZH,ibaseH
0035d7 c004      		    rjmp N_loop_direct
0035d8 94e8      		  clt
0035d9 d71b      		  rcall IFETCH_buf		; valid addr+1 in Z
0035da 58f0      		  sub_pflash_z
0035db c001      		  rjmp PC+2
                 N_loop_direct:
0035dc 9185      		    lpm tosl,Z+			; 7 / 6..23
0035dd 911d      		  ld t1,X+
0035de 1b81      		  sub tosl,t1
0035df f701      			brne NEQUAL_noMatch
0035e0 959a      		dec tosh
0035e1 f7a1      		brne NEQUAL_loop
                 ;NEQUAL_match:					; valid Z flag, valid addr+1 in Z
                 		;clr tosl				; n=0: s1==s2
                 		;clr tosh				; (already there)
0035e2 9508      		ret
                 
                 
0035e3 e1cc      		fdw		WITHIN_L
                 UMSLASHMOD_L:
0035e4 7586
0035e5 2f6d
0035e6 6f6d
0035e7 ff64      		.db		NFA|6,"um/mod",0xff
                 UMSLASHMOD:
0035e8 01dc      		movw t5t4,TOP			; divisor
0035e9 9189
0035ea 9199      		poptos					; ( ud.l ud.h			u in t5:t4 )
0035eb d0e8      		rcall udslashmod0		; (t7:t6:tosh:tosl)		rem in t3:t2
0035ec 921a
0035ed 920a      		push_t3t2				; ( rem ud'.l )
0035ee 9508      		ret
                 
                 
0035ef e396      		fdw		UDOTR_L
                 STARSLASH_L:
0035f0 7583
0035f1 2f2a      		.db		NFA|3,"u*/"
                 STARSLASH: 						; unsigned values only
0035f2 015c      		movw A,TOP				; divisor in A
0035f3 9189
0035f4 9199      		poptos
0035f5 d52f      		rcall umstar0			; product.l in t5t4, product.h in t7:t6
0035f6 93ba
0035f7 93aa      		push_t5t4
0035f8 01cf      		movw TOP,t7t6			; ( ud.l ud.h )
0035f9 01d5      		movw t5t4,A
0035fa c0d9      		rjmp udslashmod0		; ( ud'.l		ud'.h in t7:t6		rem in t3:t2 )
                 
                 
0035fb edc2      		fdw		UDSLASHMOD_L
                 USSMOD_L:
0035fc 7586
0035fd 2f2a
0035fe 6f6d
0035ff ff64      		.db		NFA|6,"u*/mod",0xff
                 USSMOD:
003600 dff1      		rcall STARSLASH			; remainder returned in t3:t2
003601 921a
003602 920a      		push_t3t2
003603 9508      		ret
                 
                 
003604 f6f2      		fdw		DEFER_L
                 ; CMOVE ( src dst u -- )		copy u bytes from src to dst
                 ;	swap !p>r for c@+ pc! p+ next drop ;
                 CMOVE_L:
003605 6385
003606 6f6d
003607 6576      		.db		NFA|5,"cmove"
                 CMOVE:
003608 91e9
003609 91f9      		pop_Z					; dst to Z
00360a 91a9
00360b 91b9      		pop_X					; src to X
00360c 30f9      		cpi ZH,HIGH(PEEPROM)
00360d f410      		  brcc CMOVE0
00360e 30b9      		cpi XH,HIGH(PEEPROM)
00360f f0b0      		  brcs MCMOVE2
                 CMOVE0:
003610 934f      		push pl
003611 935f      		push ph
003612 01af      		movw P,Z				; dst to P
003613 018d      		movw t1t0,X
003614 01dc      		movw X,TOP				; u to X
003615 01c8      		movw TOP,t1t0			; src to TOP
003616 c008      		rjmp CMOVE2
                 
                 CMOVE1:
003617 93af      		  push XL
003618 93bf      		  push XH
003619 d507      		  rcall CFETCHPP
00361a d736      		  rcall PCSTORE
00361b 0d46      		  add pl,r_one
00361c 1d57      		  adc ph,r_zero
00361d 91bf      		  pop XH
00361e 91af      		  pop XL
                 CMOVE2:
00361f 9711      		sbiw X,1
003620 f7b0      		brcc CMOVE1
                 
003621 915f      		pop ph
003622 914f      		pop pl
003623 ca09      		rjmp DROP
                 
                 MCMOVE1:				; src, dst both in RAM
003624 910d      		  ld t0,X+
003625 9301      		  st Z+,t0
                 MCMOVE2:
003626 9701      		sbiw TOP,1
003627 f7e0      		brcc MCMOVE1
                 
003628 ca04      		rjmp DROP
                 
                 
003629 e2d2      		fdw		MINUS_L
                 ; , ( x -- )					append cell to current data space
                 ;	HERE ! CELL ALLOT ;
                 COMMA_L:
00362a 2c81      		.db		NFA|1,","
                 COMMA:
00362b d99a      		rcall HERE
00362c 9602      		adiw TOP,2
00362d 9392      		st -Z,tosh				; Z-pointer valid from HERE
00362e 9382      		st -Z,tosl
00362f 9702      		sbiw TOP,2
003630 c725      		rjmp STORE
                 
                 
003631 fa8a      		fdw		CFETCH_L 
                 ; c, ( c -- )					append char to current data space
                 ;	HERE C! 1 ALLOT ;
                 CCOMMA_L:
003632 6382
003633 ff2c      		.db		NFA|2,"c,",0xff
                 CCOMMA:
003634 d991      		rcall HERE
003635 9601      		adiw TOP,1
003636 9392      		st -Z,tosh				; Z-pointer valid from HERE
003637 9382      		st -Z,tosl
003638 9701      		sbiw TOP,1
003639 c72b      		rjmp CSTORE
                 
                 
00363a e2e2      		fdw    NIP_L
                 ; N>C ( nfa -- cfa )			name addr -> code field
                 NTOC_L:
00363b 6e83
00363c 633e      		.db		NFA|3,"n>c"
                 NFATOCFA:
00363d d709      		 rcall CFETCH
00363e 708f      		 andi tosl,0x0f
00363f 0fe8      		 add ZL,tosl			; Z valid from CFETCH
003640 1df7      		 adc ZH,r_zero
003641 9631      		 adiw Z,1
003642 7fee      		 cbr ZL,1
003643 01cf      		 movw TOP,Z
003644 9508      		 ret
                 
                 
003645 f63e      		fdw    CFETCHPP_L
                 ; C>N ( cfa -- nfa )			code field addr -> name field addr
                 ; moded to match 'see': checks for valid length and chars < 0x80
                 CTON_L:
003646 6383
003647 6e3e      		.db		NFA|3,"c>n"
                 CFATONFA:
003648 ef0e      		ldi t0,-2
                 CTN_loop:
003649 d189      		  rcall MINUS_FETCH
00364a 5f0e      		  subi t0,-2
00364b ff87      		  sbrs tosl,7
00364c f021      			breq CFATONFA_3		; skip  first high byte for len > 1
00364d 379f      		  cpi tosh,0x7f
00364e f458      			brcc CTN_noname
00364f 3290      		  cpi tosh,0x20
003650 f048      		    brcs CTN_noname
                 CFATONFA_3:
003651 378f      		  cpi tosl,0x7f
003652 f039      		    breq CTN_noname
003653 f450      			brcc CTN_hit
                 CFATONFA_2:
003654 3280      		  cpi tosl,0x20
003655 f020      		    brcs CTN_noname
003656 9189
003657 9199      		  poptos
003658 300e      		  cpi t0,14
003659 f779      		brne CTN_loop
                 CTN_noname:
00365a 9622      		adiw Y,2				; NIP address
00365b e087      		ldi tosl,7				; 'r_zero' as length, if no NFA was found
00365c 2799      		clr tosh
00365d 9508      		ret
                 CTN_hit:
00365e 708f      		andi tosl,0x0f			; length
00365f f3d1      		  breq CTN_noname
003660 7f8e      		cbr tosl,1
003661 1780      		cp tosl,t0				; same lenght?
003662 f7b9      		  brne CTN_noname
003663 c9c9      		rjmp DROP
                 
                 
003664 dc00      		fdw		RDROP_L
                 ; place ( src n dst -- )		place as counted str
                 PLACE_L:
003665 7085
003666 616c
003667 6563      		.db		NFA|5,"place"
                 PLACE:
003668 d998      		rcall TWODUP
                 PLACE_twodupped:
003669 d6fb      		rcall CSTORE
00366a 9601      		adiw TOP,1
00366b d9c8      		rcall SWOP
00366c cf9b      		rjmp CMOVE
                 		 
                 
00366d d79e      		fdw		RX0Q_L
                 ; QUIT ( -- 	R: i*x -- )		interpret from kbd
                 QUIT_L:
00366e 7184
00366f 6975
003670 ff74      		.db		NFA|4,"quit",0xff
                 QUIT:
003671 01f1      		movw Z,UP
003672 977a      		sbiw Z,(-ur0)
003673 91a1      		ld t4,Z+
003674 91b1      		ld t5,Z+
003675 b70f      		in_ t0,SREG
003676 94f8      		cli
003677 bfad      		out SPL,t4
003678 bfbe      		out SPH,t5
003679 bf0f      		out_ SREG,t0
00367a 777f      		cbr FLAGS2,(1<<fSTATE)	; ''
00367b e004      		ldi t0,4
00367c bd0a      		out cse,t0				; 'RAM'
                 QUIT0:  
00367d de63      		  rcall   DP_TO_RAM
                 QUIT1: 
                 check_sp:						; check stack pointer position
00367e 01f1      			movw Z,UP
00367f 977c      			sbiw Z,(-us0)
003680 91a1      			ld t4,Z+			; SP R0 S0 WITHIN
003681 91b1      			ld t5,Z+
003682 17ac      			cp  t4,YL
003683 07bd      			cpc t5,YH
003684 f028      			  brcs SP_error		; s0 < sp -> error
003685 91a1      			ld t4,Z+			; ur0
003686 91b1      			ld t5,Z+
003687 17ac      			cp  t4,YL
003688 07bd      			cpc t5,YH
003689 f020      			brcs SP_ok
                 SP_error:
00368a d1db      			  rcall XSQUOTE
00368b 5303
00368c 3f50      			  .db   3,"SP?"
00368d c039      			  rjmp QABORT_1		; never returns
                 SP_ok:
00368e d0e2      			rcall CR
00368f dc0d      			rcall TIB
003690 939a
003691 938a      			duptos
003692 dbff      			rcall TIBSIZE
003693 970a      			sbiw  TOP,10		; reserve 10 bytes for hold buffer
003694 d9f9      			rcall ACCEPT
003695 d988      			rcall SPACE_
003696 dce9      			rcall INTERPRET
003697 fd77      			sbrc FLAGS2,fSTATE
003698 cfe5      		  rjmp QUIT1			; 'COMPILE'? -> go on 
                 
003699 dcdd      		  rcall IFLUSH
00369a de2d      		  rcall DP_TO_EEPROM
00369b d1ca      		  rcall XSQUOTE
00369c 2003
00369d 6b6f      		  .db   3," ok"
00369e d225      		  rcall TYPE
00369f d006      		  rcall PROMPT_
0036a0 cfdc      		rjmp QUIT0
                 
                 
0036a1 f3a0      		fdw		REPEAT_L
                 PROMPT_L:
0036a2 7086
0036a3 6f72
0036a4 706d
0036a5 ff74      		.db		NFA|6,"prompt",0xff
                 PROMPT_:
0036a6 d4dc      		rcall DEFER_DOES
0036a7 090a      		.dw  prompt
                 
                 
0036a8 f372      		fdw		AGAIN_L
                 ; ABORT ( i*x -- 	R: j*x -- )	clear stack & QUIT
                 ABORT_L:
0036a9 6185
0036aa 6f62
0036ab 7472      		.db		NFA|5,"abort"
                 ABORT:
0036ac 01f1      		movw Z,UP
0036ad 977c      		sbiw Z,(-us0)
0036ae 91c1      		ld YL,Z+
0036af 91d1      		ld YH,Z+
0036b0 cfc0      		rjmp QUIT				; QUIT never rets
                 
                 
0036b1 f66a      		fdw		QNEGATE_L
                 ; ?ABORT ( f -- )				abort & print '?'
                 QABORTQ_L:
0036b2 3f87
0036b3 6261
0036b4 726f
0036b5 3f74      		.db		NFA|7,"?abort?"
                 QABORTQ:
0036b6 9700      		sbiw TOP,0
0036b7 9189
0036b8 9199      		poptos
0036b9 f4c9      		  brne QAQ_ret
                 QABORTQ_0:
0036ba d963      		rcall SPACE_
0036bb e30f      		ldi t0,'?'
0036bc d0b5      		rcall EMIT_t0
0036bd cfee      		rjmp ABORT
                 
                 
0036be ee18      		fdw		BRACCHAR_L
                 ; ?ABORT ( f c-addr u -- )		abort & print msg if flag is false
                 QABORT_L:
0036bf 3f86
0036c0 6261
0036c1 726f
0036c2 ff74      		.db		NFA|6,"?abort",0xff
                 QABORT:
0036c3 810a      		ldd t0,Y+2
0036c4 811b      		ldd t1,Y+3
0036c5 2b01      		or t0,t1
0036c6 f419      		  brne QABO1
                 QABORT_1:
0036c7 d956      		rcall SPACE_
0036c8 d1fb      		rcall TYPE
0036c9 cfe2      		rjmp ABORT  			; ABORT never returns
                 QABO1:
0036ca c1f3      		rjmp DOTS_2				; (drop drop drop)
                 
                 
0036cb e114      		fdw		ACCEPT_L
                 ; ABORT" ( i*x 0  -- i*x   R: j*x -- j*x ) x1=0
                 ;		 ( i*x x1 --       R: j*x --     ) x1<>0
                 ABORTQUOTE_L:
0036cc 61d6
0036cd 6f62
0036ce 7472
0036cf ff22      		.db		NFA|IMMED|COMPILE|6,"abort",0x22,0xff
                 ABORTQUOTE:
0036d0 d9f5      		rcall SQUOTE
0036d1 dd6f      		rcall DOCOMMAXT
0036d2 ed86      		fdw  QABORT
                 QAQ_ret:
0036d3 9508      		ret
                 
                 
                 udslashmod0:				; ( 32 / 16 -> 32		rem16: t3t2 )
                 								; ( ud.l ud.h					u: t5t4 )
0036d4 9700      		sbiw TOP,0
0036d5 f031      		  breq udsm0_16
                 udsm0_32:
0036d6 d738      		rcall uslashmod0		; ( ud.l q.h	r.h  : t3t2		u: t5t4 )
0036d7 01fc      		movw t7t6,TOP
0036d8 9189
0036d9 9199      		poptos					; ( ud.l		r.h  : t3t2		u: t5t4		q.h:  t7t6 )
0036da 9468      		set
0036db c736      		rjmp udsm0_second		; ( ud'l		rem16: t3t2		u: t5t4		ud'h: t7t6 )   
                 
                 udsm0_16:
0036dc 01fc      		movw t7t6,TOP			; TOP == 0 -> ud'.h = 0
0036dd 9189
0036de 9199      		poptos
0036df c72f      		rjmp uslashmod0			; ( ud'l		rem16: t3t2		u: t5t4		ud'h: t7t6(=0) )
                 
                 
0036e0 ebc8      		fdw		UMSLASHMOD_L
                 ; UD/MOD ( ud u -- r ud' )
                 UDSLASHMOD_L:
0036e1 7586
0036e2 2f64
0036e3 6f6d
0036e4 ff64      		.db		NFA|6,"ud/mod",0xff
                 ;UDSLASHMOD:
0036e5 df02      		rcall UMSLASHMOD		; ( rem ud'.l	ud'h: t7t6 )
0036e6 939a
0036e7 938a      		pushtos					
0036e8 01cf      		movw TOP,t7t6			; ( rem ud'.l ud'.h )
0036e9 9508      		ret
                 
                 
0036ea fd1e      		fdw		MAX_L
                 ; LIT ( -- x )					fetch inline 16 bit literal to the stack
                 DOLIT_L:
0036eb 6c83
0036ec 7469      		.db		NFA|3, "lit"
                 DOLIT:
                 		m_pop_zh
0036ed 91ff      		pop ZH
0036ee 91ef      		pop ZL
0036ef dd48      		rcall FETCHLIT			; 1 / 12+7
0036f0 95f7      		ror ZH
0036f1 95e7      		ror ZL
0036f2 9409      		mijmp    ; (z)
                 
                 
0036f3 e5bc      		fdw		PAREN_L
                 ; ' ( "name" -- xt )			find word in dictionary
                 TICK_L:
0036f4 2781      		.db		NFA|1,0x27		; 27h = '
                 TICK:
0036f5 dc20      		rcall BL_WORD
                 		;rcall WORD
0036f6 db83      		rcall FIND
0036f7 cfbe      		rjmp QABORTQ
                 
                 
0036f8 f506      		fdw		DABS_L
                 ; CHAR ( -- char )				parse ASCII character
                 CHAR_L:
0036f9 6384
0036fa 6168
0036fb ff72      		.db		NFA|4,"char",0xff
                 CHAR:
0036fc dc14      		rcall BL
0036fd db3d      		rcall PARSE
0036fe d92e      		rcall DROP
0036ff c647      		rjmp CFETCH
                 
                 
003700 f438      		fdw		LEAVE_L
                 ; IHERE ( -- a-addr )			put code dictionary ptr onto data stack
                 ;   IDP @ ;
                 IHERE_L:
003701 69a5
003702 6568
003703 6572      		.db		NFA|INLINE5|5,"ihere"
                 IHERE:
003704 939a
003705 938a      		 pushtos
003706 9180 02b9
003708 9190 02ba 		 lds16 tos,dpFLASH		; 6 / 8
00370a 9508      		 ret
                 
                 
00370b ed98      		fdw		ABORTQUOTE_L
                 ; [CHAR] ( -- )					compile character as literal
                 BRACCHAR_L:
00370c 5bd6
00370d 6863
00370e 7261
00370f ff5d      		.db		NFA|IMMED|COMPILE|6,"[char]",0xff
                 BRACCHAR:
003710 dfeb      		rcall CHAR
                 LITERAL_A:
003711 c583      		rjmp LITERAL
                 
                 
                 ; helper for CREATE (CONSTANT_, VARIABLE, MARKER ...)
                 ; creates an empty dictionary entry w/o appending DOCREATE and current dp
                 CREATE0:
003712 dc03      		rcall BL_WORD
                 		;rcall WORD
003713 db66      		rcall FIND				; ( c-addr 0 ) if not found -> go on
003714 f069      		  breq CREATE_1			; Z-flag valid from 'FIND'
                 		;adiw Y,2				; (drop address) QABORT will do
003715 2788      		clr tosl
003716 2799      		clr tosh
003717 797f      		cbr FLAGS2,(1<<fINLINE) | (1<<fIMMED)	; clear flags
003718 d14d      		rcall XSQUOTE
003719 410f
00371a 524c
00371b 4145
00371c 5944
00371d 4420
00371e 4645
00371f 4e49
003720 4445      		.db 15,"ALREADY DEFINED"
003721 dfa1      		rcall QABORT			; ABORT if word has already been defined
                 
                 CREATE_1:						;			  ( c-addr 0 )
003722 81e8      		ldd ZL,Y+0				; CFETCH: we are in TIB -> RAM
003723 81f9      		ldd ZH,Y+1
003724 8180      		ld tosl,Z				;			  ( c-addr len )
003725 2388      		tst tosl
003726 f011      		  breq CREATE_2			; len = 0 -> abort
003727 3180      		cpi tosl,16
003728 f008      		brcs CREATE_3			; len < 16 -> go on
                 CREATE_2:						; len = 0 or len >= 16
003729 df8c      		  rcall QABORTQ			; invalid length -> abort
                 CREATE_3:						; (c-addr true )
00372a 9180 02bf
00372c 9190 02c0 		lds16 tos,dpLATEST		; 			  ( c-addr [latest] )
00372e d592      		rcall ICOMMA			; Link field  ( c-addr )
00372f d3f1      		rcall CFETCHPP			; str len	  ( addr' len)
003730 da48      		rcall TUCK				; len str len ( len addr' len )
                 								; IHERE LATEST !
003731 91e0 02b9
003733 91f0 02ba 		lds16 Z,dpFLASH			; IHERE
003735 93f0 02c0
003737 93e0 02bf 		sts16 dpLATEST,Z
003739 9631      		adiw Z,1				; IHERE+1
00373a 93fa
00373b 93ea      		push_Z					;			  ( len addr' ihere+1 len )
                 
00373c 939a
00373d 938a      		duptos					;			  ( len addr' ihere+1 len len )
00373e 6880      		ori tosl,NFA
00373f 2f07      		mov t0,FLAGS2
003740 7600      		andi t0,(IMMED|INLINE)	; mask out fIMMED and fINLINE
003741 2b80      		or tosl,t0				; ..and set header bits
                 							;			  ( len addr' ihere+1 len NFA[0] )
003742 797f      		cbr FLAGS2,(1<<fINLINE)|(1<<fIMMED)		; clear flags
003743 9731      		sbiw Z,1				; IHERE
003744 94e8      		clt
003745 d614      		rcall STORE_Z			; 			  ( len addr' ihere+1 len )
003746 dec1      		rcall CMOVE				; 			  ( len )
                 								; align length and increase IDP
003747 9602      		adiw TOP,2
003748 7f8e      		cbr tosl,1				;			  ( len' )
                 ;		rjmp IALLOT				; the header has now been created
                 IALLOT:
003749 27ee      		clr ZL
00374a c0b5      		rjmp ALLOT_0
                 
                 
00374b ea14      		fdw		DIGITQ_L
                 ; CREATE ( "name" -- )			create an empty definition
                 ; create a definition header and append DOCREATE and the current data space dictionary pointer
                 ; examples :
                 ; : table create 10 cells allot does> swap cells + ;
                 ; ram table table_a     flash table table_b    eeprom table table_c
                 ; ram variable  qqq
                 ; eeprom variable www ram
                 ; flash variable  rrr ram 
                 ; eeprom create calibrationtable 30 allot ram
                 ; 
                 CREATE_L:
00374c 6386
00374d 6572
00374e 7461
00374f ff65      		.db		NFA|6,"create",0xff
                 CREATE:
003750 dfc1      		rcall CREATE0
003751 939a
003752 938a      		pushtos
003753 e386      		ldi tosl, LOW(DOCREATE)	; compiles the runtime routine to fetch the next dictionary cell to the parameter stack
003754 e394      		ldi tosh,HIGH(DOCREATE)
003755 d891      		rcall STORECFF2			; append an exeution token (call !)
003756 d86f      		rcall HERE				; compile the current dataspace dp into the dictionary
003757 b50a      		in t0,cse
003758 2300      		tst t0
003759 f409      		brne PC+2
00375a 9602      		  adiw TOP,2			; in FLASH
00375b c565      		rjmp ICOMMA				; dp now points to a free cell
                 
                 
00375c dd7a      		fdw    VARIABLE_L
                 ; POSTPONE
                 POSTPONE_L:
00375d 70d8
00375e 736f
00375f 7074
003760 6e6f
003761 ff65      		.db		NFA|IMMED|COMPILE|8,"postpone",0xff
                 ;POSTPONE:
003762 dbb3      		rcall BL_WORD
003763 db16      		rcall FIND				; leaves valid Z-flag
003764 f409      		brne PC+2
003765 df50      		  rcall QABORTQ			; never returns
003766 2399      		tst tosh
003767 9189
003768 9199      		poptos
003769 f41a      		  brpl POSTPONE_immediate
                 POSTPONE_normal:				; -1
00376a dcd6      		rcall DOCOMMAXT
00376b e882      		fdw DOCOMMAXT
00376c c050      		rjmp ICOMMA_
                 
                 POSTPONE_immediate:				;  1
00376d c864      		rjmp COMMAXT
                 
                 
00376e f524      		fdw		DPLUS_L
                 ; CR ( -- )						output newline
                 CR_L:
00376f 6382
003770 ff72      		.db		NFA|2,"cr",0xff
                 CR:
003771 e00d      		ldi t0,0x0d
                 	  .if CR_with_LF == 1
                 	  .endif
                 EMIT_t0:
003772 939a
003773 938a      		pushtos
003774 2f80      		mov tosl,t0
003775 c738      		rjmp EMIT
                 
                 ; (DOES>) ( -- )				run-time action of DOES>
003776 2887
003777 6f64
003778 7365
003779 293e      		.db		NFA|7,"(does>)"	; just for 'see' to work
                 XDOES:
00377a 939a
00377b 938a      		pushtos
                 XDOES_pushed:
00377c 9180 02bf
00377e 9190 02c0 		lds16 tos,dpLATEST		; LATEST_ @
003780 debc      		rcall NFATOCFA			; 'call DOCREATE'
003781 9602      		adiw TOP,2				; point to address
003782 01fc      		movw Z,TOP
003783 919f      		pop tosh				; get caller return address
003784 918f      		pop tosl
003785 9468      		set
003786 c5d3      		rjmp STORE_Z
                 
                 
003787 f79a      		fdw		EMPTY_L
                 ; DOES> ( -- )					declare run-time action
                 DOES_L:
003788 64d5
003789 656f
00378a 3e73      		.db		NFA|IMMED|COMPILE|5,"does>"
                 DOES:
00378b dcb5      		rcall DOCOMMAXT
00378c eef4      		fdw  XDOES
00378d dcb3      		rcall DOCOMMAXT
00378e f692      		fdw  DODOES
00378f 9508      		ret
                 
                 
003790 e26c      		fdw		STORE_P_L
                 ; ] ( -- )						enter compiling state
                 RIGHTBRACKET_L:
003791 5da1      		.db		NFA|INLINE|1,"]"
                 RIGHTBRACKET:
003792 6870      		sbr FLAGS2,(1<<fSTATE)
003793 9508      		ret
                 
                 
003794 ef40      		fdw		SEMICOLON_L
                 ; : ( -- )						begin a colon definition
                 COLON_L:
003795 3a81      		.db		NFA|1,":"
                 COLON:
003796 6870      		 sbr FLAGS2,(1<<fSTATE)	; RIGHTBRACKET
003797 cf7a      		 rjmp CREATE0
                 
                 
003798 e54a      		fdw		TONUMBER_L
                 ; :noname ( -- a )				define headerless forth code
                 NONAME_L:
003799 3a87
00379a 6f6e
00379b 616e
00379c 656d      		.db		NFA|7,":noname"
                 NONAME:
00379d df66      		rcall IHERE
00379e cff3      		rjmp RIGHTBRACKET
                 
                 
00379f e214      		fdw		LESS_L
                 ; ; ( -- )						end a colon definition
                 SEMICOLON_L:
0037a0 3bd1      		.db		NFA|IMMED|COMPILE|1,";"
                 SEMICOLON:
0037a1 777f      		cbr FLAGS2,(1<<fSTATE)	; LEFTBRAKET -> ''
                 SEMICOLON_0:
0037a2 fd61      		sbrc FLAGS1,fTAILC
0037a3 c015      		  rjmp ADD_RETURN_1
0037a4 df5f      		rcall IHERE
0037a5 d02d      		rcall MINUS_FETCH
0037a6 018c      		movw t1t0,TOP
0037a7 7f10      		andi t1,0xf0			; check for 'rcall ..'
0037a8 5d10      		subi t1,0xd0			; NOT valid for more than 64 kB of FLASH 
0037a9 f041      		  breq RCALL_TO_RJMP
0037aa 9189
0037ab 9199      		poptos
0037ac d026      		rcall MINUS_FETCH
0037ad 3994      		cpi tosh,0x94
                 .ifdef EIND
                 .else
0037ae 408e      			sbci tosl,0x0e
                 .endif
0037af f439      		brne ADD_RETURN
                 CALL_TO_JMP:
                 .ifdef EIND
                 .else
0037b0 e08c      			ldi tosl,0x0c
                 .endif
0037b1 c001      		rjmp SWOP_STORE
                 
                 RCALL_TO_RJMP:
0037b2 7e9f      		cbr tosh,0x10			; 0xd... (rcall) -> 0xc... (rjmp)
                 SWOP_STORE:
0037b3 91e9
0037b4 91f9      		pop_Z
                 SWOP_STORE_Z:
0037b5 9468      		set
0037b6 c54b      		rjmp ISTORE_Z
                 
                 ADD_RETURN:
0037b7 9622      		adiw Y,2				; nip addr
0037b8 c002      		rjmp ADD_RETURN_2
                 ADD_RETURN_1:
0037b9 939a
0037ba 938a      		pushtos
                 ADD_RETURN_2:
0037bb e088      		ldi tosl, LOW(0x9508)	; compile a 'ret'
0037bc e995      		ldi tosh,HIGH(0x9508)
                 ICOMMA_:
0037bd c503      		rjmp ICOMMA
                 
                 .if optimizingCOMPILER == 1
                 	; recompile 'lit' ('pushtos  ldi16 tos,<lit>')
                 	;..to 			  ('ldi16 t1t0,<lit>'), ('ldi16 X,>lit>') or ('ldi16 P,>lit>')
                 
                 	ldi16_t1t0_C_:
0037be e010      			ldi t1,regt1t0			; -> t1:t0
                 	ldi16_thtl_C_:
0037bf e008      			ldi t0,8
                 	ldi16_thtl_C_DUP_:
0037c0 d15b      			rcall IDPMINUS			; replace 'LIT' by
0037c1 5002      			subi t0,2
                 	ldi16_thtl_C_0:
0037c2 df41      			rcall IHERE
0037c3 0f80      			add tosl,t0
0037c4 1d97      			adc tosh,r_zero
0037c5 d578      			rcall FETCH				;  'ldi tosh,<lit.1>'
0037c6 718f      			andi tosl,0x1f
0037c7 2b81      			or tosl,t1				; -> 'ldi th,<lit.1>'
0037c8 939a
0037c9 938a      			pushtos
0037ca 9734      			sbiw Z,4				; valid addr in Z returned by 'FETCH'
0037cb d573      			rcall FETCH_Zplus		;  'ldi tosl,<lit.0>'
0037cc 718f      			andi tosl,0x1f
0037cd 2b81      			or tosl,t1				; -> 'ldi tl,<lit.0>
0037ce d4f2      			rcall ICOMMA			; ..'ldi tl,..'
0037cf c4f1      			rjmp ICOMMA				; ..'ldi th,..'
                 .endif	
                 
                 
0037d0 da10      		fdw		DOTQUOTE_L
                 MINUS_FETCH_L:
0037d1 2d82
0037d2 ff40      		.db		NFA|2,"-@",0xff
                 MINUS_FETCH:
0037d3 9702      		sbiw TOP,2
0037d4 939a
0037d5 938a      		duptos
                 FETCH_A:
0037d6 c567      		rjmp FETCH
                 
                 
0037d7 e102      		fdw		SWOPMINUS_L
                 ; STATE ( -- f )				put compiler state onto data stack
                 STATE_L:
0037d8 73a5
0037d9 6174
0037da 6574      		.db		NFA|INLINE5|5,"state"
                 STATE_:
0037db 939a
0037dc 938a      		pushtos
                 STATE_0:
0037dd 01c3      		movw TOP,r_one
0037de ff77      		sbrs FLAGS2,fSTATE
0037df 2788      		  clr tosl				; 5 / 7
0037e0 9508      		ret
                 
                 
0037e1 e9e0      		fdw		LSHIFT_L
                 ; LATEST ( -- a-addr )
                 LATEST_L:
0037e2 6ca6
0037e3 7461
0037e4 7365
0037e5 ff74      		.db		NFA|INLINE4|6,"latest",0xff
                 LATEST_:
0037e6 939a
0037e7 938a      		 pushtos
                 LATEST_0:
0037e8 eb8f
0037e9 e092      		 ldi16 tos,dpLATEST		; 4 / 6	
0037ea 9508      		 ret
                 
                 
0037eb f724      		fdw		TO_L
                 ; S0 ( -- a-addr )				start of parameter stack
                 S0_L:
0037ec 73a2
0037ed ff30      		.db		NFA|INLINE4|2,"s0",0xff
                 S0:
0037ee 939a
0037ef 938a
0037f0 01c1
0037f1 974c      		inline_DOUSER us0		; 4 / 7
0037f2 9508      		ret
                 
                 
0037f3 e0ae      		fdw		RFROM_L
                 ; R0 ( -- a-addr )				start of parameter stack
                 R0_L:
0037f4 72a2
0037f5 ff30      		.db		NFA|INLINE4|2,"r0",0xff
                 R0_:
0037f6 939a
0037f7 938a
0037f8 01c1
0037f9 974a      		inline_DOUSER ur0		; 4 / 7
0037fa 9508      		ret
                 
                 
0037fb f31a      		fdw		BEGIN_L
                 ALLOT_L:
0037fc 6185
0037fd 6c6c
0037fe 746f      		.db		NFA|5,"allot"
                 ALLOT:
0037ff b5ea      		 in ZL,cse
                 ALLOT_0:
003800 27ff      		 clr ZH
003801 54e7      		 subi ZL, LOW(-dpFLASH)
003802 4ffd      		 sbci ZH,HIGH(-dpFLASH)	; DP
003803 9101      		 ld t0,Z+
003804 9111      		 ld t1,Z+				; 	@
003805 0f80      		 add tosl,t0
003806 1f91      		 adc tosh,t1			;		+
                 ALLOT_1:
003807 9392      		 st -Z,tosh
003808 9382      		 st -Z,tosl				;		  !
003809 c555      		 rjmp DROP_A
                 
                 		
00380a f8ee      		fdw		IRQ_SEMI_L
                 ; 2@ ( a-addr -- x1 x2 )		fetch 2 cells
                 ;	DUP @ SWAP CELL+ @ ;
                 TWOFETCH_L:
00380b 3282
00380c ff40      		.db		NFA|2,"2@",0xff
                 TWOFETCH:
00380d d530      		rcall FETCH				; leaves a-addr+2 in Z
00380e 939a
00380f 938a      		pushtos
003810 c52e      		rjmp FETCH_Zplus
                 
                 
003811 e1b2      		fdw		SPFETCH_L
                 ; SHB ( bitmask -- )			set header bit
                 SHB_L:
003812 7383
003813 6268      		.db		NFA|3,"shb"
                 SHB:
003814 2f18      		 mov t1,tosl			; save mask
                 SHB0:
003815 91e0 02bf
003817 91f0 02c0 		 lds16 Z,dpLATEST
003819 d52e      		 rcall CFETCH_Zplus
00381a 9731      		 sbiw Z,1
00381b 2b81      		 or tosl,t1
00381c 94e8      		 clt					; 'write char'-flag
00381d c53c      		 rjmp STORE_Z			; store tosl to (Z)
                 
                 
                 ;*************************************************************
                 ; Coded for max 256 byte pagesize !
                 ; if ((ibaselo != (iaddrlo & ~(PAGESIZEB-1))) | (ibaseH != iaddrh) | (ibaseu != iaddru))
                 ;   if (idirty)
                 ;       writebuffer_to_imem
                 ;   endif
                 ;   fillbuffer_from_imem
                 ;   ibaselo = iaddrlo & ~(PAGESIZEB-1)
                 ;   ibasehi = iaddrhi
                 ;endif
                 IFILL_BUFFER:					; org address in Z
00381e 93f0 02c2 		sts iaddrH,ZH
003820 93e0 02c1 		sts iaddrL,ZL
003822 99f1      		sbic FLAGS3, idirty
003823 d00f      		  rcall IWRITE_BUFFER
003824 91e0 02c1 		lds ZL,iaddrL
003826 91f0 02c2 		lds ZH,iaddrH
003828 78e0      		andi ZL,~(PAGESIZEB-1)
003829 016f      		movw IBASE,Z
                 	.ifdef RAMPZ
                 	.endif
                 IFILL_BUFFER_1:					; fill buffer from FLASH
                 ;		ldi t0,0xff
00382a e0a0
00382b e0b2      		ldi16 X,ibuf				; ibuf on page boundary !!
                 IFILL_BUFFER_2:
00382c 9115      		  lpm_ t1,Z+
00382d 931d      		  st X+,t1
                 ;		  and t0,t1					; check for programmed bytes
00382e 38a0      		  cpi XL, LOW(ibuf+PAGESIZEB)	; ibuf on page boundary !!
00382f f7e1      		brne IFILL_BUFFER_2
                 		
                 ;		cbi FLAGS3,fFLASH_PAGE_CLEAR
                 ;		cpi t0,0xff
                 ;		brne PC+2
                 ;		  sbi FLAGS3,fFLASH_PAGE_CLEAR	; all bytes in page = 0xff -> don't need to erase page
                 
                 	  .ifdef RAMPZ
                 	  .endif
003830 91e0 02c1 		lds ZL,iaddrL
003832 9508      		ret
                 
                 IWRITE_BUFFER:
                 	.if OPERATOR_UART == 0
                 	  .if U0FC_TYPE == 0
                 	;  .elif U0FC_TYPE == 1
                 	;		sbrs FLAGS2,ixoff_tx0
                 	;		  rcall XXOFF_TX0
                 	;  .elif U0FC_TYPE == 2
                 	;		sbi_ U0RTS_PORT, U0RTS_BIT
                 	  .else .error "illegal value: U0FC_TYPE"
                 	  .endif
                 	.else  ;; UART1
                 	  .if U1FC_TYPE == 1
                 	  .elif U1FC_TYPE == 2
                 	  .endif
                 	.endif
                 
                 	.ifdef RAMPZ
                 	.endif
                 
003833 99f9
003834 cffe      IWR_BUF_waitEE:	 sbic EECR,EEPE		rjmp IWR_BUF_waitEE	; EEPROM write in progress?
                 
                 	.if DEBUG_FLASH == 1
                 	.endif
                 		
003835 934f      		push R20				; pl (boot loader compatibility)
003836 e0a0
003837 e0b2      		ldi16 X,ibuf
003838 d7a7      		rcall WRITE_FLASH_PAGE	; leaves Z = ibase
003839 914f      		pop R20
                 		
00383a e70f      		ldi t0,LOW(PAGESIZEB-1)
00383b e0a0
00383c e0b2      		ldi16 X,ibuf			; read back and check
                 IWRITE_BUFFER2:
00383d 9005      		  lpm_ R0,Z+
00383e 901d      		  ld R1,X+
00383f 1001      		  cpse R0,R1
003840 c39f      		    rjmp WARM_0    		; reset if write error
003841 5001      		subi t0,1
003842 f7d0      		brcc IWRITE_BUFFER2
                 
003843 98f1      		cbi FLAGS3,idirty
003844 2ed0      		mov ibaseH,t0			; 0xff -> 'ibuf empty'-marker
                 
                 	.ifdef RAMPZ
                 	.endif
                 
                 	.if OPERATOR_UART == 0
                   	  .if U0FC_TYPE == 0
                 	;  .elif U0FC_TYPE == 1
                 	;		 rcall XXON_TX0
                 	;  .elif U0FC_TYPE == 2
                 	;		cbi_ U0RTS_PORT,U0RTS_BIT
                 	  .else .error "illegal value: U0FC_TYPE"
                 	  .endif
                 	.else
                 	  .if U1FC_TYPE == 1
                 	  .elif U1FC_TYPE == 2
                 	  .endif
                 	.endif
                 
                 	.if DEBUG_FLASH == 1
                 		.if   OPERATOR_UART == 0
                 		.elif OPERATOR_UART == 1
                 		.else 
                 		.endif
                 	.else	; (DEBUG_FLASH <> 1)
003845 9508      			 ret
                 	.endif
                 
                 
003846 e6f6      		fdw		INTERPRET_L
                 IMMEDIATE_L:
003847 6989
003848 6d6d
003849 6465
00384a 6169
00384b 6574      		.db		NFA|9,"immediate"
                 IMMEDIATE:
00384c e410      		 ldi t1,IMMED
                 pre_SHB:
00384d 939a
00384e 938a      		 pushtos
00384f cfc5      		 rjmp SHB0
                 
                 
003850 f922      		fdw		LITERAL_L
                 INLINED_L:
003851 6987
003852 6c6e
003853 6e69
003854 6465      		.db		NFA|7,"inlined"
                 INLINED:
003855 e210      		 ldi t1,INLINE
003856 cff6      		 rjmp pre_SHB
                 
                 
003857 e948      		fdw		DOTSTATUS_L
                 ;  .id ( nfa -- ) 
                 DOTID_L:
003858 2e83
003859 6469      		.db		NFA|3,".id"
                 DOTID:
00385a d2c6      		rcall CFETCHPP
00385b 708f      		andi tosl,NFAmask
00385c c067      		rjmp TYPE
                 
                 
00385d dac6      		fdw		TWOSTAR_L
                 ; 2! ( x1 x2 a-addr -- )		store 2 cells
                 ;	SWAP OVER ! CELL+ ! ;
                 TWOSTORE_L:
00385e 3282
00385f ff21      		.db		NFA|2,"2!",0xff
                 TWOSTORE:				; #### keep with 'XSQUOTE' for 'see' o work ####
003860 d918      		rcall TUCK
003861 9602      		adiw TOP,2
003862 d4f3      		rcall STORE
003863 c4f2      		rjmp STORE
                 
                 
                 ; (S" ( -- c-addr u )			run-time code for S"
003864 2883
003865 2273      		.db      NFA|3,"(s",0x22	; just for 'see' to work
                 XSQUOTE:				; #### do NOT change distance to 'TWOSTORE' for 'see' to work ####
                 		m_pop_zh
003866 91ff      		pop ZH
003867 91ef      		pop ZL
003868 0fee      		lsl ZL
003869 1fff      		rol ZH
00386a 9105      		lpm_ t0,Z+
00386b 939a
00386c 938a      		pushtos
00386d 01cf      		movw TOP,Z
00386e 5890      		add_pflash_tos
00386f 939a
003870 938a      		pushtos
003871 2f80      		mov tosl,t0
003872 0fe0      		add ZL,t0
003873 1df7      		adc ZH,r_zero
003874 9631      		adiw Z,1
                 		;rampv_to_c
                 		;ror zh
003875 95f6      		lsr ZH
003876 95e7      		ror ZL
003877 9409      		mijmp
                 
                 
003878 f334      		fdw		ZEROUNTIL_L
                 ; WORDS   ( "filter" -- ) 		list words beginning with 'filter'
                 WORDS_L:
003879 7785
00387a 726f
00387b 7364      		.db		NFA|5,"words"
                 WORDS:
00387c def4      		rcall CR
00387d da98      		rcall BL_WORD				; c-addr, valid Z-flag
00387e f409      		brne PC+2
00387f 6078      		  sbr FLAGS2,(1<<fWORDSall)	; list all words
003880 939a
003881 938a      		pushtos
003882 ea8a
003883 ef9a      		ldi16 tos,((kernellink_short<<1)+PFLASH); (c-addr NFA)
003884 d00d      		rcall WORDS_dict
003885 e388
003886 ee9b      		ldi16 tos,((kernellink_mid<<1)+PFLASH)	; (c-addr NFA)
003887 d00a      		rcall WORDS_dict
003888 ea82
003889 ed9c      		ldi16 tos,((kernellink_long<<1)+PFLASH)	; (c-addr NFA)
00388a d007      		rcall WORDS_dict
00388b 9180 02bf
00388d 9190 02c0 		lds16 tos,dpLATEST			; (c-addr NFA)
00388f d002      		rcall WORDS_dict
                 
003890 7f77      		cbr FLAGS2,(1<<fWORDSall)
003891 c156      		rjmp TWODROP_A
                 
                 WORDS_dict:
003892 fd73      		sbrc FLAGS2,fWORDSall
003893 c00f      		  rjmp WORDS_match
003894 01fc      		movw Z,TOP				; NFA
003895 58f0      		sub_pflash_z
003896 81a8      		ldd XL,Y+0				; c-addr
003897 81b9      		ldd XH,Y+1
003898 910d      		ld  t0,X+				; check length
003899 9115      		lpm t1,Z+
00389a 701f      		andi t1,0x0f
00389b 1710      		cp t1,t0
00389c f050      		  brcs WORDS_next		; <string> longer than dict entry
                 WORDS_loop:
00389d 900d      		  ld t2,X+
00389e 9015      		  lpm t3,Z+
00389f 1401      		  cp t2,t3
0038a0 f431      			brne WORDS_next		; char mismatch
0038a1 950a      		dec t0
0038a2 f7d1      		brne WORDS_loop
                 
                 WORDS_match:					; type name
0038a3 939a
0038a4 938a      		duptos					; (c-addr NFA NFA)
0038a5 dfb4      		rcall DOTID
0038a6 d94a      		rcall SPACE_A
                 
                 WORDS_next:
0038a7 9702      		sbiw TOP,2				; (c-addr LFA)
0038a8 d495      		rcall FETCH				; (c-addr NFA')
0038a9 9700      		sbiw TOP,0
0038aa f739      		  brne WORDS_dict
                 								; end of dict
0038ab cec5      		rjmp CR
                 
                 
                 ; .S ( -- )						print stack contents
                 ;	space sp@ s0 @ 2- begin 2dup < while -@ u. repeat 2drop ;
0038ac db9e      		fdw		ZEROLESS_L
                 DOTS_L:
0038ad 2e82
0038ae ff73      		.db		NFA|2,".s",0xff
                 DOTS:
0038af d941      		rcall SPACE_A
0038b0 939a
0038b1 938a      		pushtos
0038b2 d828      		rcall SPFETCH
0038b3 df3a      		rcall S0
0038b4 d489      		rcall FETCH
0038b5 9702      		sbiw TOP,2
                 DOTS_1:
0038b6 8108      		  ldd t0,Y+0
0038b7 8119      		  ldd t1,Y+1
0038b8 1708      		  cp t0,tosl
0038b9 0719      		  cpc t1,tosh
0038ba f418      			brcc DOTS_2
0038bb df17      		  rcall MINUS_FETCH
0038bc d92b      		  rcall UDOT
0038bd cff8      		rjmp DOTS_1
                 DOTS_2:
0038be 9624      		adiw Y,4
0038bf c49f      		rjmp DROP_A
                 
                 
0038c0 da46      		fdw		 UMAX_L
                 ; TYPE ( c-addr u -- )			type line to terminal u < $100
                 ;	for c@+ emit next drop ;
                 TYPE_L:
0038c1 7484
0038c2 7079
0038c3 ff65      		.db		NFA|4,"type",0xff
                 TYPE:
0038c4 2e88      		mov t8,tosl
0038c5 9189
0038c6 9199      		poptos
0038c7 2088      		tst t8
0038c8 f021      		  breq TYPE_2
                 TYPE_loop:
0038c9 d257      		  rcall CFETCHPP
0038ca d5e3      		  rcall EMIT
0038cb 948a      		dec t8
0038cc f7e1      		brne TYPE_loop
                 TYPE_2:
0038cd c491      		rjmp DROP_A
                 
                 
0038ce f2e2      		fdw		ELSE_L
                 ; DUMP ( addr u -- )			display memory
                 DUMP_L:
0038cf 6484
0038d0 6d75
0038d1 ff70      		.db		NFA|4,"dump",0xff
                 DUMP:
0038d2 e004      		ldi t0,4				; count DIV 16 -> line count
0038d3 9596
0038d4 9587      dump_0:	  lsr tosh	  ror tosl
0038d5 950a      		dec t0
0038d6 f7e1      		brne dump_0
                 
0038d7 01f1      		movw Z,UP
0038d8 9772      		sbiw Z,(-ubase)
0038d9 81a0      		ld t4,Z
0038da 31a0      		cpi t4,16				; base < 16 ?
0038db f408      		brcc PC+2
0038dc 6078      		  sbr FLAGS2,(1<<fDUMPxxx)	; yes -> dump 3-digit numbers
0038dd 01dc      		movw X,TOP				; save line count
0038de 9189
0038df 9199      		poptos
                 DUMP_loop:  
0038e0 93af      		  push XL
0038e1 93bf      		  push XH
0038e2 de8e      		  rcall CR
0038e3 939a
0038e4 938a      		  duptos
0038e5 939a
0038e6 938a      		  pushtos
0038e7 2799      		  clr tosh
0038e8 e084      		  ldi tosl,4
0038e9 fd73      		  sbrc FLAGS2,fDUMPxxx
0038ea 9583      			inc tosl
0038eb d8e1      		  rcall UDOTR			; type line address
                 
0038ec e0af      		  ldi XL,15				
                   DUMP2:
0038ed 93af      			push XL				; type 16 byte values
0038ee d232      			rcall CFETCHPP
0038ef 939a
0038f0 938a      			pushtos
0038f1 2799      			clr tosh
0038f2 e082      			ldi tosl,2
0038f3 fd73      			sbrc FLAGS2,fDUMPxxx
0038f4 9583      			  inc tosl
0038f5 d8d7      			rcall UDOTR
0038f6 91af      			pop XL
0038f7 50a1      		  subi XL,1
0038f8 f7a0      		  brcc DUMP2
                   
0038f9 9740      		  sbiw TOP,16
0038fa e100      		  ldi t0,16
0038fb 2e80      		  mov t8,t0
                   DUMP4:
0038fc d224      			rcall CFETCHPP		; type 16 ASCII char
0038fd d864      			rcall TO_PRINTABLE
0038fe d5af      			rcall EMIT
0038ff 948a      		  dec t8
003900 f7d9      		  brne DUMP4
                   	
003901 91bf      		  pop XH
003902 91af      		  pop XL
003903 9711      		sbiw X,1
003904 f6d8      		brcc DUMP_loop
                 
003905 7f77      		cbr FLAGS2,(1<<fDUMPxxx)
003906 e08d      		ldi tosl,CR_
003907 c5a6      		rjmp EMIT
                 
                 
                 ; ,?0= ( -- addr )				compile '?0=' and make place for a branch instruction
003908 2c84
003909 303f
00390a ff3d      		.db		NFA|4, ",?0=",0xff    ; just for 'see' to work
                 COMMAZEROSENSE:
00390b 939a
00390c 938a      		pushtos
00390d fd65      		sbrc FLAGS1,idup
00390e c003      		  rjmp COMMAZEROSENSE1
00390f e086
003910 ed99      		ldi16 tos,((ZEROSENSE<<1)+PFLASH)
003911 c0cf      		rjmp INLINE0
                 
                 COMMAZEROSENSE1:				; DUPZEROSENSE
003912 d004      		rcall IDP4MINUS
003913 e080
003914 e997      		ldi16 tos,0x9700		; 'sbiw TOP,0'		
003915 7d6f      		cbr FLAGS1,(1<<idup)
003916 c3aa      		rjmp ICOMMA
                 
                 IDP4MINUS:
003917 e004      		ldi t0,4
003918 c003      		rjmp IDPMINUS
                 IDP6MINUS:
003919 e006      		ldi t0,6
00391a c001      		rjmp IDPMINUS
                 IDP8MINUS:
00391b e008      		ldi t0,8
                 IDPMINUS:
00391c eba9
00391d e0b2      		ldi16 X,dpFLASH
00391e 91ed      		ld ZL,X+
00391f 91fd      		ld ZH,X+
003920 1be0      		sub ZL,t0
003921 09f7      		sbc ZH,r_zero
003922 93fe      		st -X,ZH
003923 93ee      		st -X,ZL				; 8 / 12
003924 9508      		ret
                 
                 
                 BRNEC:
003925 939a
003926 938a
003927 e089
003928 ef94      		inline_DOLIT 0xf409 	; brne PC+2
003929 fd64      		sbrc FLAGS1,izeroeq
00392a 7f9b      		  andi tosh, ~4			; breq PC+2
00392b c395      		rjmp ICOMMA
                 
                 
00392c f70c      		fdw		IS_L
                 ; IF ( -- adrs )				conditional forward branch
                 ; leaves address of branch instruction and compiles the condition byte
                 IF_L:
00392d 69d2
00392e ff66      		.db		NFA|IMMED|COMPILE|2,"if",0xff
                 IF_:
00392f d007      		rcall IF_createBranch
                 IF_1:
003930 7e6a      		cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)|(1<<iLITeq)
                 
                 IHERE_ZERO_RJMPC:
003931 ddd2      		rcall IHERE
003932 939a
003933 938a
003934 e080
003935 ec90      		inline_DOLIT 0xc000		; 'rjmp 0' as dummy
003936 c38a      		rjmp ICOMMA
                 
                 IF_createBranch:
003937 fd60      		sbrc FLAGS1,icarryeq
003938 c01f      		  rjmp carryIF_
003939 fd65      		sbrc FLAGS1,idup
00393a ff62      		sbrs FLAGS1,iLITeq
00393b c018      		  rjmp IF_zeroeq
                 
                 IF_dupLITeq:					; (idup && iLITeq)
00393c 939a
00393d 938a
00393e e089
00393f ef90      		inline_DOLIT 0xf009		; 'breq PC+2'
003940 ddc3      		rcall IHERE
003941 970a      		sbiw TOP,10
003942 d3fb      		rcall FETCH				; 'subi tosl,lit.0' (leaves valid adr+2 in Z)
003943 709f      		andi tosh,0x0f
003944 6390      		ori tosh,0x30			; -> 'cpi tosl,lit.0'
003945 939a
003946 938a
003947 e181
003948 ef94      		inline_DOLIT 0xf411		; 'brne PC+3'
003949 939a
00394a 938a      		pushtos
00394b d3f3      		rcall FETCH_Zplus		; 'sbci tosh,lit.1'
00394c 709f      		andi tosh,0x0f
00394d 6390      		ori tosh,0x30			; -> 'cpi tosh,lit.1'
00394e e00e      		ldi t0,14
00394f dfcc      		rcall IDPMINUS
003950 d370      		rcall ICOMMA
003951 d36f      		rcall ICOMMA
003952 d36e      		rcall ICOMMA
003953 c36d      		rjmp ICOMMA
                 
                 IF_zeroeq:
003954 fd64      		sbrc FLAGS1,izeroeq
003955 dfc3      		  rcall IDP6MINUS
003956 dfb4      		rcall COMMAZEROSENSE
003957 cfcd      		rjmp BRNEC
                 
                 carryIF_:
003958 ff65      		sbrs FLAGS1,idup
003959 c006      		  rjmp carryIF_noDUP
                 carryIF_DUP:					; for ULESS, UGREATER and GREATER only
00395a 939a
00395b 938a
00395c e088
00395d ef90      		inline_DOLIT 0xf008		; 'brcs PC+2'
00395e dfb8      		rcall IDP4MINUS			; skip 'drop'
00395f c361      		rjmp ICOMMA
                 
                 carryIF_noDUP:
003960 dfb6      		rcall IDP4MINUS
003961 939a
003962 938a      		pushtos
003963 ec8c
003964 ef92      		ldi16 tos,((BRCS_seq<<1)+PFLASH)	; 'brcs PC+2'
003965 c07b      		rjmp INLINE0
                 
                 BRCS_seq:
003966 9189
003967 9199      		poptos
003968 f008      		brcs PC+2
003969 9508      		ret
                 
                 
00396a df24      		fdw		EIGHTLSHIFT_L
                 ; 0if   ( -- adrs )				forward branch on Z-flag - NO stack action
                 ZEROIF_L:
00396b 30d3
00396c 6669      		.db		NFA|IMMED|COMPILE|3,"0if"
                 ZEROIF:
00396d 6160      		sbr FLAGS1,(1<<izeroeq)
00396e dfb6      		rcall BRNEC
00396f cfc1      		rjmp IHERE_ZERO_RJMPC
                 
                 	
003970 fd56      		fdw		EMIT_L
                 ; ELSE ( adrs1 -- adrs2 )		branch for IF..ELSE
                 ; leave adrs2 of bra instruction and store breq in adrs1
                 ; leave address of branch instruction and FALSE flag on stack
                 ELSE_L:
003971 65d4
003972 736c
003973 ff65      		.db		NFA|IMMED|COMPILE|4,"else",0xff
                 ELSE_:
003974 dfbc      		rcall IHERE_ZERO_RJMPC
003975 d9fb      		rcall SWOP_A			; else-addr  if-addr 
003976 c004      		rjmp THEN_
                 
                 
003977 eb76      		fdw		TRUE_L
                 ; THEN ( adrs  -- )				resolve forward branch
                 THEN_L:
003978 74d4
003979 6568
00397a ff6e      		.db		NFA|IMMED|COMPILE|4,"then",0xff
                 THEN_:
00397b ef0e      		ldi t0,0xfe				; -2
00397c ef1f      		ldi t1,0xff
                 THEN_0:
00397d 01fc      		movw Z,TOP				; write forward branch at 'if', 'else','do' or 'for'
00397e 9180 02b9
003980 9190 02ba 		lds16 tos,dpFLASH
003982 1b8e      		sub tosl,ZL
003983 0b9f      		sbc tosh,ZH
003984 0f80      		add tosl,t0
003985 1f91      		adc tosh,t1
003986 9595      		asr tosh
003987 9587      		ror tosl
003988 709f      		andi tosh,0x0f
                 		;ori tosl, LOW(0xc000)
003989 6c90      		ori tosh,HIGH(0xc000)
00398a 6062      		sbr FLAGS1,(1<<fTAILC)	; prevent tail jump  optimization
00398b ce29      		rjmp SWOP_STORE_Z		; write TOP at Z
                 
                 
00398c d974      		fdw		CELLPLUS_L
                 ; BEGIN ( -- adrs )				target for backward branch
                 BEGIN_L:
00398d 62d5
00398e 6765
00398f 6e69      		.db		NFA|IMMED|COMPILE|5,"begin"
                 BEGIN:
003990 cd73      		rjmp IHERE
                 
                 
003991 f6e0      		fdw		VALUE_L
                 ; UNTIL ( adrs -- )				branch backwards if true
                 UNTIL_L:
003992 75d5
003993 746e
003994 6c69      		.db		NFA|IMMED|COMPILE|5,"until"
                 UNTIL:
003995 6062      		sbr FLAGS1,(1<<fTAILC)	; prevent tail jump  optimization
003996 dfa0      		rcall IF_createBranch
003997 7e6a      		cbr FLAGS1,(1<<izeroeq)|(1<<icarryeq)|(1<<iLITeq)
003998 c023      		rjmp AGAIN_
                 
                 
003999 fb7e      		fdw		SCALE_L
                 ; 0until   ( adrs -- )      backward branch on Z-flag - NO stack action
                 ; ########## small loops ONLY ##########
                 ZEROUNTIL_L:
00399a 30d6
00399b 6e75
00399c 6974
00399d ff6c      		.db		NFA|IMMED|COMPILE|6,"0until",0xff
                 ZEROUNTIL:
00399e 2da6      		 mov t4,r_one			; b001 for Z-flag
00399f 7e6f      		 cbr FLAGS1,(1<<izeroeq)
                 		 ;rjmp UNTILflag
                 		 						; branch on cpu-flag - NO stack action
                 UNTILflag:
0039a0 6062      		 sbr FLAGS1,(1<<fTAILC)	; prevent tail jump  optimization
0039a1 9100 02b9 		 lds t0,dpFLASH			; IHERE
                 		 ;lds t1,dpFLASH+1		; not needed ...
0039a3 1b80      		 sub tosl,t0
                 		 ;sbc tosh,t1			; not needed ...
                 		 ;sbiw TOP,2
0039a4 5082      		 subi tosl,2
0039a5 7f8e      		 andi tosl, LOW(0x00fe)
0039a6 7090      		 andi tosh,HIGH(0x00fe)	; distance in bytes (already shifted left by 1)
0039a7 0f88
0039a8 1f99      		 lsl tosl	rol tosh
0039a9 0f88
0039aa 1f99      		 lsl tosl	rol tosh	; distance in words (shifted left by 3) to be inserted into 'br..'-command
0039ab 2b8a      		 or tosl,t4				; which flag
0039ac 6f94      		 ori tosh,HIGH(0xf400)	; branch on cleared
0039ad fd64      		 sbrc FLAGS1,izeroeq
0039ae 7f9b      		   cbr tosh,0x04		; ..on set
0039af c311      		 rjmp ICOMMA
                 
                 
0039b0 ed7e      		fdw		QABORT_L
                 ; 1until   ( adrs -- )      backward branch on Z-flag - NO stack action
                 ; ########## small loops ONLY ##########
                 ONEUNTIL_L:
0039b1 31d6
0039b2 6e75
0039b3 6974
0039b4 ff6c      		.db		NFA|IMMED|COMPILE|6,"1until",0xff
                 ONEUNTIL:
0039b5 2da6      		 mov t4,r_one			; b001 for Z-flag
0039b6 6160      		 sbr FLAGS1,(1<<izeroeq)
0039b7 cfe8      		 rjmp UNTILflag
                 
                 
0039b8 e0f2      		fdw		ALIGN_L
                 ; AGAIN ( adrs -- )				uncondional backward branch
                 AGAIN_L:
0039b9 61d5
0039ba 6167
0039bb 6e69      		.db		NFA|IMMED|COMPILE|5,"again"
                 AGAIN_:
0039bc 6062      		sbr FLAGS1,(1<<fTAILC)	; prevent tail jump optimization
0039bd 9100 02b9 		lds t0,dpFLASH
0039bf 9110 02ba 		lds t1,dpFLASH+1
0039c1 1b80      		sub tosl,t0
0039c2 0b91      		sbc tosh,t1
0039c3 9702      		sbiw TOP,2
                 ;		rjmp RJMPC
                 
                 ; rjmp, ( rel-addr -- )
                 RJMPC:
0039c4 9595      		asr tosh
0039c5 9587      		ror tosl
0039c6 709f      		andi tosh,0x0f
                 		;ori tosl, LOW(0xc000)	; 'rjmp ...'
0039c7 6c90      		ori  tosh,HIGH(0xc000)
0039c8 c2f8      		rjmp ICOMMA
                 
                 
0039c9 f0f2      		fdw		WORDS_L
                 ; WHILE ( addr1 -- addr2 addr1 )	branch for WHILE loop
                 ; addr1: address of BEGIN
                 ; addr2: address where to store breq instruction
                 WHILE_L:
0039ca 77d5
0039cb 6968
0039cc 656c      		.db		NFA|IMMED|COMPILE|5,"while"
                 WHILE_:
0039cd df61      		rcall IF_
0039ce c9a2      		rjmp SWOP_A
                 
                 
0039cf e9fa      		fdw		RSHIFT_L
                 ; REPEAT ( addr2 addr1 -- )		resolve WHILE loop
                 REPEAT_L:
0039d0 72d6
0039d1 7065
0039d2 6165
0039d3 ff74      		.db		NFA|IMMED|COMPILE|6,"repeat",0xff
                 REPEAT_:
0039d4 dfe7      		rcall AGAIN_
0039d5 cfa5      		rjmp THEN_
                 
                 
0039d6 da8c      		fdw		INVERT_L
                 INLINE_L:
0039d7 69d6
0039d8 6c6e
0039d9 6e69
0039da ff65      		.db      NFA|IMMED|COMPILE|6,"inline",0xff
                 ;INLINE
0039db 7466      		cbr FLAGS1,(1<<izeroeq)|(1<<idup)|(1<<icarryeq)|(1<<fLIT)|(1<<f2LIT)
0039dc dd18      		rcall TICK
0039dd c003      		rjmp INLINE0
                 
                 
0039de fd6c      		fdw		KEY_L
                 ; in, ( addr -- )
                 ;	begin @+ dup $9508 <> while i, repeat 2drop ;
                 INLINEC_L:
0039df 6983
0039e0 2c6e      		.db      NFA|3,"in,"
                 INLINE0:
0039e1 d138      		  rcall FETCHPP
0039e2 e915      		  ldi t1, HIGH(0x9508)	; 'ret'
0039e3 3088      		  cpi tosl,LOW(0x9508)
0039e4 0791      		  cpc tosh,t1
0039e5 f011      			breq INLINE1
0039e6 d2da      		  rcall ICOMMA
0039e7 cff9      		rjmp INLINE0
                 TWODROP_A:
                 INLINE1:
0039e8 9622      		adiw Y,2
0039e9 c375      		rjmp DROP_A
                 
                 
0039ea fbf2      		fdw		GCD_L
                 ; FOR  ( -- bc-addr bra-addr )
                 FOR_L:
0039eb 66d3
0039ec 726f      		.db		NFA|IMMED|COMPILE|3,"for"
                 FOR:
0039ed 939a
0039ee 938a
0039ef ef8c
0039f0 ef93      		inline_DOLIT ((XFOR<<1)+PFLASH)
                 
                 	.if optimizingCOMPILER == 1
0039f1 ff67      			sbrs FLAGS1,fLIT
0039f2 c004      			  rjmp FOR_0
                 		FORC_:
0039f3 7767      			cbr FLAGS1,(1<<fLIT)|(1<<f2LIT)
0039f4 ea10      			ldi t1,regX
0039f5 ddc9      			rcall ldi16_thtl_C_		; -> 'load literal to X'
0039f6 9606      			adiw TOP,6				; -> 'XFOR1'
                 		FOR_0:
                 	.endif
                 
0039f7 dfe9      		rcall INLINE0
0039f8 dd0b      		rcall IHERE
0039f9 9704      		sbiw TOP,4				; skip backwards 'push XL	push XH'
0039fa 939a
0039fb 938a      		duptos					; bc-addr
0039fc 9702      		sbiw TOP,2				; bra-addr
0039fd 9508      		ret
                 
                 XFOR:
0039fe 01dc      		movw X,TOP
0039ff 9189
003a00 9199      		poptos
                 XFOR1:
003a01 c000      		rjmp PC+1				; dummy address
003a02 93af      		push XL
003a03 93bf      		push XH
003a04 9508      		ret
                 
                 
003a05 df72      		fdw		DP_L
                 ; do (limit index --  R: -- limit index )
                 DO_L:
003a06 64d2
003a07 ff6f      		.db		NFA|IMMED|COMPILE|2,"do",0xff
                 DO:
003a08 939a
003a09 938a
003a0a e280
003a0b ef94      		inline_DOLIT ((XDO<<1)+PFLASH)
003a0c dfd4      		rcall INLINE0
003a0d dcf6      		rcall IHERE
003a0e 9708      		sbiw TOP,8				; adjust to '_LOOP:'
003a0f 9508      		ret
                 
                 XDO:
003a10 01dc      		movw t5t4,TOP			; index
003a11 9189
003a12 9199      		poptos
003a13 018c      		movw t1t0,TOP			; limit
003a14 9189
003a15 9199      		poptos
                 ;_LOOP:
003a16 930f      		push t0					; limit
003a17 931f      		push t1
003a18 93af      		push t4					; index
003a19 93bf      		push t5
003a1a 9508      		ret
                 
                 .if CPU_LOAD_LED == 0
003a1b dd2a      		fdw		MTSTZ_L
                 .elif CPU_LOAD_LED == 1
                 .else .error "illegal value: CPU_LOAD_LED"
                 .endif
                 ; leave ( --  R: limit index -- )	  #### one LEAVE per word ONLY!!! ####
                 LEAVE_L:							; #### do not open a loop after LEAVE !!! ####
003a1c 6cd5
003a1d 6165
003a1e 6576      		.db		NFA|IMMED|COMPILE|5,"leave"
                 LEAVE:
003a1f 939a
003a20 938a
003a21 e58a
003a22 ef94      		inline_DOLIT ((XLEAVE<<1)+PFLASH)
003a23 dfbd      		rcall INLINE0
003a24 9af3      		sbi FLAGS3,fLEAVE
003a25 ebe7
003a26 e0f2      		ldi16 Z,RAMvarBase
003a27 81a2      		ldd t4,Z+_dpFLASH
003a28 81b3      		ldd t5,Z+_dpFLASH+1
003a29 9712      		sbiw t5t4,2
003a2a 87b6      		std Z+_LEAVEadr+1,t5
003a2b 87a5      		std Z+_LEAVEadr  ,t4
003a2c 9508      		ret
                 
                 XLEAVE:
003a2d 910f      		pop t0
003a2e 910f      		pop t0
003a2f 910f      		pop t0
003a30 910f      		pop t0
003a31 c000      		rjmp PC+1				; dummy to be replaced by 'LOOP'
003a32 9508      		ret
                 
                 
003a33 dd0e      		fdw		MCLR_L
                 ; loop ( --  R: limit index -- limit index+1 )
                 ;      (     R: limit index --  )
                 LOOP_L:
003a34 6cd4
003a35 6f6f
003a36 ff70      		.db		NFA|IMMED|COMPILE|4,"loop",0xff
                 LOOP:
003a37 939a
003a38 938a
003a39 e982
003a3a ef94      		inline_DOLIT ((XLOOP<<1)+PFLASH)
003a3b dfa5      		rcall INLINE0
003a3c 9bf3      		sbis FLAGS3,fLEAVE
003a3d cf7e      		  rjmp AGAIN_			; write backward branch to '_LOOP'
                 LOOP_LEAVE:
003a3e 98f3      		cbi FLAGS3,fLEAVE
003a3f 939a
003a40 938a      		pushtos
003a41 9180 02c4 		lds tosl,LEAVEadr
003a43 9190 02c5 		lds tosh,LEAVEadr+1
003a45 e000      		ldi t0,0				; 0
003a46 e010      		ldi t1,0
003a47 df35      		rcall THEN_0			; write forward branch at LEAVE
003a48 cf73      		rjmp AGAIN_				; write backward branch to '_LOOP'
                 
                 XLOOP:
003a49 91bf      		pop t5					; index
003a4a 91af      		pop t4
003a4b 911f      		pop t1					; limit
003a4c 910f      		pop t0
003a4d 9611      		adiw t5t4,1
003a4e 170a      		cp  t0,t4
003a4f 071b      		cpc t1,t5
003a50 f008      		  brcs PC+2
003a51 9508      		ret
                 
003a52 e08c      		fdw		OVER_L
                 ; NEXT ( bc-addr bra-addr -- )
                 NEXT_L:
003a53 6ed4
003a54 7865
003a55 ff74      		.db		NFA|IMMED|COMPILE|4,"next",0xff
                 NEXT:
003a56 e002      		ldi t0,2				; +2
003a57 e010      		ldi t1,0
003a58 df24      		rcall THEN_0			; write forward branch at 'for'
003a59 939a
003a5a 938a
003a5b ec8c
003a5c ef94      		inline_DOLIT ((XNEXT<<1)+PFLASH)
003a5d df83      		rcall INLINE0
003a5e 9100 02b9 		lds t0,dpFLASH
003a60 9110 02ba 		lds t1,dpFLASH+1
003a62 1b80      		sub tosl,t0
003a63 0b91      		sbc tosh,t1
003a64 9702      		sbiw TOP,2
003a65 cf5e      		rjmp RJMPC
                 
                 ; (next) decrement top of return stack
                 ;		.db		NFA|0x20|6,"(next)",0xff
                 XNEXT:
003a66 91bf      		pop XH
003a67 91af      		pop XL
003a68 9711      		sbiw X,1
003a69 f008      		brcs PC+2
003a6a 9508      		ret
                 
                 
003a6b fd82      		fdw		EXECUTE_L
                 DNEGATE_L:
003a6c 6487
003a6d 656e
003a6e 6167
003a6f 6574      		.db		NFA|7,"dnegate"
                 DNEGATE:
003a70 9109
003a71 9119      		pop_t1t0				; d.l in t1:t0
                 DNEGATE_0:
003a72 1906      		sub t0,r_one
003a73 0917      		sbc t1,r_zero
003a74 0987      		sbc tosl,r_zero
003a75 0997      		sbc tosh,r_zero
003a76 c042      		rjmp DINVERT_0
                 
                 
003a77 e412      		fdw		CONSTANT_L
                 QDNEGATE_L:
003a78 3f88
003a79 6e64
003a7a 6765
003a7b 7461
003a7c ff65      		.db		NFA|8,"?dnegate",0xff
                 QDNEGATE:
003a7d 0f99      		lsl tosh				; mov sign to C-flag
003a7e 9189
003a7f 9199      		poptos
003a80 f378      		  brcs DNEGATE
003a81 9508      		ret
                 
                 
003a82 e054      		fdw		DROP_L
                 DABS_L:
003a83 6484
003a84 6261
003a85 ff73      		.db		NFA|4,"dabs",0xff
                 DABS:
003a86 fd97      		sbrc tosh,7
003a87 cfe8      		  rjmp DNEGATE
003a88 9508      		ret
                 
                 
003a89 db54      		fdw		MFETCH_L
                 ; m+  ( d n -- d1 )
                 MPLUS_L:
003a8a 6d82
003a8b ff2b      		.db		NFA|2, "m+",0xff
                 ;MPLUS:
003a8c 018c      		 movw t1t0,TOP			; n		(d2.l)
003a8d 0f99      		 lsl tosh				; s>d	(d2.h)
003a8e 0b88      		 sbc tosl,tosl
003a8f 0b99      		 sbc tosh,tosh
003a90 c005      		 rjmp DPLUS_0
                 
                 
003a91 f544      		fdw		DMINUS_L
                 DPLUS_L:
003a92 6482
003a93 ff2b      		.db		NFA|2,"d+",0xff
                 DPLUS:
003a94 9109
003a95 9119      		pop_t1t0				; d2.l
                 DPLUS_0:
003a96 91e9
003a97 91f9      		pop_t7t6				; d1.h
003a98 91a9
003a99 91b9      		pop_t5t4				; d1.l
003a9a 0f0a      		add t0,t4
003a9b 1f1b      		adc t1,t5
003a9c 1f8e      		adc tosl,t6
003a9d 1f9f      		adc tosh,t7
003a9e 931a
003a9f 930a      		push_t1t0
003aa0 9508      		ret
                 
                 
003aa1 e400      		fdw		DDOT_L
                 DMINUS_L:
003aa2 6482
003aa3 ff2d      		.db		NFA|2,"d-",0xff
                 DMINUS:
003aa4 9109
003aa5 9119      		 pop_t1t0				; d2.l
                 DMINUS_0:
003aa6 01fc      		 movw t7t6,TOP			; d2.h
003aa7 9189
003aa8 9199      		 poptos					; d1.h
003aa9 91a9
003aaa 91b9      		 pop_t5t4				; d1.l
003aab 1ba0      		 sub t4,t0
003aac 0bb1      		 sbc t5,t1
003aad 0b8e      		 sbc tosl,t6
003aae 0b9f      		 sbc tosh,t7
003aaf 93ba
003ab0 93aa      		 push_t5t4				; Z-flag valid
003ab1 9508      		 ret					; 13 / 21+4
                 
                 
003ab2 f4d8      		fdw		DNEGATE_L
                 DINVERT_L:
003ab3 64a7
003ab4 6e69
003ab5 6576
003ab6 7472      		.db		NFA|INLINE5|7,"dinvert"
                 DINVERT:
003ab7 9109
003ab8 9119      		pop_t1t0
                 DINVERT_0:
003ab9 9500      		com t0
003aba 9510      		com t1
003abb 9580      		com tosl
003abc 9590      		com tosh
003abd 931a
003abe 930a      		push_t1t0				; 8 / 12
003abf 9508      		ret
                 
                 
003ac0 db02      		fdw		DTWOSTAR_L
                 DZEROEQUAL_L:
003ac1 64a3
003ac2 3d30      		.db		NFA|INLINE5|3,"d0="
                 DZEROEQUAL:
003ac3 9109
003ac4 9119      		pop_t1t0
                 DZEROEQUAL_0:
003ac5 2b89      		or tosl,tosh
003ac6 2b80      		or tosl,t0
003ac7 2b81      		or tosl,t1
003ac8 9701      		sbiw TOP,1				; TOP == 0 -> C-flag
003ac9 0b88      		sbc tosl,tosl
003aca 0b99      		sbc tosh,tosh			; 8 / 11
003acb 9508      		ret
                 
                 
003acc f5bc      		fdw		DGREATER_L
                 DEQUAL_L:
003acd 6482
003ace ff3d      		.db		NFA|2,"d=",0xff
003acf dfd4      		rcall DMINUS			; d1 d2 -
003ad0 9701      		sbiw TOP,1
003ad1 c007      		rjmp putFlag
                 
                 
003ad2 f59a      		fdw		DEQUAL_L
                 DLESS_L:
003ad3 6482
003ad4 ff3c      		.db		NFA|2,"d<",0xff
                 DLESS:
003ad5 dfce      		rcall DMINUS			; d1 d2 -
003ad6 f40b      		brvc PC+2
                 DG_2:
003ad7 9590      		  com tosh
                 DG_1:
003ad8 0f99      		lsl tosh
                 putFlag:
003ad9 0b88      		sbc tosl,tosl
003ada 0b99      		sbc tosh,tosh
003adb 9622      		adiw Y,2				; NIP d'.l (from DMINUS)
003adc 9508      		ret
                 
                 
003add d9c2      		fdw		DI_L
                 DGREATER_L:
003ade 6482
003adf ff3e      		.db		NFA|2,"d>",0xff
                 DGREATER:
003ae0 dfc3      		rcall DMINUS
003ae1 f3b9      		  breq putFlag			; d1 == d2 -> C=0 -> put FALSE
003ae2 f3ab      		brvs DG_1
003ae3 f79b      		brvc DG_2
                 
                 
                 
                 .if FLASHEND > 0x3fff
                   .ifdef RAMPZ
                   .endif
                   .ifdef RAMPZ
                   .endif
                 .endif
                 
                 
003ae4 0000      		.dw     0
                 ; FORGET ( "name" -- ) 
                 ;  bl word latest @ (f) ?abort?
                 ;  c>n 2- dup @ ?abort?
                 ;  dup flash dp ! @ latest ! ram
                 FORGET_L:
003ae5 6686
003ae6 726f
003ae7 6567
003ae8 ff74      		.db		NFA|6,"forget",0xff
                 ;FORGET:
003ae9 d82c      		rcall BL_WORD
003aea dcfb      		rcall LATEST_
003aeb d252      		rcall FETCH
003aec dab1      		rcall findi
003aed dbc8      		rcall QABORTQ
003aee db59      		rcall CFATONFA
003aef 9702      		sbiw TOP,2				; LFA
003af0 939a
003af1 938a      		duptos
003af2 d24b      		rcall FETCH
003af3 dbc2      		rcall QABORTQ
003af4 9390 02ba
003af6 9380 02b9 		sts16 dpFLASH,tos		; dup idp !
003af8 d245      		rcall FETCH
003af9 dcec      		rcall LATEST_
003afa c25b      		rjmp STORE
                 
                 
003afb f5ca      		fdw		FORGET_L
                 ; marker ( "name" -- )
                 MARKER_L:
                 lastword:
003afc 6d86
003afd 7261
003afe 656b
003aff ff72      		.db		NFA|6,"marker",0xff
                 ;MARKER:
003b00 bc7a      		out cse,r_zero			; 'flash'
003b01 dc4e      		rcall CREATE
003b02 dbea      		rcall DOLIT 
003b03 0900      		.dw dp_start
003b04 dbff      		rcall IHERE
003b05 d00e      		rcall TEN_CMOVE
003b06 dbfd      		rcall IHERE
003b07 960a      		adiw TOP,10
003b08 9390 02ba
003b0a 9380 02b9 		sts16 dpFLASH,tos
003b0c e004      		ldi t0,4
003b0d bd0a      		out cse,t0				; 'ram'
003b0e dc6d      		rcall XDOES_pushed
003b0f d039      		rcall DODOES
003b10 939a
003b11 938a      		pushtos
003b12 eb87
003b13 e092      		ldi16 tos,dpSTART
                 TEN_CMOVE:
003b14 dbd8      		rcall DOLIT
003b15 000a      		.dw 10
003b16 caf1      		rjmp CMOVE
                 
                 
                 .if CPU_LOAD_LED == 1
                 			.if CPU_LOAD_LED_POLARITY == 1
                 			.elif CPU_LOAD_LED_POLARITY == 0
                 			.else .error "illegal value: CPU_LOAD_LED_POLARITY"
                 			.endif
                 .endif
                  
                 ; @+   ( addr -- addr+2 n )
                 ;   dup 2+ swap @ ;
003b17 dc38      		fdw		L_FETCH_P
                 FETCHPP_L:
003b18 4082
003b19 ff2b      		.db		NFA|2,"@+",0xff
                 FETCHPP:
003b1a d223      		rcall FETCH
003b1b 93fa
003b1c 93ea      		push_Z
003b1d 9508      		ret
                 
                 
                 ; c@+  ( addr -- addr+1 n )
                 ;   dup 1+ swap c@ ;
003b1e dfa0      		fdw		COMMAXT_L
                 CFETCHPP_L:
003b1f 6383
003b20 2b40      		.db		NFA|3,"c@+"
                 CFETCHPP:
003b21 d225      		rcall CFETCH
003b22 93fa
003b23 93ea      		push_Z
003b24 9508      		ret
                 
                 
                 .if CPU_LOAD == 1
                 .endif
                 
                 .ifdef UCSR1A
                   .if U1FC_TYPE == 1
                   .elif U1FC_TYPE == 2
                   .else .error "illegal value: U1FC_TYPE"
                   .endif
                   .if OPERATOR_UART == 1
                     .if CTRL_O_WARM_RESET == 1
                     .endif
                   .endif
                   .if U1FC_TYPE == 1
                   .elif U1FC_TYPE == 2
                   .else .error "illegal value: U1FC_TYPE"
                   .endif
                 .endif
                 
                 
                 
                 
                 ; unsigned 16/16 -> 32 multiply
                 umstar0:						; product.l in t5t4, product.h in t7:t6
003b25 9109
003b26 9119      		 pop_t1t0
                 umstar0_0:
003b27 9f80      		 mul tosl,t0
003b28 01d0      		 movw t5t4,R1:R0
003b29 9f91      		 mul tosh, t1
003b2a 01f0      		 movw t7t6,R1:R0
003b2b 9f90      		 mul tosh, t0
003b2c 0db0      		 add t5,R0
003b2d 1de1      		 adc t6,R1
003b2e 1df7      		 adc t7,r_zero
003b2f 9f81      		 mul tosl, t1
003b30 0db0      		 add t5,R0
003b31 1de1      		 adc t6,R1
003b32 1df7      		 adc t7,r_zero
003b33 9508      		 ret					; 15 / 20+4
                 
                 
003b34 d964      		fdw		ALIGNED_L
                 QNEGATE_L:
003b35 3f87
003b36 656e
003b37 6167
003b38 6574      		.db		NFA|7,"?negate"
                 ;QNEGATE:
003b39 0f99      		lsl tosh				; copy sign into C-flag
003b3a 9189
003b3b 9199      		poptos
003b3c f030      		  brcs NEGATE
003b3d 9508      		ret
                 
                 
003b3e ed44      		fdw		PROMPT_L
                 NEGATE_L:
003b3f 6ea6
003b40 6765
003b41 7461
003b42 ff65      		.db		NFA|INLINE|6, "negate",0xff
                 NEGATE:
003b43 9580      		com tosl
003b44 9590      		com tosh
003b45 9601      		adiw TOP,1				; 3 / 4
003b46 9508      		ret
                 
                 
                 ;;; Resolve the runtime action of the word created by using does>
                 DODOES_L:
003b47 2883
003b48 2964      		.db		NFA|3,"(d)"		; just for 'see' to work
                 DODOES:
                 		m_pop_xh
003b49 91bf      		pop XH
003b4a 91af      		pop XL
                 		m_pop_zh
003b4b 91ff      		pop ZH
003b4c 91ef      		pop ZL
003b4d d8ea      		rcall FETCHLIT
003b4e 01fd      		movw Z,X
003b4f 9409      		mijmp					; 7 / 30
                 
                 
                 ; rx0 complete interrupt
                 RX0_ISR:
003b50 b73f      		in_ SREG_intSafe,SREG
003b51 930f      		push t0
003b52 9100 00c6 		in_ t0,UDR0_
                 
003b54 300f      		cpi t0,CTRL_O
003b55 f409      		brne PC+2
003b56 c3a9      		  rjmp RESET_
                 
003b57 91e0 02b6 		lds ZL,rbuf0_lv			; rbuf0 size fix to 0x100
003b59 95e3      		inc ZL
003b5a f061      		  breq RX0_OVF
003b5b 93e0 02b6 		sts rbuf0_lv,ZL
003b5d 91e0 02b4 		lds ZL,rbuf0_wr
003b5f e0f1      		ldi ZH,HIGH(rbuf0)		; rbuf0 on page boundary!!
003b60 9301      		st Z+,t0
003b61 93e0 02b4 		sts rbuf0_wr,ZL
                 RX0_ISR_EXIT:
003b63 910f      		pop t0
003b64 bf3f      		out_ SREG,SREG_intSafe
003b65 01f2      		movw Z,intSafe16
003b66 9518      		reti
                 
                 RX0_OVF:
003b67 e7fc      		ldi ZH,'|'
003b68 d043      		rcall TX0_SEND
003b69 cff9      		rjmp RX0_ISR_EXIT
                 
                 
003b6a e0d2      		fdw		ABS_L
                 ; ['] ( "name" -- )				find word & compile xt as literal
                 BRACTICK_L:
003b6b 5bd3
003b6c 5d27      		.db		NFA|IMMED|COMPILE|3,"[']"
                 ;BRACTICK:
003b6d db87      		rcall TICK				; get xt of 'name'
003b6e c126      		rjmp LITERAL
                 
                 
003b6f f394      		fdw		WHILE_L
                 VALUE_L:
003b70 7685
003b71 6c61
003b72 6575      		.db		NFA|5,"value"
                 VALUE:
003b73 dbdc      		rcall CREATE
003b74 dab6      		rcall COMMA
003b75 dc04      		rcall XDOES
                 VALUE_DOES:
003b76 dfd2      		rcall DODOES
003b77 c1c6      		rjmp FETCH
                 
                 
003b78 e342      		fdw		TODIGIT_L
                 DEFER_L:
003b79 6485
003b7a 6665
003b7b 7265      		.db		NFA|5,"defer"
                 DEFER:
003b7c dbd3      		rcall CREATE
003b7d 939a
003b7e 938a
003b7f e588
003b80 ee9d      		inline_DOLIT ((ABORT<<1)+PFLASH)
003b81 daa9      		rcall COMMA
003b82 dbf7      		rcall XDOES
                 DEFER_DOES:
003b83 dfc5      		rcall DODOES
003b84 c34a      		rjmp FEXECUTE
                 
                 
003b85 db3e      		fdw		MSTORE_L
                 IS_L:
003b86 69c2
003b87 ff73      		.db		NFA|IMMED|2,"is",0xff
                 IS:
003b88 db6c      		rcall TICK				; -> fdw TURNKEY
003b89 9604      		adiw TOP,4				; '.dw dpSTART'
003b8a d1b3      		rcall FETCH
003b8b ff77      		sbrs FLAGS2,fSTATE
003b8c c1c9      		  rjmp STORE
003b8d d107      		rcall LITERAL
003b8e d8b2      		rcall DOCOMMAXT
003b8f faac      		fdw STORE
003b90 9508      		ret
                 
                 
003b91 e3cc      		fdw		UDOT_L
                 TO_L:
003b92 74c2
003b93 ff6f      		.db		NFA|IMMED|2,"to",0xff
                 TO:
003b94 cff3      		rjmp IS
                 
                 
003b95 f4f0      		fdw		QDNEGATE_L
                 TURNKEY_L:
003b96 7487
003b97 7275
003b98 6b6e
003b99 7965      		.db		NFA|7,"turnkey"
                 TURNKEY:
                 		;--------------------------------------------------
003b9a 940e 3b76 		call VALUE_DOES      	; 'call ..' for IS to work!
                 		;--------------------------------------------------
003b9c 02b7      		.dw dpSTART
                 
                 
003b9d ebe0      		fdw		STARSLASH_L
                 ; TX0  ( c -- )					output character to UART0
                 TX0_L:
003b9e 7483
003b9f 3078      		.db		NFA|3,"tx0"
                 TX0_:
                 	  .if U0FC_TYPE == 1
                 	  .endif
                 	  .if IDLE_MODE == 1
003ba0 6074      		sbr FLAGS2,(1<<fTX0pending)
                 	  .endif
                 
                 TX0_LOOP:
003ba1 d1e9      		  rcall PAUSE
                 TX0_quick:
003ba2 9190 00c0 		  in_ tosh,UCSR0A
003ba4 ff95      		  sbrs tosh,UDRE0		; USART0 Data Register Empty
003ba5 cffb      		rjmp TX0_LOOP
                 
003ba6 9380 00c6 		out_ UDR0_,tosl
003ba8 9189
003ba9 9199      		poptos
                 	  .if IDLE_MODE == 1
003baa 7f7b      		cbr FLAGS2,(1<<fTX0pending)
                 	  .endif
                 
003bab 9508      		ret
                 
                 	.if U0FC_TYPE == 1
                 	.endif
                 
                 TX0_SEND:
003bac 91e0 00c0 		  in_ ZL,UCSR0A
003bae ffe5      		  sbrs ZL,UDRE0			; USART0 Data Register Empty
003baf cffc      		rjmp TX0_SEND
003bb0 93f0 00c6 		out_ UDR0_,ZH
003bb2 9508      		ret
                 
                 
003bb3 dc0e      		fdw		STOD_L
                 ; RX0    -- c    get character from the UART0 buffer
                 RX0_L:
003bb4 7283
003bb5 3078      		.db		NFA|3,"rx0"
                 RX0_:
003bb6 d1d4      		  rcall PAUSE
003bb7 b70f      		  in_ t0,SREG
003bb8 94f8      		  cli			
003bb9 91a0 02b6 		  lds XL,rbuf0_lv		; rbuf0 size fix to 0x100
003bbb 50a1      		  subi XL,1
003bbc f410      			brcc RX0_1
003bbd bf0f      		  out_ SREG,t0
003bbe cff7      		rjmp RX0_
                 
                 RX0_1:
003bbf 93a0 02b6 		sts rbuf0_lv,XL
003bc1 91a0 02b5 		lds XL,rbuf0_rd
003bc3 e0b1      		ldi XH,HIGH(rbuf0)		; rbuf0 on page boundary
003bc4 939a
003bc5 938a      		pushtos
003bc6 918d      		ld tosl,X+
003bc7 2799      		clr tosh
003bc8 93a0 02b5 		sts rbuf0_rd,XL
003bca bf0f      		out_ SREG,t0
003bcb 9508      	  ret
                 
                 
                 .ifdef UCSR1A
                 .else
003bcc dbee      		fdw		ENDIT_L
                 .endif
                 EMPTY_L:
003bcd 6585
003bce 706d
003bcf 7974      		.db		NFA|5,"empty"
                 EMPTY:
003bd0 db1c      		rcall DOLIT
003bd1 d786      		fdw COLDLIT
003bd2 db1a      		rcall DOLIT
003bd3 0900      		.dw dp_start
003bd4 db18      		rcall DOLIT
003bd5 000c      		.dw coldlitsize
003bd6 da31      		rcall CMOVE				; burn DP's to EEPROM
003bd7 c909      		rjmp DP_TO_RAM			; .. and copy to RAM
                 
                 
003bd8 e4c4      		fdw		WORD_L
                 WARM_L:
003bd9 7784
003bda 7261
003bdb ff6d      		.db		NFA|4,"warm",0xff
                 WARM_:
003bdc 94e8      		clt
                 WARM_math:
003bdd 27dd      		clr YH
                 	.ifdef MCUCSR
                 	.endif
                 	.ifdef MCUSR
003bde b604      			in_ R0,MCUSR
003bdf bfd4      			out_ MCUSR,YH
                 	.endif
                 WARM_0:
003be0 b61f      		in_ R1,SREG	
003be1 94f8      		cli
                 ; zero memory
003be2 e0a2      		ldi XL,2
003be3 e0b0      		ldi XH,0
                 WARM_1:							; clear register R2..R25 (r_zero, FLAGS1, FLAGS2, TOP included)
003be4 93dd      		  st X+,YH
003be5 31aa      		  cpi XL,26
003be6 f7e9      		brne WARM_1
                 
003be7 9100 0066 		in_ t0,OSCCAL		; save OSCCAL for ...
                 
003be9 e1ac      		ldi XL,28  				; clear IO and RAM from Y register upwards (FLAGS3, cse included)
                 WARM_2:
003bea 927d      		  st X+,r_zero
003beb 30b9      		  cpi XH,HIGH(PEEPROM)	; up to the end of SRAM
003bec f7e9      		brne WARM_2
                 
003bed 9300 0066 		out_ OSCCAL,t0		; .. flash + eeprom write timing
                 
                 ; init empty flash buffer
003bef 94da      	    dec ibaseH				; 0xff
                 
                 	.ifdef RAMPZ
                 	.endif
                 
                 ; init Stack pointer
003bf0 e6c0      		ldi YL, low(utibbuf-4)	; 2 cells safety
003bf1 e0d3      		ldi YH,high(utibbuf-4)
                 ; init Return stack pointer
003bf2 e202      		ldi t0, LOW(usbuf-2)	; 1 cell safety
003bf3 e013      		ldi t1,HIGH(usbuf-2)
003bf4 bf0d      		out SPL,t0
003bf5 bf1e      		out SPH,t1
                 
                 		;rcall   INIT_012		; Init constant registers
                 ;INIT_012:
                 		;clr r_zero				; already there
003bf6 9463      		inc r_one				; from 0 to 1
                 ;		inc r_two	inc r_two	; no r_two anymore
                 
003bf7 d074      		rcall WDOFF
                 ; init user pointer
003bf8 ee02      		ldi t0, LOW(up0)
003bf9 e012      		ldi t1,HIGH(up0)
003bfa 0118      		movw UP,t1t0
                 
                 	.ifdef RAMPZ
                 	.endif
                 	.ifdef EIND
                 	.endif
                 
                 ; init warm literals
003bfb daf1      		rcall DOLIT
003bfc d774      		fdw WARMLIT
003bfd daef      		rcall DOLIT
003bfe 02c6      		.dw uvars
003bff daed      		rcall DOLIT
003c00 0014      		.dw warmlitsize
003c01 da06      		rcall CMOVE
                 
                 		;out cse,r_zero			; initialized to 0 (= 'flash')
                 		;out state,r_two		; initialized to 0 (= 'interpret') with FLAGS2
                 
                 ; init cold data to eeprom
003c02 e0e0      		ldi ZL, LOW(dp_start)
003c03 e0f9      		ldi ZH,HIGH(dp_start)
                 ;		pushtos					; stack is empty -> nothing to save
003c04 9468      		set
003c05 d111      		rcall EFETCH			; Z+ included
003c06 9601      		adiw TOP,1				; if 'turnkey' is 0xffff then burn DP's to EEPROM
                 ;		poptos					; nothing pushed yet
003c07 f409      		brne PC+2
003c08 dfc7      		  rcall EMPTY
                 								; move interrupts to boot flash section
003c09 be65      		out_ MCUCR,r_one   		; (1<<IVCE)
003c0a e0f2      		ldi t7,2				; (1<<IVSEL)
003c0b bff5      		out_ MCUCR,t7
                 
                 ; init MS timer
                 	.if MS_TIMER == 0
                 	  .ifdef TIMSK0
003c0c bdf4      			out_ TCCR0A,t7			; 0x02 (CTC mode)
003c0d e003      	       	ldi t0,ms_pre_tmr0
003c0e bd05      	       	out_ TCCR0B,t0
003c0f ef09      	       	ldi t0,ms_value_tmr0
003c10 bd07      	       	out_ OCR0A,t0
003c11 93f0 006e 			out_ TIMSK0,t7			; 0x02 (1<<OCIE0A)
                 	  .endif
                 	  .ifdef TIMSK
                 	  .endif
                 	.elif MS_TIMER == 1
                   	  .ifdef TIMSK
                   	  .endif
                   	  .ifdef TIMSK1
                   	  .endif
                 	.elif MS_TIMER == 2
                   	  .ifdef TIMSK2
                   	  .endif
                   	  .ifdef TIMSK
                   	  .endif
                 	.endif
                 
                 ; init load counter
                 	.if CPU_LOAD == 1
                   	  .ifdef TIMSK
                   	  .endif
                   	  .ifdef TIMSK1
                   	  .endif
                 	.endif
                 
                 ; init UART0
                 .ifdef UBRR0L
003c13 e500      		ldi t0, LOW(RX0_ISR)
003c14 e31b      		ldi t1,HIGH(RX0_ISR)
                 
                   .ifdef URXC0addr
                   .else
003c15 9310 02a5   			sts (URXCaddr+ivec+1),t1
003c17 9300 02a4 			sts (URXCaddr+ivec)  ,t0
                   .endif
                 
003c19 e100      		ldi t0,ubrr0val				; set baud rate
003c1a 9300 00c4 		out_ UBRR0L,t0
003c1c 93f0 00c0 		out_ UCSR0A,t7				; 0x02 -> set double speed mode			
003c1e e908      		ldi t0,(1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)	; enable receiver, transmitter, rx0 interrupts
003c1f 9300 00c1 		out_ UCSR0B,t0
003c21 e006      		ldi t0,(3<<UCSZ00)|URSEL_	; set frame format: 8data, 1stop bit
003c22 9300 00c2 		out_ UCSR0C,t0
                 
                   .if U0FC_TYPE == 0
                 ;  .elif  U0FC_TYPE == 1
                 ;			sbr FLAGS2,(1<<ixoff_tx0)
                 ;  .elif U0FC_TYPE == 2
                 ;			sbi_ U0RTS_DDR,U0RTS_BIT
                   .else .error "illegal value: U0FC_TYPE"
                   .endif
                 .endif
                 								; init rbuf0 pointer
                 		;sts rbuf0_lv,r_zero		; (done with RAM init)
                 		;sts rbuf0_rd,r_zero
                 		;sts rbuf0_wr,r_zero
                 
                 	; init UART1
                 	.ifdef UBRR1L
                   	  .if U1FC_TYPE == 1
                   	  .endif
                   	  .if U1FC_TYPE == 2
                   	  .endif
                 	.endif
                 	.ifdef rbuf1_lv
                 	.endif
                 
003c24 d8bc      		rcall DP_TO_RAM
                 
003c25 9478      		sei
                 		 ;rcall RQ_EMIT
                 ;RQ_EMIT:
003c26 e200      		ldi t0,' '
003c27 fc02      		sbrc R0,BORF
003c28 e402      		  ldi t0,'B'
003c29 fc03      		sbrc R0,WDRF
003c2a e507      		  ldi t0,'W'
003c2b fc01      		sbrc R0,EXTRF
003c2c e405      		  ldi t0,'E'
003c2d fc00      		sbrc R0,PORF			; (MCUSR reset value in R0)
003c2e e500      		  ldi t0,'P'
003c2f fc16      		sbrc R1,6				; T with MATH error (SREG reset value in R1)
003c30 e40d      		  ldi t0,'M'
003c31 db40      		rcall EMIT_t0
                 
003c32 d85b      		rcall VER
                 ; init LED
003c33 9a25      		sbi_ CPU_LOAD_DDR,CPU_LOAD_BIT
                        .if CPU_LOAD_LED_POLARITY == 1
003c34 982d      			cbi_ CPU_LOAD_PORT,CPU_LOAD_BIT
                        .else
                        .endif
                 
                 WARM_4:						; write protect bootloader section
003c35 99f9      		  sbic EECR,EEPE
003c36 cffe      		rjmp WARM_4				; EEPROM write in progress?
                 
003c37 01f3      		movw Z,r_one
003c38 ee0f      		ldi t0,0xef				; BLB11 = 0
003c39 2e00      		mov R0,t0
003c3a e019      		ldi t1,(1<<BLBSET) | (1<<SPMEN)
003c3b d2f9      		rcall DO_SPM
                 
                 ; check 'turnkey'
003c3c df5d      		rcall TURNKEY
003c3d 9700      		sbiw TOP,0
003c3e f071      		  breq STARTQ2
003c3f dc26      		rcall XSQUOTE
003c40 7306
003c41 6174
003c42 7472
003c43 003f      		.db  6,"start?",0
003c44 dc7f      		rcall TYPE
003c45 ed80
003c46 e097      		ldi16 tos,TURNKEY_DELAY
003c47 d136      		rcall MS
003c48 d275      		rcall KEYQ
003c49 9700      		sbiw TOP,0
003c4a f411      		  brne STARTQ2
                 STARTQ1:						; no key -> execute
003c4b df4e      		rcall TURNKEY
003c4c d278      		rcall EXECUTE
                 STARTQ2:
003c4d ca5e      		rjmp ABORT
                 
003c4e d942      		fdw		RPFETCH_L
                 ROT_L:
003c4f 7283
003c50 746f      		.db		NFA|3, "rot"
                 ROT:
003c51 91a9
003c52 91b9      		 pop_t5t4
003c53 9109
003c54 9119      		 pop_t1t0
003c55 93ba
003c56 93aa      		 push_t5t4
003c57 939a
003c58 938a      		 pushtos
003c59 01c8      		 movw TOP,t1t0			; 9 / 17
003c5a 9508      		 ret
                 
                 
                 .if (FLASHEND < 0x1ffff)
003c5b f8d4      			fdw		WDOFF_L
                 	; WD+ ( n -- )				n < 8, start watchdog timer
                 	WDON_L:
003c5c 7783
003c5d 2b64      			.db		NFA|3,"wd+"
                 	;WDON:
003c5e 94f8      			cli
003c5f 95a8      			wdr
003c60 7087      			andi tosl,7
003c61 6088      			ori tosl,(1<<WDE)
003c62 e198      			ldi tosh,(1<<WDCE)|(1<<WDE)
003c63 9390 0060 			out_ WDTCSR,tosh
003c65 9380 0060 			out_ WDTCSR,tosl
003c67 9478      			sei
003c68 c0f6      			rjmp DROP_A
                 
                 
003c69 dbac      			fdw		X_TO_R_L
                 	; WD- ( -- )				stop the watchdog 
                 	WDOFF_L:
003c6a 7783
003c6b 2d64      			.db		NFA|3,"wd-"
                 	WDOFF:
003c6c 94f8      			cli
003c6d 95a8      			wdr
                   	.ifdef MCUSR
003c6e be74      				out_ MCUSR,r_zero
                   	.else
                   	.endif
003c6f e108      			ldi t0,(1<<WDCE)|(1<<WDE)
003c70 9300 0060 			out_ WDTCSR,t0
003c72 9270 0060 			out_ WDTCSR,r_zero
003c74 9478      			sei
003c75 9508      			ret
                 .endif
                 
                 ;*******************************************************
                 ; ;i ( -- )						end definition of user interrupt routine
003c76 e330      		fdw		LESSNUM_L
                 IRQ_SEMI_L:
003c77 3bc2
003c78 ff69      		.db		NFA|IMMED|2,";i",0xff
                 ;IRQ_SEMI:
003c79 da73      		rcall DOLIT
                 
                 	.ifdef EIND
                 	.else
003c7a 940c      			.dw 0x940C			; jmp <page 0>
                 	.endif
                 
003c7b d045      		rcall ICOMMA
003c7c da70      		rcall DOLIT
003c7d 3ed1      		.dw OF_ISR_EXIT
003c7e 777f      		cbr FLAGS2,(1<<fSTATE)
003c7f c041      		rjmp ICOMMA
                 
                 
003c80 fd76      		fdw		KEYQ_L
                 ; int! ( addr n  --  )			store to interrupt vector number
                 IRQ_V_L:
003c81 6984
003c82 746e
003c83 ff21      		.db		NFA|4,"int!",0xff
                 ;IRQ_V:
003c84 5081      		subi tosl,1
003c85 0f88      		lsl tosl
003c86 e8e0      		ldi ZL, LOW(ivec)
003c87 e0f2      		ldi ZH,HIGH(ivec)
003c88 0fe8      		add ZL,tosl
003c89 1df7      		adc ZH,r_zero
003c8a 9189
003c8b 9199      		poptos
003c8c 5890      		sub_pflash_tos			; TO_XA (virtual addr -> real addr)
003c8d 9596      		lsr tosh
003c8e 9587      		ror tosl
003c8f c0cd      		rjmp SRZ_w				; store word to RAM
                 
                 
003c90 e894      		fdw		NUMBERQ_L
                 ; DOLITERAL ( x -- )			compile DOLITeral x as native code
                 LITERAL_L:
003c91 6cc7
003c92 7469
003c93 7265
003c94 6c61      		.db		NFA|IMMED|7,"literal"
                 LITERAL:
003c95 939a
003c96 938a      		pushtos
003c97 e888
003c98 ed9b      		ldi16 tos,((DUP<<1)+PFLASH)
003c99 dd47      		rcall INLINE0
                 ;LITERAL_2:
003c9a fd67      		sbrc FLAGS1,fLIT
003c9b 6068      		  sbr FLAGS1,(1<<f2LIT)
003c9c 6860      		sbr FLAGS1,(1<<fLIT)
003c9d 786e      		cbr FLAGS1,(1<<izeroeq)|(1<<idup)|(1<<icarryeq)|(1<<doclear)
003c9e 9380 02c3 		sts litbuf0,tosl
003ca0 bd9b      		out litbuf1,tosh
003ca1 939a
003ca2 938a      		duptos
003ca3 2f98      		mov tosh,tosl
003ca4 e810      		ldi t1,regtosl			; 'ldi regl,<lit.0>'
003ca5 d002      		rcall LITERAL_1
                 
003ca6 2f89      		mov tosl,tosh
003ca7 e910      		ldi t1,regtosh			; 'ldi regh,<lit.1>'
                 LITERAL_1:
003ca8 9592      		swap tosh
003ca9 709f      		andi tosh,0x0f
003caa 708f      		andi tosl,0x0f
003cab 6e90      		ori tosh,0xe0			; 'ldi ..,..'
003cac 2b81      		or tosl,t1
003cad c013      		rjmp ICOMMA
                 
                 #if 0
                 #endif
                 
                 
                 ;*****************************************************************
                 .if optimizingCOMPILER == 1
                 	FETCHC_:
003cae d007      			 rcall FETCHC_helper	; compile 'in/lds tosl,<addr>'
003caf 9601      			 adiw TOP,1				; <addr+1>
003cb0 e9a0      			 ldi t4,0x90			; register 0x19 -> tosh
003cb1 c8a4      			 rjmp comp_lds_			; compile 'in/lds tosh,<addr+1>'
                 
                 	CFETCHC_:
003cb2 d003      			 rcall FETCHC_helper
                 	ldi_tosh_0_C_:
003cb3 e980
003cb4 ee90      			 ldi16 tos,0xe090		; replace <addr> by 'ldi tosh,0x00'
003cb5 c00b      			 rjmp ICOMMA
                 	
                 	FETCHC_helper:
003cb6 dc60      			 rcall IDP4MINUS
003cb7 9180 02c3 			 lds tosl,litbuf0		; lit in TOP
003cb9 b59b      			 in tosh,litbuf1
                 	FETCHC_help0:
003cba 939a
003cbb 938a      			 duptos					; dup <addr>
003cbc e8a0      			 ldi t4,0x80			; register 0x18 -> tosl
003cbd c898      			 rjmp comp_lds_
                 .endif	
                 
                 
003cbe f25a      		fdw		IF_L
                 ICOMMA_L:
003cbf 6982
003cc0 ff2c      		.db		NFA|2, "i,",0xff
                 ICOMMA:
003cc1 9468      		set
003cc2 e002      		ldi t0,2
                 ICOMMA_0:
003cc3 99f2      		sbic FLAGS3,fLOCK
003cc4 c021      		  rjmp ISTORERR
003cc5 eba9
003cc6 e0b2      		ldi16 X,dpFLASH
003cc7 91ed      		ld ZL,X+
003cc8 91fd      		ld ZH,X+
003cc9 0fe0      		add ZL,t0
003cca 1df7      		adc ZH,r_zero
003ccb 93fe      		st -X,ZH
003ccc 93ee      		st -X,ZL
003ccd 1be0      		sub ZL,t0
003cce 09f7      		sbc ZH,r_zero
003ccf c032      		rjmp ISTORE_Z
                 
                 
003cd0 f3be      		fdw		INLINEC_L
                 ; ic,  ( c -- )					write char at ihere
                 ;   IHERE c! 1 CHARS IALLOT ;
                 ICCOMMA_L:
003cd1 6983
003cd2 2c63      		.db		NFA|3,"ic,"
                 ICCOMMA:
003cd3 94e8      		 clt
003cd4 e001      		 ldi t0,1
003cd5 cfed      		 rjmp ICOMMA_0
                 
                 
003cd6 e042      		fdw		SPACES_L
                 ; SOURCE  ( -- addr n )			current input buffer
                 ;	'SOURCE 2@ ;				length is at higher adrs
                 SOURCE_L:
003cd7 7386
003cd8 756f
003cd9 6372
003cda ff65      		.db		NFA|6,"source",0xff
                 ;SOURCE:
003cdb 939a
003cdc 938a      		 pushtos
003cdd 01f1      		 movw Z,UP
003cde 9738      		 sbiw Z,(-usource)
003cdf 9181      		 ld tosl,Z+
003ce0 9191      		 ld tosh,Z+
003ce1 939a
003ce2 938a      		 pushtos
003ce3 9181      		 ld tosl,Z+
003ce4 9191      		 ld tosh,Z+				; 10 / 19
003ce5 9508      		 ret
                 
                 
                 ISTORERR:						; write access to kernel
003ce6 dbc8      		rcall DOTS
003ce7 db7e      		rcall XSQUOTE
003ce8 4103
003ce9 3f44      		.db 3,"AD?"
003cea dbd9      		rcall TYPE
003ceb c9c0      		rjmp ABORT
                 		
                 IIFETCH_0:
003cec 25ec      		eor ZL,ibaseL
                 IIFETCH:
003ced 9185      		lpm_ tosl,Z+	     	; fetch from FLASH directly
003cee f40e      		brtc PC+2
003cef 9195      		  lpm_ tosh,Z+
003cf0 58f0      		add_pflash_z
003cf1 9508      		ret
                 
                 IFETCH:
003cf2 58f0      		sub_pflash_z
                 IFETCH_0:
                 	.ifdef RAMPZ
                 	.endif
                 
003cf3 11fd      		cpse ZH,ibaseH
003cf4 cff8      		  rjmp IIFETCH
                 IFETCH_buf:
                 	  .if PAGESIZEB == 0x80
003cf5 25ec      		eor ZL,ibaseL
003cf6 f3aa      		  brmi IIFETCH_0
003cf7 e0f2      		ldi ZH,HIGH(ibuf)
003cf8 8180      		ldd tosl,Z+0
003cf9 f40e      		brtc PC+2
003cfa 8191      		  ldd tosh,Z+1
003cfb 25ec      		eor ZL,ibaseL
003cfc 2dfd      		mov ZH,ibaseH
003cfd 9631      		adiw Z,1
003cfe f40e      		brtc PC+2
003cff 9631      		  adiw Z,1
003d00 58f0      		add_pflash_z
003d01 9508      		ret
                 	  .else
                 	  .endif
                 /*	  .if PAGESIZEB == 0x80
                 		mov XL,ZL				; ATmega328
                 		eor XL,ibaseL			; ibaseL = x000 0000
                 		  brmi IIFETCH			; bits 7 not equal -> go fetch directly
                 	  .else
                 			mov t0,ZL
                 			andi t0,~(PAGESIZEB-1)
                 			cp t0,ibaseL
                 			  brne IIFETCH
                 			mov XL,ZL
                 			andi XL,(PAGESIZEB-1)
                 	  .endif
                 	  						; bits 7 equal -> XL = 0xxx xxxx
                 		;add XL, LOW(ibuf)		; ibuf on page boundary !!!
                 		ldi XH,HIGH(ibuf)
                 		ld tosl,X+
                 		adiw Z,1
                 		brtc PC+3
                 		  ld tosh,X+
                 		  adiw Z,1
                 		add_pflash_z
                 		ret
                 */
                 ISTORE_Z:
                 ;		rcall IUPDATEBUF
                 ;IUPDATEBUF:					; +++ begin inline IUPDATEBUF +++
003d02 58f0      		sub_pflash_Z
                 	  .ifdef  RAMPZ
                 	  .endif
                 ;XUPDATEBUF:
                 	  .ifdef RAMPZ
                 	  .endif
003d03 36e8      		cpi ZL, LOW(FLASH_HI-PFLASH+1) ; don't allow kernel writes
003d04 e517      		ldi t1,HIGH(FLASH_HI-PFLASH+1)
003d05 07f1      		cpc ZH,t1
003d06 f6f8      		  brcc ISTORERR				; ### ignore write and set buffer free ###
                 
                 	  .ifndef RAMPZ
                 		.if PAGESIZEB == 0x80		; ATmega328
003d07 15fd      		  cp ZH,ibaseH
003d08 f419      		    brne XUPDATEBUF3		; not equal -> fill buffer
003d09 25ec      		  eor ZL,ibaseL
003d0a f41a      		  brpl PC+4					; bits 7 equal -> skip buffer fill
003d0b 25ec      			eor ZL,ibaseL			; restore Z
                 		  XUPDATEBUF3:
003d0c db11      			rcall IFILL_BUFFER
003d0d 77ef      		    andi ZL,(PAGESIZEB-1)
                 
                 		.elif PAGESIZEB == 0x100
                 		.else .error "illegal value: PAGESIZEB"
                 		.endif
                 	  .else			; (RAMPZ defined)
                 	  .endif
                 								; +++ end inline +++
003d0e e0f2      		ldi ZH,high(ibuf)
003d0f f40e      		brtc PC+2
003d10 8391      		  std Z+1,tosh			; T-flag -> 'store word'
003d11 8380      		std Z+0,tosl
003d12 9af1      		sbi FLAGS3,idirty
003d13 c04b      		rjmp DROP_A
                 
                 FETCH1:
003d14 9468      		set
                 CFETCH1:
003d15 38f0      		cpi ZH,HIGH(OFLASH)
003d16 f6d8      		  brcc IFETCH
                 
003d17 99f9
003d18 cffe      EFETCH:   sbic EECR,EEWE	rjmp EFETCH	; EEPROM ready?
                 
003d19 50f9      		subi ZH,high(PEEPROM)
003d1a bdf2      		out EEARH,ZH
003d1b bde1      		out EEARL,ZL
003d1c ba6f      		out EECR,r_one			; (1<<EERE)
003d1d b580      		in tosl,EEDR
003d1e 9631      		adiw Z,1
003d1f f42e      		  brtc EFETCH_leave
003d20 bdf2      		out EEARH,ZH				
003d21 bde1      		out EEARL,ZL
003d22 ba6f      		out EECR,r_one			; (1<<EERE)
003d23 b590      		in tosh,EEDR
003d24 9631      		adiw Z,1				; for 'FETCH_Zplus'
                 EFETCH_leave:
003d25 5ff7      		subi ZH,HIGH(-PEEPROM)
003d26 9508      		ret
                 
                 
                 STORE1:
003d27 99f2      		sbic FLAGS3,fLOCK
003d28 cfbd      		  rjmp ISTORERR			; EEPROM + FLASH write protected
003d29 38f0      		cpi ZH,high(OFLASH)
003d2a f6b8      		  brcc ISTORE_Z
                 ;ESTORE_Z:
003d2b 50f9      		subi ZH,HIGH(PEEPROM)
                 
003d2c 99f9
003d2d cffe      ECS_wait: sbic EECR,EEWE	rjmp ECS_wait	; wait EEPROM ready
                 
003d2e bdf2      		  out EEARH,ZH
003d2f bde1      		  out EEARL,ZL
003d30 bd80      		  out EEDR,tosl
003d31 b70f      		  in_ t0,SREG
003d32 94f8      		  cli
003d33 e084      		  ldi tosl,(EEMPE<<1)
003d34 bb8f      		  out EECR,tosl
003d35 9af9      		  sbi EECR,EEWE
003d36 bf0f      		  out_ SREG,t0
003d37 f53e      		    brtc DROP_A
003d38 9631      		  adiw Z,1
003d39 2f89      		  mov tosl,tosh
003d3a 94e8      		  clt
003d3b cff0      		rjmp ECS_wait
                 
                 
                 .if FLASHEND > 0x3fff
                 .else
003d3c d89e      		fdw		innerINDEX_L
                 .endif
                 FETCH_L:
003d3d 4081      		.db		NFA|1, "@"
                 FETCH:
003d3e 01fc      		movw Z,TOP
                 FETCH_Zplus:
003d3f 30f9      		cpi ZH,HIGH(PEEPROM)
003d40 f698      		  brcc FETCH1
003d41 9181      		ld tosl,Z+
003d42 9191      		ld tosh,Z+
003d43 9508      		ret
                 
                 
003d44 eede      		fdw		CR_L
                 ; c@  ( adr -- c )				fetch char from adr
                 CFETCH_L:
003d45 6382
003d46 ff40      		.db		NFA|2, "c@",0xff
                 CFETCH:
003d47 01fc      		movw Z,TOP
                 CFETCH_Zplus:
003d48 2799      		clr tosh
003d49 94e8      		clt
003d4a 30f9      		cpi ZH,HIGH(PEEPROM)
003d4b f648      		  brcc CFETCH1
003d4c 9181      		ld tosl,Z+
003d4d 9508      		ret
                 
                 
003d4e fad0      		fdw		L_PCFETCH
                 ; pc!  ( c -- )					store char to address in pointer
                 PCSTORE_L:
003d4f 7083
003d50 2163      		.db		NFA|3,"pc!"
                 PCSTORE:
                 /*		movw Z,P					; can be inlined and double speed in RAM
                 		cpi ZH,HIGH(PEEPROM)		; (speed vs. size)
                 		brcs PCSTORE_RAM
                 		  clt
                 		  call STORE1
                 		  rjmp PCSTORE_exit
                 PCSTORE_RAM:
                 		std Z+0,tosl
                 		poptos
                 PCSTORE_exit:
                 		ret
                 */
003d51 94e8      		clt
003d52 01fa      		movw Z,P
003d53 c006      		rjmp STORE_Z
                 
                 
003d54 dd96      		fdw		NUM_L
                 ; !  ( n adr -- )				store n to adr
                 STORE_L:
                 kernellink_short:
003d55 2181      		.db		NFA|1, "!"
                 STORE:
003d56 9468      		set						; 'store word' flag
                 STORE_0:
003d57 01fc      		movw Z,TOP
003d58 9189
003d59 9199      		poptos
                 STORE_Z:
003d5a 30f9      		cpi ZH,high(PEEPROM)
003d5b f658      		  brcc STORE1
                 STORE_RAM_Z:
003d5c f40e      		brtc SRZ_b
                 SRZ_w:
003d5d 8391      		  std Z+1,tosh
                 SRZ_b:
003d5e 8380      		std Z+0,tosl
                 DROP_A:
003d5f 9189
003d60 9199      		poptos
003d61 9508      		ret
                 
                 
003d62 ec64      		fdw		CCOMMA_L
                 ; c!  ( c adr -- )				store char to adr
                 CSTORE_L:
003d63 6382
003d64 ff21      		.db		NFA|2, "c!",0xff
                 CSTORE:
003d65 94e8      		clt						; 'store char' flag
003d66 cff0      		rjmp STORE_0
                 
                 
003d67 dbe4      		fdw		PFL_L
                 ; pc@ ( -- c )					fetch char from address in pointer
                 L_PCFETCH:
003d68 7083
003d69 4063      		.db		NFA|3,"pc@"
                 ;PCFETCH:
003d6a 939a
003d6b 938a      		pushtos
003d6c 01fa      		movw Z,P
003d6d cfda      		rjmp CFETCH_Zplus
                 
                 
003d6e efe8      		fdw		R0_L
                 ; p@  ( -- n )					fetch word from address in pointer
                 PFETCH_L:
003d6f 7082
003d70 ff40      		.db		NFA|2,"p@",0xff
                 PFETCH:
003d71 939a
003d72 938a      		pushtos
003d73 01fa      		movw Z,P
003d74 cfca      		rjmp FETCH_Zplus
                 
                 
003d75 dc86      		fdw		PPLUS_L
                 ; p!  ( n -- )					store word to address in pointer
                 PSTORE_L:
003d76 7082
003d77 ff21      		.db		NFA|2,"p!",0xff
                 PSTORE:
                 /*		movw Z,P					; can be inlined and double speed in RAM
                 		cpi ZH,HIGH(PEEPROM)		; (speed vs. size)
                 		brcs PSTORE_RAM
                 		  set
                 		  call STORE1
                 		  rjmp PSTORE_exit
                 PSTORE_RAM:
                 		std Z+1,tosh
                 		std Z+0,tosl
                 		poptos
                 PSTORE_exit:
                 		ret
                 */
003d78 9468      		set
003d79 01fa      		movw Z,P
003d7a cfdf      		rjmp STORE_Z
                 
                 
003d7b eb88      		fdw		NEQUAL_L
                 ; ms  ( u -- )					pause for u milliseconds
                 ;	ticks +
                 ;	begin pause dup ticks = until drop ;
                 ;
                 MS_L:
003d7c 6d82
003d7d ff73      		.db		NFA|2,"ms",0xff
                 MS:
003d7e 0187      		movw t1t0,MS_COUNT
003d7f 0f80      		add tosl,t0
003d80 1f91      		adc tosh,t1
                 MS1:
003d81 d009      		  rcall PAUSE
003d82 0187      		  movw t1t0,MS_COUNT
003d83 1708      		  cp  t0,tosl
003d84 0719      		  cpc t1,tosh
003d85 f7d9      		brne MS1
003d86 cfd8      		rjmp DROP_A
                 
                 
003d87 ecca      		fdw		PLACE_L
                 ; PAUSE ( -- )					switch task
                 PAUSE_L:
003d88 7085
003d89 7561
003d8a 6573      		.db		NFA|5,"pause"
                 PAUSE:
003d8b 01f1      		movw Z,UP
                 	.if IDLE_MODE == 0
                 	.elif IDLE_MODE == 1
                 	  IDLE_LOAD:				; +++ inline IDLE_LOAD +++
003d8c ff71      			sbrs FLAGS2,fIDLE
003d8d c00f      			  rjmp IDLE_LOAD1		; 'busy' -> no sleep
003d8e 3ee2      			cpi ZL, LOW(up0)
003d8f f469      			  brne IDLE_LOAD1		; not in 'operator' task -> no sleep
003d90 30f2      			cpi ZH,HIGH(up0)
003d91 f459      			  brne IDLE_LOAD1		; not in 'operator' task -> no sleep
                 
003d92 9100 02b6 			lds t0,rbuf0_lv			; check rbuf0_lv/rbuf1_lv
                     	  .ifndef rbuf1_lv
003d94 2300      		  	tst t0
                 		  .else
                     	  .endif
003d95 f439      			  brne IDLE_LOAD1		; .. not empty -> no sleep
                 
                 		  .if CPU_LOAD_LED == 1
                     		  .if CPU_LOAD_LED_POLARITY == 1	; LED off
                     		  .else
                     		  .endif
                 		  .endif
                 
                 		  .ifdef SMCR				; buffers empty -> enable sleep mode
003d96 be63      			out_ SMCR,r_one
                 		  .else
                 		  .endif
                 
                 		  .if CPU_LOAD == 1
                 		  .endif
                 
                 		  .if OPERATOR_UART == 0	; #### must be placed right before 'sleep' ####
003d97 eb08      			ldi t0,(1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)|(1<<UDRIE0)
003d98 fd72      			sbrc FLAGS2,fTX0pending	; if a char for TX0 is pending
003d99 9300 00c1 			  out_ UCSR0B,t0		; .. enable UDRE0-interrupt (disabled by UDRE_ISR)
                 		  .endif
                 
003d9b 9588      			sleep		       		; enter sleep mode 'IDLE'
                 
                 		  .ifdef SMCR				; disable sleep mode
003d9c be73      			out_ SMCR,r_zero
                 		  .else
                 		  .endif
                 
                 		  .if CPU_LOAD_LED == 1
                     		  .if CPU_LOAD_LED_POLARITY == 1
                     		  .else
                     		  .endif
                 		  .endif
                 	  IDLE_LOAD1:
                 	.else
                 	.endif
                 
003d9d 95a8      		wdr						; watchdog reset
003d9e 973c      		sbiw Z,(-ulink)
003d9f 91a1      		ld XL,Z+				; get task link
003da0 91b1      		ld XH,Z+
003da1 15a2      		cp  XL,upL				; UP = ulink?
003da2 05b3      		cpc XH,upH
003da3 f0c9      		  breq PAUSE_exit		; ..yes -> single task, no switching
                 							; switch task
003da4 b71f      		in_ t1,SREG
003da5 94f8      		cli
003da6 93df      		push YH					; SP
003da7 93cf      		push YL
003da8 939f      		push tosh      			; TOS
003da9 938f      		push tosl
003daa 935f      		push ph					; P
003dab 934f      		push pl
003dac 01f1      		movw Z,UP
003dad b70e      		in t0,SPH				; write rsp to 'ursave'
003dae 9302      		st -Z,t0
003daf b70d      		in t0,SPL
003db0 9302      		st -Z,t0
003db1 011d      		movw UP,X
003db2 910e      		ld t0,-X
003db3 bf0e      		out SPH,t0
003db4 910e      		ld t0,-X
003db5 bf0d      		out SPL,t0
003db6 914f      		pop pl
003db7 915f      		pop ph
003db8 918f      		pop tosl
003db9 919f      		pop tosh
003dba 91cf      		pop YL
003dbb 91df      		pop YH
003dbc bf1f      		out_ SREG,t1
                 PAUSE_exit:
003dbd 9508      		ret						; 36 / 13..55+4 (busy)
                 
                 
003dbe f362      		fdw		ONEUNTIL_L
                 SCALE_L:
003dbf 3186
003dc0 3230
003dc1 2a34
003dc2 ff2f      		.db		NFA|6,"1024*/",0xff
                 SCALE:
003dc3 9109
003dc4 9119      		pop_t1t0
                 SCALE_0:
003dc5 dd61      		rcall umstar0_0			;	product32 in t7:t6:t5:t4
003dc6 95f6
003dc7 95e7
003dc8 95b7      		lsr t7	ror t6	ror t5	; '1.024 /' by shifting right 
003dc9 95f6
003dca 95e7
003dcb 95b7      		lsr t7	ror t6	ror t5	
003dcc 2f8b      		mov tosl,t5				; .. and dropping lower 8 bits
003dcd 2f9e      		mov tosh,t6
003dce 1d87      		adc tosl,r_zero			; rounding
003dcf 1d97      		adc tosh,r_zero			; 14 / 37
003dd0 9508      		ret			
                 
                 
003dd1 e3e6      		fdw		UDDOT_L
                 ; UD* ( ud u -- ud' )			unsigned 32 x 16 bit multiply to 32 bit
                 UDSTAR_L:
003dd2 7583
003dd3 2a64      		.db		NFA|3,"ud*"
                 ;UDSTAR:
003dd4 018c      		movw t1t0,TOP			; u    in t1t0 
003dd5 9189
003dd6 9199      		poptos					; ud.h in TOP
003dd7 dd4f      		rcall umstar0_0			; ud.h * u -> t7:t6:t5:t4, t1t0 unchanged
003dd8 015d      		movw A,t5t4				; save low part, drop high part (t7:t6)
003dd9 9189
003dda 9199      		poptos					; ud.l in TOP
003ddb dd4b      		rcall umstar0_0			; ud.l * u -> t7:t6:t5:t4
003ddc 93ba
003ddd 93aa      		push_t5t4				; push low part
003dde 01c5      		movw TOP,A				; get high part
003ddf 0f8e      		add tosl,t6				; accumulate high part to ud'.h
003de0 1f9f      		adc tosh,t7				; 13 / 63
003de1 9508      		ret
                 
                 
003de2 e918      		fdw		VER_L
                 UMSTAR_L:
003de3 7583
003de4 2a6d      		.db		NFA|3,"um*"
                 UMSTAR:
003de5 dd3f      		 rcall umstar0			; product32 in t7:t6:t5:t4
003de6 93ba
003de7 93aa      		 push_t5t4
003de8 01cf      		 movw TOP,t7t6
003de9 9508      		 ret
                 
                 
003dea d9de      		fdw		ULINK_L
                 USLASHMOD_L:
003deb 7585
003dec 6d2f
003ded 646f      		.db		NFA|5,"u/mod"
                 USLASHMOD:
003dee d01d      		rcall USLASH			; (tosh:tosl) / (t5:t4) -> (tosh:tosl) (t3:t2[rem])
003def 921a
003df0 920a      		push_t3t2
003df1 9508      		ret
                 
003df2 ec76      		fdw		NTOC_L
                 MOD_L:
003df3 6d83
003df4 646f      		.db		NFA|3,"mod"
                 MOD:						; unsigned values only
003df5 d016      		 rcall USLASH			; remainder returned in t3:t2
003df6 01c0      		 movw TOP,t3t2
                 GCD_xxx:
003df7 9508      		 ret
                 
                 
003df8 d7ea      		fdw		HEX_L
                 ; gcd (u1 u2 -- gcd )		greatest common divider
                 GCD_L:
003df9 6783
003dfa 6463      		.db		NFA|3,"gcd"
                 GCD:
003dfb 9109
003dfc 9119      		pop_t1t0
                 GCD_loop:
003dfd 1780      		cp  tosl,t0
003dfe 0791      		cpc tosh,t1
003dff f3b9      		  breq GCD_xxx
003e00 f418      		  brcc GCD_u1less
                 GCD_u2less:
003e01 1b08      		sub t0,tosl
003e02 0b19      		sbc t1,tosh
003e03 cff9      		rjmp GCD_loop
                 
                 GCD_u1less:
003e04 1b80      		sub tosl,t0
003e05 0b91      		sbc tosh,t1
003e06 cff6      		rjmp GCD_loop
                 
                 
                 usm0_err:
003e07 9468      		set
003e08 cdd4      		rjmp WARM_math
                 
                 
003e09 e244      		fdw		ULESS_L
                 USLASH_L:
003e0a 7582
003e0b ff2f      		.db		NFA|2,"u/",0xff
                 USLASH:
003e0c 01dc      		movw t5t4,TOP
003e0d 9189
003e0e 9199      		poptos
                 		;rjmp uslashmod0
                 							; unsigned 16 16 -- 16 16 division
                 uslashmod0:						; (tosh:tosl) / (t5:t4) -> (tosh:tosl) (t3:t2[rem])
003e0f 2400      		clr t2
003e10 2411      		clr t3
                 uslashmod0_0:
003e11 94e8      		clt
                 udsm0_second:					; for t3t2 < t5t4 ONLY
003e12 e008      		ldi t0,16/2
                 
                 .if optimizeNUM == 0
                 .elif optimizeNUM == 1
003e13 23bb      		tst t5
003e14 f569      		  brne usm0_x_16
003e15 23aa      		tst t4
003e16 f381      		  breq usm0_err
                 
                   usm0_x_8:						; divisorH = 0
003e17 f09e      		brts usm0_full_8
                 							; t3t2 = 0
003e18 2399      		tst tosh
003e19 f489      		  brne usm0_full_8
                 								; dividentH = 0
003e1a 178a      		cp tosl,t4
003e1b f110      		  brcs usm0_below		; -> (divident < divisor)
003e1c f421      		  brne usm0_8_8
                   ;		  breq usm0_equal		; -> (divident = divisor)
                   usm0_equal:
003e1d 01c3      		movw TOP,r_one
003e1e 9508      		ret						; (uslashmod0: 15+4 for divident = divisor, both < 0x0100)
                 								; (            14+4 for divident = divisor, both > 0x00ff)
                 	usm0_8_8_zero:
003e1f 950a      		dec t0
003e20 f049      		breq usm0_8_8_done
                   usm0_8_8:						; (divident > divisor)
                 	usm0_8_8_loop:
003e21 0f88      		  lsl tosl
003e22 1c00      		  rol t2
003e23 f010      		    brcs usm0_8_8_one
003e24 160a      		  cp t2,t4
003e25 f3c8      		  brcs usm0_8_8_zero
                 	usm0_8_8_one:
003e26 1a0a      		    sub t2,t4
003e27 9583      			inc tosl
                 	usm0_8_8_next:
003e28 950a      		dec t0
003e29 f7b9      		brne usm0_8_8_loop
                 	usm0_8_8_done:
                 		;push_t3t2				; remainder in t3t2
003e2a 9508      		ret						; (uslashmod0: 79..95+4 for divident and divisor < 0x0100)
                 
                   usm0_full_8:
                   ;		ldi t0,16/2				; 2-bit loop (save 10..24 ticks using 8 words)
                 	usm0_full_8_loop:
003e2b 0f88      		  lsl tosl
003e2c 1f99      		  rol tosh
003e2d 1c00      		  rol t2
003e2e f010      		    brcs usm0_full_8_one1
003e2f 160a      		  cp t2,t4
003e30 f010      		  brcs usm0_full_8_bit2
                 	usm0_full_8_one1:
003e31 1a0a      			sub t2,t4
003e32 9583      			inc tosl
                 	
                 	usm0_full_8_bit2:
003e33 0f88      		  lsl tosl
003e34 1f99      		  rol tosh
003e35 1c00      		  rol t2
003e36 f010      		    brcs usm0_full_8_one2
003e37 160a      		  cp t2,t4
003e38 f010      		  brcs usm0_full_8_next
                 	usm0_full_8_one2:
003e39 1a0a      			sub t2,t4
003e3a 9583      			inc tosl
                 	usm0_full_8_next:
003e3b 950a      		dec t0
003e3c f771      		brne usm0_full_8_loop
                 
                 		;push_t3t2				; remainder in t3t2
003e3d 9508      		ret						; (uslashmod0: 146..164+4 for divisor < 0x0100)
                 
                   usm0_below:
003e3e 010c      		movw t3t2,TOP			
003e3f 2788      		clr tosl
003e40 2799      		clr tosh
003e41 9508      		ret						; (uslashmod0: 17+4 for divident < divisor, both < 0x0100)
                 								; (            15+4 for divident < divisor, both > 0x0100)
                 
                   usm0_x_16:					; divisorH > 0
003e42 f09e      		brts usm0_full_16
                 							; t3t2 = 0
003e43 178a      		cp  tosl,t4
003e44 079b      		cpc tosh,t5
003e45 f3c0      		  brcs usm0_below		; -> (divident < divisor)
003e46 f2b1      		  breq usm0_equal		; -> (divident = divisor)
                 							; (divident > divisor)
                   usm0_16_16:		
003e47 2e09      		mov t2,tosh			; .. (t3t2=0) -> 8<< (fast shift first 8)
003e48 2799      		clr tosh
                 	;	ldi t0,16-8
                 	usm0_16_16_loop:
003e49 0f88      		  lsl tosl
003e4a 1c00      		  rol t2
003e4b 1c11      		  rol t3
003e4c f018      		    brcs usm0_16_16_one
003e4d 160a      		  cp  t2,t4
003e4e 061b      		  cpc t3,t5
003e4f f018      		  brcs usm0_16_16_next
                 	usm0_16_16_one:
003e50 1a0a      		    sub t2,t4
003e51 0a1b      			sbc t3,t5
003e52 9583      			inc tosl
                 	usm0_16_16_next:
003e53 950a      		dec t0
003e54 f7a1      		brne usm0_16_16_loop
                 		; push_t3t2				; remainder in t3t2
003e55 9508      		ret						; (uslashmod0: 100..116+4 for divisor > 0x00ff)
                 .endif ;(optimizeNUM == 1)
                 
                 usm0_full_16:
                 	usm0_full_16_loop:			; 2-bit loop (save 10..24 ticks using 11 words)
003e56 0f88      		  lsl tosl
003e57 1f99      		  rol tosh
003e58 1c00      		  rol t2
003e59 1c11      		  rol t3
003e5a f018      			brcs usm0_full_16_one1
003e5b 160a      		  cp t2,t4
003e5c 061b      		  cpc t3,t5
003e5d f018      		  brcs usm0_full_16_bit2
                 	usm0_full_16_one1:
003e5e 1a0a      			sub t2,t4
003e5f 0a1b      			sbc t3,t5
003e60 9583      			inc tosl
                 
                 	usm0_full_16_bit2:
003e61 0f88      		  lsl tosl
003e62 1f99      		  rol tosh
003e63 1c00      		  rol t2
003e64 1c11      		  rol t3
003e65 f018      			brcs usm0_full_16_one2
003e66 160a      		  cp t2,t4
003e67 061b      		  cpc t3,t5
003e68 f018      		  brcs usm0_full_16_next
                 	usm0_full_16_one2:
003e69 1a0a      			sub t2,t4
003e6a 0a1b      			sbc t3,t5
003e6b 9583      			inc tosl
                 	usm0_full_16_next:
003e6c 950a      		dec t0
003e6d f741      		brne usm0_full_16_loop
                 	usm0_full_16_done:
                 		; push_t3t2				; remainder in t3t2
003e6e 9508      		ret						; (uslashmod0: 177..209+4 for divisor > 0x00ff)
                 
                 
003e6f ef2a      		fdw		COLON_L
                 SLASH_L:
003e70 2f81      		.db		NFA|1,"/"
                 ;SLASH:
003e71 01dc      		movw t5t4,TOP			; divisor
003e72 9189
003e73 9199      		poptos					; divident
003e74 2f0b      		mov t0,t5
003e75 2709      		eor t0,tosh
003e76 930f      		push t0					; save 'sign xor sign'
003e77 fd97      		sbrc tosh,7
003e78 dcca      		  rcall NEGATE			; (speed vs. size)
003e79 23bb      		tst t5
003e7a f41a      		brpl SLASH_1
003e7b 95a0      		  com t4
003e7c 95b0      		  com t5
003e7d 9611      		  adiw t5t4,1
                 SLASH_1:
003e7e df90      		rcall uslashmod0
                 
003e7f 910f      		pop t0					; resulting sign
003e80 fd07      		sbrc t0,7
003e81 ccc1      		  rjmp NEGATE			; (speed vs. size)
003e82 9508      		ret
                 
                 
003e83 e198      		fdw		CQUOTE_L
                 PLUSSTORE_L:
003e84 2b82
003e85 ff21      		.db		NFA|2,"+!",0xff
                 ;PLUSSTORE:
003e86 deb7      		rcall FETCH				; leaves valid Z+2
003e87 9732      		sbiw Z,2
003e88 9109
003e89 9119      		pop_t1t0
003e8a 0f80      		add tosl,t0
003e8b 1f91      		adc tosh,t1
003e8c 9468      		set						; write word
003e8d cecc      		rjmp STORE_Z
                 
                 
003e8e db70      		fdw		MCSTORE_L
                 MAX_L:
003e8f 6d83
003e90 7861      		.db		NFA|3,"max"
                 MAX:
003e91 9109
003e92 9119      		 pop_t1t0				; NEXT
                 ;MAX_0:
003e93 01f8      		 movw t7t6,t1t0
003e94 27f9      		 eor t7,tosh
003e95 01f8      		 movw t7t6,t1t0
003e96 f012      		   brmi MAX_1
003e97 1be8      		 sub t6,tosl			; NEXT-TOP
003e98 0bf9      		 sbc t7,tosh
                 MAX_1:
003e99 fff7      		 sbrs t7,7				; -> max = TOP
003e9a 01c8      		   movw TOP,t1t0		; max = NEXT
003e9b 9508      		 ret
                 
                 
003e9c fbe6      		fdw		MOD_L
                 MIN_L:
003e9d 6d83
003e9e 6e69      		.db		NFA|3,"min"
                 MIN:
003e9f 9109
003ea0 9119      		 pop_t1t0				; NEXT
                 ;MIN_0:
003ea1 01fc      		 movw t7t6,TOP
003ea2 27f1      		 eor t7,t1				; check signs
003ea3 01fc      		 movw t7t6,TOP
003ea4 f012      		   brmi MIN_1			; -> different signs
003ea5 1be0      		 sub t6,t0				; TOP-NEXT
003ea6 0bf1      		 sbc t7,t1
                 MIN_1:
003ea7 fff7      		 sbrs t7,7				; -> min = TOP
003ea8 01c8      		   movw TOP,t1t0		; min = NEXT
003ea9 9508      		 ret
                 
                 
003eaa e1c2      		fdw		EXIT_L
                 ; EMIT ( c -- )					output character to the UEMIT vector
                 EMIT_L:
003eab 6584
003eac 696d
003ead ff74      		.db		NFA|4,"emit",0xff
                 EMIT:
003eae eea8      		ldi XL,uemit
                 UEXECUTE:
003eaf efbf      		ldi XH,0xff
003eb0 0da2      		add XL,upl
003eb1 1db3      		adc XH,uph
003eb2 91ed      		ld ZL,X+
003eb3 91fd      		ld ZH,X+
003eb4 c013      		rjmp EXECUTE_0			; 7 / 15
                 
                 
003eb5 edd6      		fdw		DOLIT_L
                 ; KEY  ( -- c )					get char from UKEY vector
                 KEY_L:
003eb6 6b83
003eb7 7965      		.db		NFA|3,"key"
                 KEY:
003eb8 eeaa      		ldi XL,ukey
003eb9 cff5      		rjmp UEXECUTE			; 2 / 17
                 
                 
                 .if CPU_LOAD == 0
003eba f468      		fdw		LOOP_L
                 .elif CPU_LOAD == 1
                 .else .error "illegal value: CPU_LOAD"
                 .endif
                 ; KEY  ( -- c )					check for char from UKEYQ vector
                 KEYQ_L:
003ebb 6b84
003ebc 7965
003ebd ff3f      		.db		NFA|4,"key?",0xff
                 KEYQ:
003ebe eeac      		ldi XL,ukeyq
003ebf cfef      		rjmp UEXECUTE			; 2 / 17
                 
                 
003ec0 f0a2      		fdw		INLINED_L
                 EXECUTE_L:
003ec1 6587
003ec2 6578
003ec3 7563
003ec4 6574      		.db		NFA|7,"execute"
                 EXECUTE:
003ec5 01fc      		movw Z,TOP
003ec6 9189
003ec7 9199      		poptos
                 EXECUTE_0:
003ec8 58f0      		sub_pflash_z
003ec9 95f6      		lsr ZH
003eca 95e7      		ror ZL
003ecb 9409      		mijmp					; 7 / 10
                 
                 
003ecc f6d6      		fdw		BRACTICK_L
                 FEXECUTE_L:
003ecd 4083
003ece 7865      		.db		NFA|3,"@ex"
                 FEXECUTE:
003ecf de6e      		rcall FETCH
003ed0 cff4      		rjmp EXECUTE
                 
                 
                 .if CPU_LOAD == 1
                 .elif CPU_LOAD > 1
                 .endif
                 
                 .org BOOT_START - 0x2f
                 OF_ISR_EXIT:
                 ;		pop t3					; save ticks ... activate when needed
                 ;		pop t2					; ###################### see 'OF_ISR' ##############################
003ed1 911f      		pop t1
003ed2 910f      		pop t0
003ed3 91ff      		pop ZH					; t7	
003ed4 91ef      		pop ZL					; t6
003ed5 bf3f      		out_ SREG,SREG_intSafe
003ed6 01d2        		movw X,intSafe16		; t5:t4
003ed7 9518      		reti
003ed8 ffff
003ed9 ffff      		.dw 0xffff,0xffff		; ############### placeholder for 'pop t2    pop t3' ###############
                 		 
                 .org BOOT_START - 0x26
                 RX0_VECTOR:
003eda 012f      		movw intSafe16,Z
003edb 91e0 02a4 		lds ZL,(URXCaddr+ivec)
003edd 91f0 02a5 		lds ZH,(URXCaddr+ivec+1)
003edf 9409      		mijmp
                 
                 .org BOOT_START - 0x20			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 MS_TIMER_ISR:
                   .if CPU_LOAD == 0
003ee0 b73f      		in_ SREG_intSafe,SREG
003ee1 0ce6      		add ms_countL,r_one
003ee2 1cf7      		adc ms_countH,r_zero
003ee3 bf3f      		out_ SREG,SREG_intSafe
003ee4 9518      		reti
                   .elif CPU_LOAD == 1			
                   .else .error "illegal value: CPU_LOAD"
                   .endif
                 
                 
                 .org BOOT_START - 0x1b			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 OF_ISR:
003ee5 012d      		movw intSafe16,X		; t5:t4
                 	.if CPU_LOAD == 1
                 	.endif
                 
003ee6 93ef      		push ZL					; t6
003ee7 93ff      		push ZH					; t7
003ee8 930f      		push t0
003ee9 931f      		push t1
                 ;		push t2					; save ticks ... activate when needed
                 ;		push t3					; ###################### see 'OF_ISR_EXIT' #########################
003eea 2fa3      		mov XL,INTvector
003eeb e0b2      		ldi XH,HIGH(ivec)
003eec b73f      		in_ SREG_intSafe,SREG	; (INTvector = SREG_intSafe = R19)
003eed 91ed      		ld ZL,X+
003eee 91fd      		ld ZH,X+
003eef 9409      		mijmp
003ef0 ffff
003ef1 ffff      		.dw 0xffff,0xffff		; ############### placeholder for 'push t2    push t3' ############# 
                 	.if CPU_LOAD == 0
003ef2 ffff
003ef3 ffff
003ef4 ffff      		  .dw 0xffff,0xffff,0xffff
                 	.elif CPU_LOAD == 1
                 	.else .error "illegal value: CPU_LOAD"
                 	.endif
                 
                 .org BOOT_START - 0x0b			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 INTx16_VECTOR:
                   .if CPU_LOAD == 0
003ef5 e936      			ldi INTvector,0x16 + LOW(ivec)
003ef6 cfee      		    rjmp OF_ISR
003ef7 ffff      			.dw 0xffff
                   .elif CPU_LOAD == 1				; -> load-timer interrupt
                   .else .error "illegal value: CPU_LOAD"
                   .endif 
                 
                 .org BOOT_START - 0x08			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 UDRE_VECTOR:
                   .if IDLE_MODE == 0
                   .elif IDLE_MODE == 1
                 	.if CPU_LOAD == 0
                 	  UDRE_ISR:
003ef8 e938      			ldi INTvector,(1<<RXEN0)|(1<<TXEN0)|(1<<RXCIE0)
003ef9 9330 00c1 			out_ UCSR0B,INTvector	; disable UDRE0-interrupt
003efb 9518      			reti
003efc ffff
003efd ffff
003efe ffff      			.dw 0xffff,0xffff,0xffff
                 	.elif CPU_LOAD == 1
                 	.else .error "illegal value: CPU_LOAD" 
                 	.endif  ; (CPU_LOAD)
                   .else .error "illegal value: IDLE_MODE"
                   .endif	; (IDLE_MODE)
                 
                 .org BOOT_START - 0x01			; DO NOT CHANGE !! (requires reburning of bootloader part)
                 WARM_VECTOR:
003eff cce0      			rjmp WARM_0
                 
                 ; ################################################################################ ;
                 ;                                                                                  ;
                 ; OptiForth + Arduino bootloader                                                             ; 
                 ;                                                                                  ;
                 ; based on Optiboot (https://githib.com/Optiboot/optiboot)                         ;
                 ;  "Although it has evolved considerably, Optiboot builds on the original work     ;
                 ;   of Jason P. Kyle (stk500boot.c), Arduino group (bootloader),                   ;
                 ;   Spiff (1K bootloader), AVR-Libc group and Ladyada (Adaboot).                   ;
                 ;                                                                                  ;
                 ;   Optiboot is the work of Peter Knight (aka Cathedrow). Despite some             ;
                 ;   misattributions, it is not sponsored or supported by any organisation          ;
                 ;   or company including Tinker London, Tinker.it! and Arduino.                    ;
                 ;   Maintenance of optiboot was taken over by Bill Westfield (aka WestfW) in 2011.";
                 ;                                                                                  ;
                 ; fits into 256 words of FLASH                                                     ; 
                 ;                                                                                  ;
                 ; extended functions:                                                              ;
                 ;   - save MCUSR reset status in R0                                                ;
                 ;   - increased USART speed   (250.000 baud standard)                              ;
                 ;   - read/write EEPROM                                                            ;
                 ;   - read FUSE                                                                    ;
                 ;   - read/write LOCK bits                                                         ;
                 ;   - read SIGNATURE from MCU (if enabled)                                         ;
                 ;   - read OSCCAL             (if enabled)                                         ;
                 ;                                                                                  ;
                 ; MIT License                                                                      ;
                 ;                                                                                  ;
                 ; Copyright (c) 2021 bitflipser                                                    ;
                 ;                                                                                  ;
                 ; Permission is hereby granted, free of charge, to any person obtaining a copy     ;
                 ; of this software and associated documentation files (the "Software"), to deal    ;
                 ; in the Software without restriction, including without limitation the rights     ;
                 ; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell        ;
                 ; copies of the Software, and to permit persons to whom the Software is            ;
                 ; furnished to do so, subject to the following conditions:                         ;
                 ;                                                                                  ;
                 ; The above copyright notice and this permission notice shall be included in all   ;
                 ; copies or substantial portions of the Software.                                  ;
                 ;                                                                                  ;
                 ; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR       ;
                 ; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,         ;
                 ; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE      ;
                 ; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER           ;
                 ; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,    ;
                 ; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE    ;
                 ; SOFTWARE.                                                                        ;
                 ;                                                                                  ;
                 ; ################################################################################ ;
                 
                 ;.equ HW_VER   = 3
                 .equ SW_MAJOR = 5
                 .equ SW_MINOR = $6d
                 
                 ; 1 - ###############
                 ;     select MCU type
                 
                 ; ######### tested for ATmega328/P ONLY ###########
                 .equ ATmega = 328
                 ; #################################################
                 
                 ; 2 - ###################
                 ;     select MCU sub type
                 
                 ;.equ subType= 0			; no letter
                 ;.equ subType= 1			; A
                 ;.equ subType= 2			; L
                 .equ subType= 3			; P
                 ;.equ subType= 4			; PA
                 ;.equ subType= 5			; V
                 
                 ; 3 - ################
                 ;     select frequency
                 
                 ;.equ F_CPU= 20			; 20 MHz
                 .equ F_CPU= 16			; 16 MHz
                 ;.equ F_CPU= 10			; 10 MHz
                 ;.equ F_CPU=  8			;  8 MHz
                 ;.equ F_CPU=  1			;  1 MHz
                 
                 ; 4 - ##############
                 ;     select Vtarget
                 
                 .equ Vtarget = 50		; 5,0 V
                 ;.equ Vtarget = 33		; 3,3 V
                 ;.equ Vtarget = xy		; x,y V - set value
                 
                 ; 5 - ##############################################
                 ;     select standard or high-speed USART connection
                 
                 ;.equ USARTspeed= 0			; standard baud rates 
                 .equ USARTspeed= 1			; increased USART speed, better timing accuracy
                 
                 ; 6 - ########################
                 ;     select Watchdog Time Out
                 
                 ;.equ WDtimeOut = 0x0c		; 250 ms
                 ;.equ WDtimeOut = 0x0d		; 500 ms
                 .equ WDtimeOut = 0x0e		;   1 s
                 ;.equ WDtimeOut = 0x0f		;   2 s
                 ;.equ WDtimeOut = 0x28		;   4 s
                 ;.equ WDtimeOut = 0x29		;   8 s
                 
                 ; 7 - ######################
                 ;     memory saving specials
                 
                 .equ noADDRpreset		 =1	; uncomment to save  2 words: (it's not needed with avrdude)
                 .equ noLED_START_FLASH	 =1	; uncomment to save 14 words: LED will NOT blink at start
                 .equ noVtarget			 =1	; uncomment to save  4 words: Vtarget-reply will be 2.0 V
                 .equ noOSCCAL			 =1	; uncomment to save  5 words: STK_READ_OSCCAL will return 0
                 .equ noSIGfromMCU		 =1	; uncomment to save 10 words: SIGNATURE taken from bootloader code instead of MCU
                 ;   includes noOSCCAL=1
                 
                 ; 8 - ###################
                 ;     set LED port values
                 
                 .equ LED_DDR  = DDRB
                 .equ LED_PORT = PORTB
                 .equ LED_PIN  = PINB
                 .equ LEDpin   = 5
                 
                 
                 .equ SIG_1=0x1e
                 
                 .if ATmega == 328
                 	.set SIG_2=0x95
                 	.if subType==0
                 	.elif subType==3
                 		.equ SIG_3=0x0f
                 		.LIST
                 	.else
                 	.endif
                 .endif
                 
                 .if F_CPU == 20
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 	.endif
                 .endif
                 
                 .if F_CPU == 16
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 		; high-speed baud rates
                 		.set Baud = 0x0003				;  250.000 baud:  0,0%
                 		;.set Baud = 0x0001				;  500.000 baud:  0,0%
                 		;.set Baud = 0x0000				;1.000.000 baud:  0,0%
                 		.set doubleSpeed = 0
                 	.endif
                 .endif
                 
                 .if F_CPU == 10
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 	.endif
                 .endif
                 
                 .if F_CPU == 8
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 	.endif
                 .endif
                 
                 .if F_CPU == 1
                 	.if USARTspeed == 0
                 	.elif USARTspeed == 1
                 	.endif
                 .endif
                 
                 .equ USARTbase	= UCSR0A
                 .equ oUCSR0A	= UCSR0A-USARTbase		; register offsets to be accessed with ldd/std and Y+d
                 .equ oUCSR0B	= UCSR0B-USARTbase
                 .equ oUCSR0C	= UCSR0C-USARTbase
                 .equ oUBRR0L	= UBRR0L-USARTbase
                 .equ oUBRR0H	= UBRR0H-USARTbase
                 .equ oUDR0		= UDR0  -USARTbase
                 
                 .equ buff = 0x200						; bootloader buffer addr in SRAM - DO NOT CHANGE!!!
                 
                 .if withBOOTLOADER == 0				; w/o bootloader
                 	.equ RESET_				= BOOT_START
                 	.equ DO_PAGE_ERASE		= BOOT_START + 0x34
                 	.equ DO_SPM				= BOOT_START + 0x35
                 	.equ WRITE_FLASH_PAGE	= BOOT_START + 0xe0
                 .else 								;with bootloader
                 	  .if MS_TIMER_ADDR == 0x08
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x0e
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x12
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x14
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x16
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x18
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x1a
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x1c
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x1e
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x20
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x22
                 	  .else
                 	  .endif
                 	  .if MS_TIMER_ADDR == 0x2a
                 	  .else
                 	  .endif
                 	.ifdef MCUCSR					; save MCU state for application program
                 	.endif
                 	.ifdef MCUSR
                 	.endif
                 	.ifndef noADDRpreset
                 	.endif
                 	.if doubleSpeed == 1
                 	.endif
                 	.if Baud == 0
                 	.else
                 	.endif
                 	.ifndef noLED_START_FLASH
                 	 .if F_CPU == 16 || F_CPU == 20
                 	 .else
                 	 .endif
                 	 .if F_CPU > 1					; start TC1
                 	 .else
                 	 .endif
                 	.else
                 	.endif
                 	  .ifndef noVtarget
                 	  .else						; noVtarget == 1
                 	  .endif
                 	  .ifndef noVtarget
                 	  .else
                 	  .endif
                 	.ifndef noSIGfromMCU
                 	.else
                 	.endif
                 	.ifndef noOSCCAL
                 	 .ifndef noSIGfromMCU		
                 	  .endif
                 	.endif
                 .endif ; (appendBOOTLOADER == 1)
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

ATmega328P register use summary:
r0 :  75 r1 :  50 r2 :  44 r3 :   3 r4 :   4 r5 :   0 r6 :  18 r7 :  52 
r8 :  23 r9 :   6 r10:   9 r11:   8 r12:   6 r13:   8 r14:   6 r15:   1 
r16: 373 r17: 214 r18:   0 r19:  10 r20:  20 r21:  10 r22:  59 r23:  35 
r24: 771 r25: 527 r26: 155 r27: 101 r28:   6 r29:   9 r30: 150 r31: 150 
x  :  80 y  : 570 z  : 241 
Registers used: 33 out of 35 (94.3%)

ATmega328P instruction use summary:
.lds  :   0 .sts  :   0 adc   :  51 add   :  43 adiw  :  61 and   :   6 
andi  :  30 asr   :   5 bclr  :   0 bld   :   2 brbc  :   0 brbs  :   0 
brcc  :  31 brcs  :  46 break :   0 breq  :  52 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   5 
brne  :  54 brpl  :   8 brsh  :   0 brtc  :   8 brts  :   2 brvc  :   4 
brvs  :   1 bset  :   0 bst   :   1 call  :   7 cbi   :   4 cbr   :  46 
clc   :   0 clh   :   0 cli   :   9 cln   :   0 clr   :  36 cls   :   0 
clt   :  12 clv   :   0 clz   :   0 com   :  22 cp    :  36 cpc   :  30 
cpi   :  60 cpse  :   9 dec   :  16 eor   :  14 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   1 ijmp  :   6 in    :  39 inc   :  16 jmp   :   1 
ld    : 323 ldd   :  35 ldi   : 260 lds   :  45 lpm   :  23 lsl   :  27 
lsr   :  16 mov   :  48 movw  : 163 mul   :  28 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :  23 ori   :  16 out   :  51 pop   :  56 
push  :  37 rcall : 354 ret   : 219 reti  :   4 rjmp  : 246 rol   :  24 
ror   :  36 sbc   :  58 sbci  :  10 sbi   :   6 sbic  :  10 sbis  :   1 
sbiw  :  94 sbr   :  26 sbrc  :  35 sbrs  :  21 sec   :   1 seh   :   0 
sei   :   4 sen   :   0 ser   :   2 ses   :   0 set   :  12 sev   :   0 
sez   :   0 sleep :   1 spm   :   0 st    : 347 std   :  23 sts   :  29 
sub   :  36 subi  :  55 swap  :   3 tst   :  15 wdr   :   6 
Instructions used: 79 out of 113 (69.9%)

ATmega328P memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x007e00   7370   2512   9882   32768  30.2%
[.dseg] 0x000100 0x0003be      0    702    702    2048  34.3%
[.eseg] 0x000000 0x000002      0      2      2    1024   0.2%

Assembly complete, 0 errors, 23 warnings
